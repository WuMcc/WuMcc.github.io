<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dreamlegs</title>
  
  <subtitle>Love Coding</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-22T09:31:39.877Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>wmc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安卓开发</title>
    <link href="http://example.com/2024/06/22/2024-06-22-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2024/06/22/2024-06-22-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/</id>
    <published>2024-06-22T06:32:32.000Z</published>
    <updated>2024-06-22T09:31:39.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AndroidStudio新建项目"><a href="#AndroidStudio新建项目" class="headerlink" title="AndroidStudio新建项目"></a>AndroidStudio新建项目</h1><h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><h3 id="1-gradle和-idea"><a href="#1-gradle和-idea" class="headerlink" title="1. .gradle和.idea"></a>1. .gradle和.idea</h3><p>自动生成的文件</p><h3 id="2-app"><a href="#2-app" class="headerlink" title="2. app"></a>2. app</h3><p>项目中运行的代码资源都放在此文件夹下类似于src。</p><h3 id="3-build"><a href="#3-build" class="headerlink" title="3. build"></a>3. build</h3><p>包含编译时自动生成的文件</p><h3 id="4-gradle"><a href="#4-gradle" class="headerlink" title="4. gradle"></a>4. gradle</h3><p>包含了gradle wrapper配置文件</p><h3 id="5-gitignore"><a href="#5-gitignore" class="headerlink" title="5. .gitignore"></a>5. .gitignore</h3><p>版本控制</p><h3 id="6-build-gradle"><a href="#6-build-gradle" class="headerlink" title="6. build.gradle"></a>6. build.gradle</h3><p>项目全局的gradle构建脚本</p><h3 id="7-gradle-properties"><a href="#7-gradle-properties" class="headerlink" title="7.  gradle.properties"></a>7.  gradle.properties</h3><p>全局配置文件</p><h3 id="8-gradlew和gradle-bat"><a href="#8-gradlew和gradle-bat" class="headerlink" title="8. gradlew和gradle.bat"></a>8. gradlew和gradle.bat</h3><p>用于在命令行界面执行gradle命令，gradlew在Linux或mac，后者运行于Windows</p><h3 id="9-helloworld-iml"><a href="#9-helloworld-iml" class="headerlink" title="9. helloworld.iml"></a>9. helloworld.iml</h3><p>所有IDEA项目都会生成用于标识项目</p><h3 id="10-local-properties"><a href="#10-local-properties" class="headerlink" title="10. local.properties"></a>10. local.properties</h3><p>指定本机sdk路径</p><h3 id="11-settings-gradle"><a href="#11-settings-gradle" class="headerlink" title="11. settings.gradle"></a>11. settings.gradle</h3><p>用于指定项目中所有引用的模块</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240622144047475.png" alt="image-20240622144047475"></p><h2 id="app目录"><a href="#app目录" class="headerlink" title="app目录"></a>app目录</h2><h3 id="androidTest和test都是用来测试的"><a href="#androidTest和test都是用来测试的" class="headerlink" title="androidTest和test都是用来测试的"></a>androidTest和test都是用来测试的</h3><h3 id="主要代码都在main里面，Java包中编写，res下放资源相关。图片一般放在res的mipmap的xxhdpi。"><a href="#主要代码都在main里面，Java包中编写，res下放资源相关。图片一般放在res的mipmap的xxhdpi。" class="headerlink" title="主要代码都在main里面，Java包中编写，res下放资源相关。图片一般放在res的mipmap的xxhdpi。"></a>主要代码都在main里面，Java包中编写，res下放资源相关。图片一般放在res的mipmap的xxhdpi。</h3><h2 id="查看res目录下资源意义"><a href="#查看res目录下资源意义" class="headerlink" title="查看res目录下资源意义"></a>查看res目录下资源意义</h2><h3 id="res-values-strings-xml"><a href="#res-values-strings-xml" class="headerlink" title="res&#x2F;values&#x2F;strings.xml"></a>res&#x2F;values&#x2F;strings.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;app_name&quot;</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在代码中，通过R.string.app_name可以获取该字符串引用</li><li>在xml中，通过@string&#x2F;app_name获取该字符串引用</li></ul><p>其中string部分可以替换，如果引用图片资源替换成drawable，应用图标换为mipmap，布局文件替换为layout。</p><h2 id="build-gradle文件"><a href="#build-gradle文件" class="headerlink" title="build.gradle文件"></a>build.gradle文件</h2><p>外层用于全局配置。</p><p>app中的build.gradle中，</p><ul><li>plugin用于选择程序模块，Android.library和Android.application，一般选择后者，后者可以直接运行。</li><li>如果需要使用kotlin需要导入kotlin-android和kotlin-android-extensions插件</li><li>android闭包中千刀的defaultConfig闭包可以对项目细节进行配置：applicationId是每个应用唯一标识（包名），minSdkVersion：指定项目最低兼容安卓版本。targetSdkVersion：指定在这个目标版本上作了充分测试，可以使用这个版本的所有特性。versionCode：指定版本号。versionName：版本名</li><li>buildTypes闭包：release：指定生成的正式版安装文件的配置。minifyEnabled：true表示混淆</li><li>dependencies：指定依赖关系</li></ul><h2 id="日志工具掌握"><a href="#日志工具掌握" class="headerlink" title="日志工具掌握"></a>日志工具掌握</h2><h3 id="Log工具类"><a href="#Log工具类" class="headerlink" title="Log工具类"></a>Log工具类</h3><p>log.v():打印最为琐碎的意义最小的日志信息，对应<code>verbose</code>级别</p><p>log.d():打印一些调试信息，对应<code>debug</code></p><p>log.i():打印一些比较重要的信息，可以帮助分析用户行为，<code>info</code></p><p>log.w():打印警告信息，<code>warn</code></p><p>log.e():打印错误信息,<code>error</code></p><p><strong>级别依次递增</strong></p><p>使用Logcat进行日志调试查看，过滤日志。</p><h3 id="为什么不用System-out-println"><a href="#为什么不用System-out-println" class="headerlink" title="为什么不用System.out.println?"></a>为什么不用System.out.println?</h3><p>这个方法除了使用方便，一无是处。比如：日志开关不可控，不能添加日志标签，日志没有级别区分等。</p><h1 id="kotlin开发"><a href="#kotlin开发" class="headerlink" title="kotlin开发"></a>kotlin开发</h1><p>kotlin变量声明只有var和val，var表示非final，val为final，可以自动识别准确类型。</p><p>kotlin中没有基本类型，他将Java中的基本类型首字母大写，成为对象。</p><p><strong>永远优先使用val，当val无法满足时，使用var，来保证程序的健壮性和代码规范</strong></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>fun关键字来声明,后面跟函数名，括号中填写需要的参数以及类型（可以不填），如果不需要返回值类型就不写。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin语法糖1：当函数中只有一行代码时，允许不必编写函数体，直接将唯一一行代码写在尾部，中间用等号链接。比如上面的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = max(num1, num2)</span><br><span class="line"><span class="comment">//由于kotlin的类型推导机制，可以省略注明返回的Int</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = max(num1, num2)</span><br></pre></td></tr></table></figure><h3 id="程序逻辑控制"><a href="#程序逻辑控制" class="headerlink" title="程序逻辑控制"></a>程序逻辑控制</h3><h4 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h4><p>if和when</p><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">        value = num1</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        value = num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Java中的不同之处：</p><p>if可以有返回值,返回值为每个if语句块中最后一行的返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> value = <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">        num1</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value冗余，精简</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">        num1</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据语法糖，继续精简</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">        num1</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span>(num1 &gt; num2) num1 <span class="keyword">else</span> num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="when条件语句"><a href="#when条件语句" class="headerlink" title="when条件语句"></a>when条件语句</h4><p>类似于Java的switch</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">if</span> (name == <span class="string">&quot;Tom&quot;</span>)&#123;</span><br><span class="line">    <span class="number">86</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">&quot;Jim&quot;</span>)&#123;</span><br><span class="line">    <span class="number">77</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">&quot;Jack&quot;</span>)&#123;</span><br><span class="line">    <span class="number">99</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过when可以再精简</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span>(name)&#123;</span><br><span class="line">    <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">99</span></span><br><span class="line">    <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">76</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了精确匹配，when还允许类型匹配</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(num: <span class="type">Number</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">when</span>(num)&#123;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;is Int&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; println(<span class="string">&quot;is Double&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;not support&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码，is关键字相当于Java的instanceof关键字。Number是kotlin的抽象类，Int，Long，Double，Float等与数字相关的都是他的子类，这里就使用类型判断是否为需要的参数。</p><p>when的不带参数用法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span>&#123;</span><br><span class="line">    name == <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    name == <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">99</span></span><br><span class="line">    name == <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">76</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">kotlin中判断对象是否相等可以直接使用“==”来判断。</span><br><span class="line">用法</span><br><span class="line">所有名字开头为Jhon的都为<span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span>&#123;</span><br><span class="line">    name.startsWith(<span class="string">&quot;Jhon&quot;</span>) -&gt; <span class="number">100</span></span><br><span class="line">    name == <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    name == <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">99</span></span><br><span class="line">    name == <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">76</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="while和for"><a href="#while和for" class="headerlink" title="while和for"></a>while和for</h5><p>while和Java无二</p><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><p>for-i直接被省略了。for-each增强为for-in</p><p>val range &#x3D; 0..10,表示[0,10]:   <code>..</code>是创建两端闭区间的关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但很多情况下，双端闭区间却不如单端闭区间好用。下标都是从0开始的，长度为10的数组，下标范围为0到9，因此左闭右开在设计中更加常用。kotlin使用<code>until</code>关键字创建一个左闭右开区间：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">0</span> until <span class="number">10</span></span><br><span class="line"><span class="comment">//[0, 10)</span></span><br></pre></td></tr></table></figure><p>默认情况下for-in循环中，每次执行循环都会在区间范围内递增1(i++效果)，如果想跳过其中一些元素，可以使用step关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span> step <span class="number">2</span>)&#123;<span class="comment">//i+2</span></span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>..</code>和<code>until</code>都是创建的升序区间，想要创建降序区间需要<code>downTo</code>关键字。用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span>)&#123;<span class="comment">//[10, 1]</span></span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>Class创建一个类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(name + <span class="string">&quot;is eating. He is &quot;</span>+ age + <span class="string">&quot;years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> per = Person()</span><br><span class="line">per.name = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">per.age = <span class="number">19</span></span><br><span class="line">per.eat()</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240622163430552.png" alt="image-20240622163430552"></p><h3 id="继承和构造函数"><a href="#继承和构造函数" class="headerlink" title="继承和构造函数"></a>继承和构造函数</h3><p>新建一个类Student：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sno = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;<span class="comment">//显然现在和Person类没有关系</span></span><br></pre></td></tr></table></figure><p>需要Person类被继承，需要</p><p>1.是Person类可以被继承：kotlin遵守了“如果一个类不是专门为继承而设计的，那么就应该主动加上final声明，禁止它可以被继承”，所有它默认都不能被继承。</p><p>开启方法：加上open关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(name + <span class="string">&quot;is eating. He is &quot;</span>+ age + <span class="string">&quot;years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.让Student类继承Person类，在kotlin中继承关键字变成了冒号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="type">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> sno = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要加括号？</p><p>涉及到了主构造函数和次构造函数。</p><p>kotlin将构造函数分为<code>主构造函数</code>和<code>次构造函数</code>：</p><p><strong>主构造函数</strong>将是最常用的构造函数，每个类默认都会有一个不带参数的主构造函数，当然也可以显式的指名参数。主构造函数的特点是没有函数体，直接定义在类后面即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;            <span class="comment">//主构造函数</span></span><br></pre></td></tr></table></figure><p>这里表明，在对Student类实例化的时候，必须传入所有参数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = Student(<span class="string">&quot;a123&quot;</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>主函数中没有函数体，如何在主构造函数中编写逻辑？</p><p>kotlin提供了init结构体，所有主函数逻辑在这里编写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>): Person() &#123;</span><br><span class="line"><span class="keyword">init</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;sno is&quot;</span> + sno)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>Java继承特性：子类的构造函数必须调用父类的构造函数，kotlin也遵守了，那么回头看，Student类中声明了一个主构造函数，是否需要放入init结构体中执行Person的构造方法？可以放入，但是不是个好方法，大部分情况下我们不需要编写init结构体。因此通过()来指定。</p><p>将父类的属性放入主构造函数，如何继承？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>): Person(name, age) &#123;</span><br><span class="line"><span class="comment">//不再用val修饰父类构造函数的变量，因为在子类构造函数中声明val或var的参数将自动成为该类的字段，回到是和父类中同名的字段冲突。</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>当一个类中既有主构造函数又有次构造函数，所有的次构造函数都需要调用主构造函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>): Person(name, age) &#123;</span><br><span class="line"><span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>): <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age)&#123;</span><br><span class="line">        <span class="comment">//通过this关键字调用了主构造函数，并且对sno和grade赋初值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(): <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//通过this关键字调用了第一个次构造函数，并且将name，age赋初值，间接调用主构造函数也合法。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以通过这几种进行实例化了</span></span><br><span class="line"><span class="keyword">val</span> student = Student()</span><br><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;Jack&quot;</span>, <span class="number">19</span>)</span><br><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;a123&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Jack&quot;</span>, <span class="number">19</span>)</span><br></pre></td></tr></table></figure><p>特殊情况：只有次构造函数，没有子构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="type">Person</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age)&#123;</span><br><span class="line">        <span class="comment">//由于Student没有主构造函数，继承类的时候就不需要()了，但是由于没有主构造函数，次构造函数只能直接通过super调用父类的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>新建一个Study接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomeWork</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让Student类实现Study接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(name: String, age: <span class="built_in">Int</span>) : Person(name, age), Study&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(name + <span class="string">&quot;is reading.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doHomeWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(name + <span class="string">&quot;is doing homework.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Study接口中定义的两个待实现函数，Student类必须实现。</p><p>当接口的函数有了函数体，就不需要强制实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">//默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomeWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;do homework&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数可见性修饰符"><a href="#函数可见性修饰符" class="headerlink" title="函数可见性修饰符"></a>函数可见性修饰符</h3><p>kotlin中：</p><p>public：所有类可见，默认</p><p>private：当前类可见</p><p>protected：当前类、子类可见</p><p>default：无</p><p>internal：同一模块中的类可见</p><h3 id="数据类和单例类"><a href="#数据类和单例类" class="headerlink" title="数据类和单例类"></a>数据类和单例类</h3><p>数据类通常需要重写equals，hashcode，toString方法。在kotlin中，在类前面加data，表示这个类是一个数据类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cellphone</span>(<span class="keyword">val</span> brand: String, <span class="keyword">val</span> price: <span class="built_in">Double</span>)</span><br><span class="line">会根据参数生成这些方法。</span><br></pre></td></tr></table></figure><p>main函数中测试</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> cellphone = Cellphone(<span class="string">&quot;iphone&quot;</span>, <span class="number">9988.0</span>)</span><br><span class="line">    <span class="keyword">val</span> cellphone1 = Cellphone(<span class="string">&quot;iphone&quot;</span>, <span class="number">9988.0</span>)</span><br><span class="line">    println(cellphone)</span><br><span class="line">    println(cellphone == cellphone1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240622172731158.png" alt="image-20240622172731158"></p><p>实现单例类</p><p>创建类型选择Object</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">singletonTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;hello singleton&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过函数名调用，kotlin自动帮我们创建了一个实例，并且保证全局只有一个。</p>]]></content>
    
    
    <summary type="html">安卓学习</summary>
    
    
    
    <category term="安卓" scheme="http://example.com/categories/%E5%AE%89%E5%8D%93/"/>
    
    
    <category term="安卓" scheme="http://example.com/tags/%E5%AE%89%E5%8D%93/"/>
    
    <category term="Kotlin" scheme="http://example.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>校园论坛项目</title>
    <link href="http://example.com/2024/06/20/2024-06-20-%E6%A0%A1%E5%9B%AD%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2024/06/20/2024-06-20-%E6%A0%A1%E5%9B%AD%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-06-20T07:38:32.000Z</published>
    <updated>2024-06-20T07:39:00.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="校园论坛项目"><a href="#校园论坛项目" class="headerlink" title="校园论坛项目"></a>校园论坛项目</h1><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>新建空项目，添加两个子模块后端forum-backend和前端forum-frontend，导入相关依赖。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240620105234477.png" alt="image-20240620105234477"></p><h2 id="配置Security配置类"><a href="#配置Security配置类" class="headerlink" title="配置Security配置类"></a>配置Security配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span>&#123;</span><br><span class="line">     <span class="comment">//lambada表达式</span></span><br><span class="line">     <span class="keyword">return</span> http</span><br><span class="line">         <span class="comment">//拦截</span></span><br><span class="line">         .authorizeHttpRequests(conf -&gt; conf </span><br><span class="line">                               .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>).permitAll() <span class="comment">//api验证操作允许放行</span></span><br><span class="line">                               .anyRequest().authenticated()<span class="comment">//其余操作全部拦截</span></span><br><span class="line">                               )</span><br><span class="line">         <span class="comment">//登录</span></span><br><span class="line">         .formLogin(conf -&gt; conf  </span><br><span class="line">                   .loginProcessingUrl(<span class="string">&quot;/api/auth/login&quot;</span>)</span><br><span class="line">                   .failureHandler(<span class="built_in">this</span>::onAuthenticationFailure)</span><br><span class="line">                   .successHandler(<span class="built_in">this</span>::onAuthenticationSuccess)</span><br><span class="line">                   )</span><br><span class="line">         <span class="comment">//退出登录</span></span><br><span class="line">         .logout(conf -&gt; conf </span><br><span class="line">                    .logoutUrl(<span class="string">&quot;/api/auth/logout&quot;</span>)</span><br><span class="line">                    .logoutSuccessHandler(<span class="built_in">this</span>::onLogoutSuccess)</span><br><span class="line">                    )</span><br><span class="line">         <span class="comment">//配置跨域</span></span><br><span class="line">         .csrf(conf -&gt; disable())</span><br><span class="line">         <span class="comment">//设置session为无状态</span></span><br><span class="line">         .sessionManagement(conf -&gt; conf </span><br><span class="line">                           .sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">         .build();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                    Authentication authentication)</span> <span class="keyword">throws</span> IOException,ServletException&#123;</span><br><span class="line">    response.getWriter().write(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                    AuthenticationException exception)</span> <span class="keyword">throws</span> IOException,ServletException&#123;</span><br><span class="line">    response.getWriter().write(<span class="string">&quot;failure&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                            HttpServletResponse response, </span></span><br><span class="line"><span class="params">                            Authentication authentication)</span> <span class="keyword">throws</span> IOException,ServletException&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的数据不标准，封装一个实体类，返回JSON格式的数据</p><h3 id="封装一个记录类型实体类，用于统一返回格式"><a href="#封装一个记录类型实体类，用于统一返回格式" class="headerlink" title="封装一个记录类型实体类，用于统一返回格式"></a>封装一个记录类型实体类，用于统一返回格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson2.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson2.JSONWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">RestBean</span>&lt;T&gt;(<span class="type">int</span> code, T data, String message) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestBean</span>&lt;&gt;(<span class="number">200</span>, data, <span class="string">&quot;请求成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">failure</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestBean</span>&lt;&gt;(code, <span class="literal">null</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">asJsonString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSONObject.toJSONString(<span class="built_in">this</span>, JSONWriter.Feature.WriteNulls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过fastjson将数据转换为json格式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                       HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                       AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">       response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">       response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">       response.getWriter().write(RestBean.failure(<span class="number">401</span>, exception.getMessage()).asJsonString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                       HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                       Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">       response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">       response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">       response.getWriter().write(RestBean.success().asJsonString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>完成基本登录，引入JWT令牌，登录之后发放令牌，创建一个JWT工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.security.jwt.key&#125;&quot;)</span></span><br><span class="line">    String key;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.security.jwt.expire&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> expire;</span><br><span class="line">    <span class="comment">//创建JWT</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createJwt</span><span class="params">(UserDetails details, <span class="type">int</span> id, String username)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="built_in">this</span>.expireTime();</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;id&quot;</span>, id)    <span class="comment">//自定义存入id</span></span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, username)    <span class="comment">//自定义存入name</span></span><br><span class="line">                .withClaim(<span class="string">&quot;authorities&quot;</span>, details.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())   <span class="comment">//自定义存入验证信息</span></span><br><span class="line">                .withExpiresAt(expire)  <span class="comment">//设置过期时间</span></span><br><span class="line">                .withIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())   <span class="comment">//设置颁发时间</span></span><br><span class="line">                .sign(algorithm);   <span class="comment">//签名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过期时间计算</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">expireTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.add(Calendar.HOUR, expire * <span class="number">24</span>);</span><br><span class="line">        <span class="keyword">return</span> calendar.getTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在登陆成功时颁发，放到Security配置类中的onAuthenticationSuccess方法中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) authentication.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtUtils.createJwt(user, <span class="number">1</span>,  user.getUsername());</span><br><span class="line">        <span class="type">AuthorizeVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizeVO</span>();</span><br><span class="line">        vo.setExpire(JWT.decode(token).getExpiresAt());</span><br><span class="line">        vo.setRole(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        vo.setToken(token);</span><br><span class="line">        vo.setUsername(user.getUsername());</span><br><span class="line">        response.getWriter().write(RestBean.success(vo).asJsonString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>新建vo响应类，统一返回数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登陆成功后的响应类</span></span><br><span class="line"><span class="comment"> * 返回用户名、角色、token、过期时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeVO</span> &#123;</span><br><span class="line">    String username;</span><br><span class="line">    String role;</span><br><span class="line">    String token;</span><br><span class="line">    Date expire;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置JWT后，需要进行校验，SpringSecurity自带一个过滤器链机制，需要把我们自定义的一些规则加入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthorizeFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    JwtUtils jwtUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                    HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> jwtUtils.resolveJwt(authorization);</span><br><span class="line">        <span class="keyword">if</span> (jwt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//jwt不为空，将用户信息解析出来放入UserDetails</span></span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> jwtUtils.toUser(jwt);</span><br><span class="line">            <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user, <span class="literal">null</span>, user.getAuthorities());</span><br><span class="line">            authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            request.setAttribute(<span class="string">&quot;id&quot;</span>, jwtUtils.toId(jwt));</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JWTUtils也要加入对应方法，供解析</span></span><br><span class="line"><span class="comment">//将JWT解析为UserDetails</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">toUser</span><span class="params">(DecodedJWT jwt)</span>&#123;</span><br><span class="line">        Map&lt;String, Claim&gt; claims = jwt.getClaims();</span><br><span class="line">        <span class="keyword">return</span> User</span><br><span class="line">                .withUsername(claims.get(<span class="string">&quot;name&quot;</span>).asString())</span><br><span class="line">                .password(<span class="string">&quot;*****&quot;</span>)</span><br><span class="line">                .authorities(claims.get(<span class="string">&quot;authorities&quot;</span>).asArray(String.class))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将JWT解析为id</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">toId</span><span class="params">(DecodedJWT jwt)</span>&#123;</span><br><span class="line">        Map&lt;String, Claim&gt; claims = jwt.getClaims();</span><br><span class="line">        <span class="keyword">return</span> claims.get(<span class="string">&quot;id&quot;</span>).asInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断token是否合法，合法即切割开头自带Bearer返回</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">convertToken</span><span class="params">(String headerToken)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headerToken == <span class="literal">null</span> || !headerToken.startsWith(<span class="string">&quot;Bearer &quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> headerToken.substring(<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完成之后，将过滤器链加入Security配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跨域</span></span><br><span class="line">                .csrf(AbstractHttpConfigurer::disable)</span><br><span class="line">                <span class="comment">//设置session无状态</span></span><br><span class="line">                .sessionManagement(conf -&gt; conf</span><br><span class="line">                                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">                <span class="comment">//添加过滤器,放在默认之前</span></span><br><span class="line">                .addFilterBefore(jwtAuthorizeFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><p>加入异常处理，确保jwt异常时，输出格式的合理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后的Security配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    JwtUtils jwtUtils;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    JwtAuthorizeFilter jwtAuthorizeFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                <span class="comment">//拦截</span></span><br><span class="line">                .authorizeHttpRequests(conf -&gt; conf</span><br><span class="line">                                        .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>).permitAll()</span><br><span class="line">                                        .anyRequest().authenticated())</span><br><span class="line">                <span class="comment">//登录</span></span><br><span class="line">                .formLogin(conf -&gt; conf</span><br><span class="line">                        .loginProcessingUrl(<span class="string">&quot;/api/auth/login&quot;</span>)</span><br><span class="line">                        .failureHandler(<span class="built_in">this</span>::onAuthenticationFailure)</span><br><span class="line">                        .successHandler(<span class="built_in">this</span>::onAuthenticationSuccess))</span><br><span class="line"></span><br><span class="line">                <span class="comment">//退出</span></span><br><span class="line">                .logout(conf -&gt; conf</span><br><span class="line">                        .logoutUrl(<span class="string">&quot;/api/auth/logout&quot;</span>)</span><br><span class="line">                        .logoutSuccessHandler(<span class="built_in">this</span>::onLogoutSuccess))</span><br><span class="line"></span><br><span class="line">                <span class="comment">//jwt异常处理</span></span><br><span class="line">                .exceptionHandling(conf -&gt; conf</span><br><span class="line">                        .authenticationEntryPoint(<span class="built_in">this</span>::onUnauthorized)</span><br><span class="line">                        .accessDeniedHandler(<span class="built_in">this</span>::onAccessDeny))</span><br><span class="line">                <span class="comment">//跨域</span></span><br><span class="line">                .csrf(AbstractHttpConfigurer::disable)</span><br><span class="line">                <span class="comment">//设置session无状态</span></span><br><span class="line">                .sessionManagement(conf -&gt; conf</span><br><span class="line">                                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">                <span class="comment">//添加过滤器,放在默认之前</span></span><br><span class="line">                .addFilterBefore(jwtAuthorizeFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAccessDeny</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             AccessDeniedException exception)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(RestBean.forbidden(exception.getMessage()).asJsonString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUnauthorized</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                AuthenticationException exception)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(RestBean.unauthorized(exception.getMessage()).asJsonString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        AuthenticationException exception)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(RestBean.unauthorized(exception.getMessage()).asJsonString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        Authentication authentication)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) authentication.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtUtils.createJwt(user, <span class="number">1</span>,  user.getUsername());</span><br><span class="line">        <span class="type">AuthorizeVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizeVO</span>();</span><br><span class="line">        vo.setExpire(JWT.decode(token).getExpiresAt());</span><br><span class="line">        vo.setRole(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        vo.setToken(token);</span><br><span class="line">        vo.setUsername(user.getUsername());</span><br><span class="line">        response.getWriter().write(RestBean.success(vo).asJsonString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写jwtUtils，logout删除jwt的方法</span></span><br><span class="line">    <span class="comment">//令牌失效方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">invalidateJwt</span><span class="params">(String headerToken)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">this</span>.convertToken(headerToken);</span><br><span class="line">        <span class="keyword">if</span>(token == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//获取相同的key，指定相同的jwt算法</span></span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="comment">//创建验证器，用于验证JWT合法性</span></span><br><span class="line">        <span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(algorithm).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置黑名单，通过jwt的id来判断，因此在下面create的时候加入uuid生成的id</span></span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line">            <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> jwt.getId();</span><br><span class="line">            <span class="keyword">return</span> deleteToken(id, jwt.getExpiresAt());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JWTVerificationException e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让令牌失效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">deleteToken</span><span class="params">(String uuid, Date time)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isInvalidToken(uuid))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//设置过期时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> Math.max(time.getTime() - now.getTime(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//存入redis</span></span><br><span class="line">        template.opsForValue().set(Const.JWT_BLACK_LIST + uuid, <span class="string">&quot;&quot;</span>, expire, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否失效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInvalidToken</span><span class="params">(String uuid)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(template.hasKey(Const.JWT_BLACK_LIST + uuid));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完善Security配置类的onLogoutSuccess方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (jwtUtils.invalidateJwt(authorization))&#123;</span><br><span class="line">            writer.write(RestBean.success(<span class="string">&quot;退出成功&quot;</span>).asJsonString());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            writer.write(RestBean.failure(<span class="number">400</span>, <span class="string">&quot;退出失败&quot;</span>).asJsonString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">项目编写</summary>
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/06/19/hello-world/"/>
    <id>http://example.com/2024/06/19/hello-world/</id>
    <published>2024-06-19T01:17:14.564Z</published>
    <updated>2024-06-19T03:43:25.819Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">新建博客的默认文章</summary>
    
    
    
    <category term="start" scheme="http://example.com/categories/start/"/>
    
    
    <category term="start" scheme="http://example.com/tags/start/"/>
    
  </entry>
  
  <entry>
    <title>Java语言面试</title>
    <link href="http://example.com/2024/06/13/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2024/06/13/Java%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2024-06-13T13:02:32.000Z</published>
    <updated>2024-06-19T07:12:10.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h3><ol><li>什么是Java</li><li>Java语言有哪些特点</li><li>JVM，JDK，JRE有什么区别</li><li>什么是跨平台性？原理是什么</li><li>什么是字节码？采用字节码的好处</li><li>为什么说Java语言“编译与解释并存”</li></ol><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ol><li>Java有哪些数据类型</li><li>自动类型转换、强制类型转换</li><li>什么是自动拆箱&#x2F;封箱</li><li>&amp;&amp;和&amp;的区别</li><li>switch能否作用在byte&#x2F;long&#x2F;String上</li><li>break、continue、return区别及作用</li><li>最有效率的方法计算2乘以8</li><li>自增自减运算</li></ol><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ol><li>面向对象和面向过程的区别</li><li>面向对象有哪些特性</li><li>重载和重写的区别</li><li>访问修饰符public、private、protected、以及默认区别</li><li>this关键字的作用</li><li>抽象类和接口的区别</li><li>成员变量与局部变量的区别有哪些</li><li>静态变量和实例变量的区别？静态方法和实例方法？</li><li>final关键字作用</li><li>final、finally、finalize区别</li><li>&#x3D;&#x3D;和equals区别</li><li>hashCode和equals？</li></ol><ul><li>什么是hashcode</li><li>为什么要有hashcode</li><li>为什么重写equals时必须重写hashcode方法</li><li>为什么两个对象有相同的hashcode值他们也不一定是相等的</li></ul><p>13.Java是值传递，还是引用传递</p><p>14.深拷贝和浅拷贝</p><p>15.Java创建对象方式</p><h3 id="集合基础"><a href="#集合基础" class="headerlink" title="集合基础"></a>集合基础</h3><ol><li>Java中实现Map接口的有哪些类</li><li>遍历HashMap的方法</li></ol><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><ol><li>String是Java的基本数据类型吗？可以被继承吗</li><li>String和String Builder、String Buffer</li><li>String str1 &#x3D; new String(“abc”)和String str2 &#x3D; “abc”的区别</li><li>String不是不可变类吗？拼接如何实现</li><li>intern方法作用</li><li>Java的包装类有什么用？为什么需要包装类？</li><li>Object类常见方法</li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li>Java中异常层级结构</li><li>异常的处理机制</li><li>finally一定会执行吗</li></ol><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><ol><li>Java中IO流分为几种</li><li></li></ol>]]></content>
    
    
    <summary type="html">Java面试基础</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello, Blog!</title>
    <link href="http://example.com/2024/05/21/%E7%BB%99%20SheepMango%EF%BC%9A/"/>
    <id>http://example.com/2024/05/21/%E7%BB%99%20SheepMango%EF%BC%9A/</id>
    <published>2024-05-20T21:20:20.000Z</published>
    <updated>2024-06-19T07:31:57.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给-SheepMango："><a href="#给-SheepMango：" class="headerlink" title="给 SheepMango："></a>给 SheepMango：</h1><h2 id="搭建了一个个人小博客，保佑找到好工作！🥭🐏"><a href="#搭建了一个个人小博客，保佑找到好工作！🥭🐏" class="headerlink" title="搭建了一个个人小博客，保佑找到好工作！🥭🐏"></a>搭建了一个个人小博客，保佑找到好工作！🥭🐏</h2>]]></content>
    
    
    <summary type="html">❤❤❤</summary>
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="❤" scheme="http://example.com/tags/%E2%9D%A4/"/>
    
  </entry>
  
  <entry>
    <title>多线程JUC并发编程</title>
    <link href="http://example.com/2024/05/12/%E5%A4%9A%E7%BA%BF%E7%A8%8BJUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/05/12/%E5%A4%9A%E7%BA%BF%E7%A8%8BJUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-05-12T07:30:32.000Z</published>
    <updated>2024-06-19T07:17:30.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程JUC并发编程"><a href="#多线程JUC并发编程" class="headerlink" title="多线程JUC并发编程"></a>多线程JUC并发编程</h1><p><strong>JUC -&gt; Java.util.concurrent</strong></p><p><strong>进程</strong>：在操作系统之上，可以同时运行很多个进程，且每个进程之间相互隔离互不干扰，CPU通过时间片轮转算法给每个进程分配时间片，时间片使用结束后切换到下一个进程继续执行，实现了宏观上的多个程序同时运行。</p><p>由于每个进程之间都有一个自己的内存空间，进程间的通信很麻烦，且执行不同进程会产生上下文切换非常耗时。</p><p><strong>线程</strong>：一个进程可以拥有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程是程序执行流的最小单元，各个线程之间共享程序的内存空间（所在进程的内存空间），上下文切换的速度也高于进程。</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><p>并发执行也是只能同一时间处理一个任务，但是每个任务轮流做（时间片轮转）：</p><p>只要单次处理分配时间够短，宏观来看，就是同时进行。</p><p>但是当需要同时处理上百上千个任务，CPU跟不上线程数，所以要程序有良好的并发性能，来应对同一时间大量任务的处理。学习JUC处理高并发。</p><h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>突破了同一时间只能处理一个任务，可以同一时间处理多个任务。</p><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>通过<code>synchronized</code>关键字实现锁，一定是和某个对象关联的，因为底层需要获取到监视对象的监视器<code>monitor</code>，获取<code>monitor</code>，执行之后判断是否发生异常，会有两个<code>monitorexit</code>，如果程序正常执行完会执行第一个释放，如果发生异常，为了防止锁住，会使用<code>athorw</code>，指令抛出异常再释放。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>每个等待锁的线程都会被封装为ObjectWaiter对象，进入到如下机制：</p><p><img src="https://image.itbaima.cn/markdown/2023/03/06/OvufwzKx7l6yNMB.png" alt="image-20230306171005840"></p><p>ObjectWaiter会先进入Entry Set等待，当线程获取到对象的<code>monitor</code>后进入The Owner区域并把<code>monitor</code>中的<code>owner</code>变量设置为当前线程，同时<code>moniter</code>中的计数器<code>count</code>加一，若线程调用了<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>owner</code>变量恢复为<code>null</code>，<code>count</code>自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>并复位变量的值，以便其他线程进入获取对象的<code>monitor</code>。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的目标是，在无竞争情况下，减少重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。他不像是重量级锁那样，需要向操作系统申请互斥量。</p><blockquote><p> CAS（Compare And Swap）是一种无锁算法（我们之前在Springboot阶段已经讲解过了），它并不会为对象加锁，而是在执行的时候，看看当前数据的值是不是我们预期的那样，如果是，那就正常进行替换，如果不是，那么就替换失败。比如有两个线程都需要修改变量<code>i</code>的值，默认为10，现在一个线程要将其修改为20，另一个要修改为30，如果他们都使用CAS算法，那么并不会加锁访问<code>i</code>，而是直接尝试修改<code>i</code>的值，但是在修改时，需要确认<code>i</code>是不是10，如果是，表示其他线程还没对其进行修改，如果不是，那么说明其他线程已经将其修改，此时不能完成修改任务，修改失败。</p><p>在CPU中，CAS操作使用的是<code>cmpxchg</code>指令，能够从最底层硬件层面得到效率的提升。</p></blockquote><p>如果CAS操作失败了的话，那么说明可能这时有线程已经进入这个同步代码块了，这时虚拟机会再次检查对象的Mark Word，是否指向当前线程的栈帧，如果是，说明不是其他线程，而是当前线程已经有了这个对象的锁，直接放心大胆进同步代码块即可。如果不是，那确实是被其他线程占用了。</p><p>这时，轻量级锁一开始的想法就是错的（这时有对象在竞争资源，已经赌输了），所以说只能将锁膨胀为重量级锁，按照重量级锁的操作执行（注意锁的膨胀是不可逆的）</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁对比轻量级锁，消除了同步，不需要进行CAS操作。当某个线程第一次获得锁时，接下来如果没有其他线程获取此锁，那么持有锁的线程将不需要进行同步操作。</p><h3 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h3><p>某段代码加了锁，但在运行时根本不可能出现各个线程之间资源争夺的情况，这种情况下完全不需要加任何锁机制，所以锁会被消除。锁粗化则是代码中频繁出现互斥同步操作，比如在一个循环内部加锁，这样明显是非常消耗性能的，虚拟机一旦检测到这种操作，会将整个同步范围进行扩展。</p><h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><img src="https://image.itbaima.cn/markdown/2023/03/06/UMkWgFatBoLsfr5.png" alt="image-20230306171115671"></p><p>JMM（Java Memory Model）内存模型规定如下：</p><ul><li>所有的变量全部存储在主内存（注意这里包括下面提到的变量，指的都是会出现竞争的变量，包括成员变量、静态变量等，而局部变量这种属于线程私有，不包括在内）</li><li>每条线程有着自己的工作内存（可以类比CPU的高速缓存）线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据。</li><li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存。</li></ul><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h2 id="队列同步器AQS"><a href="#队列同步器AQS" class="headerlink" title="队列同步器AQS"></a>队列同步器AQS</h2>]]></content>
    
    
    <summary type="html">JUC相关，锁，JMM</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="http://example.com/2024/05/08/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2024/05/08/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2024-05-08T12:16:32.000Z</published>
    <updated>2024-06-19T07:13:29.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h1><h2 id="对象存活判定方法"><a href="#对象存活判定方法" class="headerlink" title="对象存活判定方法"></a>对象存活判定方法</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br></pre></td></tr></table></figure><p>只要一个对象还有实用价值，我们可以通过他的引用变量来进行操作</p><ul><li>每个对象都包含一个<strong>引用计数器</strong>，用于存放引用计数（被引用的次数)</li><li>每当有一个地方引用此对象时，引用计数加一</li><li>当引用失效时，引用计数减一</li><li>当引用计数为零时，表示此对象不可能再被引用。</li></ul><p>存在问题-&gt;两个对象相互引用，引用计数器的值始终为一。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>采用类似树结构搜索机制</p><p>每个对象引用都有机会成为树的根节点（GC Roots），成为根节点的条件：</p><ul><li>位于虚拟机的栈帧中的本地变量表索引用到的对象</li><li>类的静态成员变量所引用的对象</li><li>方法区中，常量池里面引用的对象，比如之前的<code>String</code>对象</li><li>被添加了锁的对象（synchronized）</li><li>虚拟机内部需要用到的对象</li></ul><p>一旦以及存在的根节点不满足存在的条件时，根节点与对象之间的连接将断开，如果对象存在对其它对象的引用，但是由于没有任何根节点的引用，所以此对象可被判定为不再使用。</p><h3 id="最终判定"><a href="#最终判定" class="headerlink" title="最终判定"></a>最终判定</h3><p>经历了可达性分析算法后基本可能判断哪些对象能够被回收，但是并不代表此对象一定会被回收，会在最终判定阶段进行挽留。</p><p><code>Object</code>类中的<code>finalize()</code>方法就是最终判定方法，如果子类重写了此方法，那么子类对象在被判定为可回收时，会执行这个方法进行二次确认。如果在二次确认后对象不满足可回收条件，那么对象不会被回收。</p><p>只能执行一次，第二次执行的时候会跳过，直接回收。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h3><p>Java虚拟机将堆内存划分为<strong>新生代</strong>，<strong>老年代</strong>，<strong>永久代</strong>。</p><p><img src="https://image.itbaima.cn/markdown/2023/03/06/OZrKbUm39lfaAgv.png" alt="image-20230306165311823"></p><p>新创建的对象会放入Eden区，进行一次扫描，引用为空的对象会丢掉，剩下存活的对象转移到Survivor区，一开始From和To区都是空的，所有Eden存活的对象进入From区，最后From和To进行一次交换。</p><p>下一次垃圾回收，操作与上次一样，但是From区中有对象了，因此Eden区中的对象复制到From区后，会对To区的对象进行判定（每经历一次垃圾回收，年龄+1，对象年龄大于15，会直接进入老年代，否则会移入From区）</p><p>垃圾收集分为：</p><ul><li>Minor GC - 次要垃圾回收，主要进行新生代区域垃圾收集<ul><li>触发条件：新生代Eden区容量满</li></ul></li><li>Major GC：主要垃圾回收，主要对老年代垃圾收集</li><li>Full GC：完全垃圾回收，对整个Java堆内存和方法区进行垃圾回收。<ul><li>触发条件：<ul><li>每次晋升到老年代的对象平均大小大于老年代剩余空间</li><li>Minor GC后存活的对象超过了老年代剩余空间</li><li>永久代空间不足（JDK8之前）</li><li>手动调用System.gc()方法</li></ul></li></ul></li></ul><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记所有需要回收的对象，然后再依次回收被标记的对象，或者是标记所有不需要回收的对象，回收没有被标记的对象。</p><p>缺点：如果存在大量对象，就会存在大量标记，大规模清除后连续的内存空间可能会出现许多空袭，碎片化导致连续内存空间利用率降低。</p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>将容量分为大小相同的两块区域，每次清除垃圾后将存活的对象全部复制到另一个区域，解决了碎片化问题。适用于新生代</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记对象后，将所有待回收的对象整齐排列，将后续对象全部清除。</p><h2 id="垃圾收集器实现"><a href="#垃圾收集器实现" class="headerlink" title="垃圾收集器实现"></a>垃圾收集器实现</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>单线程，会终止当前用户线程，收集完后继续线程</p><h3 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge&#x2F;Parallel Old收集器"></a>Parallel Scavenge&#x2F;Parallel Old收集器</h3><p>JDK8使用这种组合方式垃圾回收方案</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><h3 id="Garbage-First（G1）收集器"><a href="#Garbage-First（G1）收集器" class="headerlink" title="Garbage First（G1）收集器"></a>Garbage First（G1）收集器</h3><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>JDK8时直接将本地内存作为元空间（<strong>Metaspace</strong>）的区域，物理内存有多大，元空间内存就可以有多大</p><p><img src="https://image.itbaima.cn/markdown/2023/03/06/2RD3AnPvbh1lQ5N.png" alt="image-20230306165703340"></p><h2 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h2><p>强引用：<code>Object o = new Object()</code>，JVM不会随意回收强引用对象</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>内存空间不足时，软引用指向对象会被回收，get()方法得到null，并且软引用对象本身被丢进队列中</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>进行垃圾回收时，不管内存空间是否充足，都会回收</p>]]></content>
    
    
    <summary type="html">JVM垃圾回收</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>NIO</title>
    <link href="http://example.com/2024/05/08/NIO/"/>
    <id>http://example.com/2024/05/08/NIO/</id>
    <published>2024-05-08T12:16:32.000Z</published>
    <updated>2024-06-19T07:14:30.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h3>]]></content>
    
    
    <summary type="html">没有内容。。。。</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="NIO" scheme="http://example.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>链表及算法例题</title>
    <link href="http://example.com/2024/04/26/%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2024/04/26/%E9%93%BE%E8%A1%A8/</id>
    <published>2024-04-26T15:53:32.000Z</published>
    <updated>2024-06-19T07:18:41.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链表的入口节点称为链表的头结点也就是head。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt="链表1"></p><h2 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>刚刚说的就是单链表。</p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>单链表中的指针域只能指向节点的下一个节点。</p><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p>双链表 既可以向前查询也可以向后查询。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png" alt="链表2"></p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表，顾名思义，就是链表首尾相连。</p><p>循环链表可以用来解决约瑟夫环问题。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png" alt="链表4"></p><h2 id="链表的存储方式"><a href="#链表的存储方式" class="headerlink" title="链表的存储方式"></a>链表的存储方式</h2><p>了解完链表的类型，再来说一说链表在内存中的存储方式。</p><p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p><p>链表是通过指针域的指针链接在内存中各个节点。</p><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>Java实现链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p><p>直接使用原链表删除元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不用if，因为移除头节点是一个持续的过程，如果链表是1-&gt;1-&gt;1,目标为1用if就错了。</span></span><br><span class="line"><span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val == target)&#123;</span><br><span class="line">    head = head.next;</span><br><span class="line">    <span class="comment">//如果是c++需要进行头节点的释放，其他语言有垃圾回收机制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = head;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cur-&gt;next-&gt;val == target)&#123;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><p>使用虚拟头节点(在非头节点和头节点操作时统一了操作)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dummyhead = <span class="keyword">new</span> <span class="title class_">ListNode</span>;</span><br><span class="line">dummyhead.next = head;</span><br><span class="line">cur = dummyhead;<span class="comment">//实际删除的是cur的next</span></span><br><span class="line"><span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.next.val == target)&#123;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummyhead.next;</span><br></pre></td></tr></table></figure><p>题目代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="comment">//ListNode pre = dummyNode;</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cur = cur.next;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p><p>获取第n个节点的值（n从0开始）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cur = dummyhead.next;</span><br><span class="line"><span class="keyword">while</span>(n )&#123;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur.val;</span><br></pre></td></tr></table></figure><p>头部插入节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newnode = <span class="keyword">new</span> <span class="title class_">node</span>();</span><br><span class="line">newnode.next = dummyhead.next;</span><br><span class="line">dummynode.next = newnode;</span><br><span class="line">size++;</span><br></pre></td></tr></table></figure><p>尾部插入节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cur = dummyhead;</span><br><span class="line"><span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">cur.next = newnode;</span><br><span class="line">size++;</span><br></pre></td></tr></table></figure><p>第n个节点前插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cur = dummyhead;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    cur =  cur.next;</span><br><span class="line">&#125;</span><br><span class="line">newnode.next = cur.next;</span><br><span class="line">cur.next = newnode;</span><br><span class="line">size++;</span><br></pre></td></tr></table></figure><p>删除第n个节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cur = dummyhead;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br><span class="line">cur.next = cur.next.next;</span><br><span class="line">size--;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">链表算法题</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java基础常见面试题总结</title>
    <link href="http://example.com/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2024-04-26T08:43:32.000Z</published>
    <updated>2024-06-19T07:02:47.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础常见面试题总结"><a href="#Java基础常见面试题总结" class="headerlink" title="Java基础常见面试题总结"></a>Java基础常见面试题总结</h1><h2 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h2><h3 id="Java语言有哪些特点？"><a href="#Java语言有哪些特点？" class="headerlink" title="Java语言有哪些特点？"></a>Java语言有哪些特点？</h3><p>1.简单易学；</p><p>2.面向对象（封装，继承，多态）；</p><p>3.平台无关性（JVM实现了平台无关性）；</p><p>4.支持多线程（C++11之前 没有内置多线程机制，因此必须调用操作系统的多线程来进行多线程设计，而Java提供了多线程支持）；</p><p>5.可靠性（具有异常处理和自动内存管理机制）； </p><p>6.安全性（Java本身的设计就提供了多重防护机制如控制访问符、限制程序直接访问操作系统资源）；</p><p>7.高效性（通过JIT编译器等技术的优化，Java运行的效率还不错）</p><p>8.支持网络编程并且很方便；</p><p>9.编译与解释并存；</p><p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！—-JavaGuide</p><h3 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM &amp; JDK &amp; JRE"></a>JVM &amp; JDK &amp; JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，都会给出相同的结果。<strong>字节码和不同系统上的JVM是实现Java语言“一次编译，随处运行”的关键</strong></p><p>JVM并不只有一种，只要满足JVM规范，每个人都可以开发自己的专属JVM；</p><h4 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h4><p>JDK（Java Development Kit），他是功能齐全的Java SDK，是提供给开发者使用，能够创建和编译Java程序的开发套件。包含了JRE、编译Java源码的Javac以及一些其他工具（Javadoc、jdb、jconsole、javap等等）</p><p>JRE（Java Runtime Environment）是Java运行时的环境。他是已经运行已编译Java程序所需的内容的集合，主要包括Java虚拟机（JVM）、Java基础类库（Class Library）</p><p>总的来说，JRE是Java运行时的环境，仅包含Java应用程序的运行时环境和必要类库。JDK包含了JRE，同时还包括了其他工具，用于Java应用程序的开发和调试。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-include-jre.png" alt="JDK 包含 JRE"></p><h3 id="什么是字节码，采用字节码的好处？"><a href="#什么是字节码，采用字节码的好处？" class="headerlink" title="什么是字节码，采用字节码的好处？"></a>什么是字节码，采用字节码的好处？</h3><p>在Java中JVM可以理解的代码叫做字节码（拓展名为<code>.class</code>的文件），他不面向任何特定的处理器，只面向虚拟机。</p><p>Java通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行起来还是相对高效的。而且由于字节码并不针对特定的机器，因此Java程序无需重新编译即可在多种不同的操作系统的计算机上运行。</p><p><strong>Java 程序从源代码到运行的过程如下图所示</strong>：</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png" alt="Java程序转变为机器代码的过程"></p><p><code>.class-&gt;机器码</code>这一步，JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式执行速度相对比较慢，而且有些方法和代码块经常需要被调用（热点代码），所以后面引进了JIT（Just In Time Commpliation）编译器，JIT属于运行时编译。当JIT编译器完成第一次编译后，会将字节码对应的机器码保存起来，下次可以直接使用。这也解释了为什么说 <strong>Java 是编译与解释共存的语言</strong> 。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code-with-jit.png" alt="Java程序转变为机器代码的过程"></p><p>JDK、JRE、JVM、JIT 这四者的关系如下图所示。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png" alt="JDK、JRE、JVM、JIT 这四者的关系"></p><h3 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h3><p>高级编程语言按照程序执行方式分为两种：</p><ul><li><strong>编译型</strong>：编译型语言会将源代码一次性翻译成可以被该平台执行的机器码。一般情况下，该类型开发效率较低，执行速度较快。（C、C++、GO、Rust）</li><li><strong>解释型</strong>：解释型语言会通过解释器一句一句将代码解释为机器代码后再执行。该类型开发较快，执行速度较慢。（Python、JavaScript、PHP）</li></ul><h4 id="为什么说Java语言“编译与解释并存”？-1"><a href="#为什么说Java语言“编译与解释并存”？-1" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h4><p>因为Java语言既有编译型语言特征也有解释型语言特征。因为Java程序要经过先编译，后解释两个步骤，由Java编写的程序先经过编译步骤，生成字节码，这种字节码再由Java解释器来解释运行。</p><h3 id="AOT有什么优点？为什么不全部使用AOT？"><a href="#AOT有什么优点？为什么不全部使用AOT？" class="headerlink" title="AOT有什么优点？为什么不全部使用AOT？"></a>AOT有什么优点？为什么不全部使用AOT？</h3><p>JDK9新引入了一种新的编译模式AOT（Ahead of Time Compilation）。这种模式会在程序被执行前就将其编译成机器码，属于静态编译（C++，Rust，GO就是静态编译）。AOT避免了JIT预热等各方面开销，可以提高Java程序的启动速度，避免预热时间长。并且，AOT还能减少内存占用和增强Java程序的安全性（AOT编译后的代码不容易被反编译和修改），特别适用于云原生场景。</p><p>AOT的优势在于启动时间，内存占用和打包体积。JIT的优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p><h3 id="既然-AOT-这么多优点，那为什么不全部使用这种编译方式呢？"><a href="#既然-AOT-这么多优点，那为什么不全部使用这种编译方式呢？" class="headerlink" title="既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？"></a>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</h3><p>两者各有优点，AOT更适合云原生场景，对微服务架构支持也比较友好，AOT无法支持Java一些动态特性，如反射、动态代理、动态加载等。然而很多的框架和库（Spring）都用到了这些特性。如果只使用AOT编译就没办法使用这些框架和库了。</p><h3 id="Java和C-的区别？"><a href="#Java和C-的区别？" class="headerlink" title="Java和C++的区别？"></a>Java和C++的区别？</h3><p>Java和C++都是面向对象语言，都支持封装、继承和多态</p><ul><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；但是Java接口可以多继承</li><li>Java有自动内存管理垃圾回收机制（GC），不需要手动释放无用内存。</li><li>C++同时支持方法重载和操作符重载，Java只支持方法重载（操作符重载增加了复杂性，与Java最初的设计思想不符）</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="标识符和关键字区别？"><a href="#标识符和关键字区别？" class="headerlink" title="标识符和关键字区别？"></a>标识符和关键字区别？</h4><p>在编写程序时，需要大量为程序，方法，类，变量等取名字，于是简单来说<strong>标识符就是一个名字</strong></p><p>有些标识符，Java已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是<strong>关键字</strong>。</p><p>Java关键字：</p><p>这里列举截止到Java17所有的关键字及其功能：</p><ul><li><strong>abstract</strong> 声明一个类为抽象类或一个方法为抽象方法。</li><li><strong>assert</strong> 断言表达式使用，用来对某些东西进行判断，如果判断失败会抛出错误，默认无效，需要添加启动参数才能开启，一般在测试环境中使用。</li><li><strong>boolean</strong> 基本数据类型，布尔类型，只有true和false两种结果。</li><li><strong>break</strong> 用于for&#x2F;while循环语句中对循环提前终止，以及在switch语句中结束当前case语句块，防止程序继续向下执行。</li><li><strong>byte</strong> 基本数据类型，字节类型，可以表示1字节的数据，取值范围为-128 到 127。</li><li><strong>case</strong> 用于在switch语句中判断条件，匹配后执行相应的代码块。</li><li><strong>catch</strong> 用于捕获异常，处理try块中抛出的异常。</li><li><strong>char</strong> 基本数据类型，字符类型，表示单个字符（16位Unicode字符）表示范围为’\u0000’ (0) 到 ‘\uffff’ (65535)</li><li><strong>class</strong>：声明一个类型，此外，使用<code>类名.class</code>用于获取指定类型的Class对象。</li><li><strong>const</strong> 保留关键字，无实际用途。</li><li><strong>continue</strong>：用于for&#x2F;while循环语句中跳过当前循环的剩余代码，直接开启下一轮循环。</li><li><strong>default</strong> 在switch语句中表示默认情况，同时，在接口中也可以为抽象方法指定默认实现（仅Java8之后可用）</li><li><strong>do</strong> 用于do-while循环中定义循环体，循环开始前会执行一次循环。</li><li><strong>double</strong> 基本数据类型，双精度浮点数，表示范围为4.9e-324 到 1.8e+308，精度为15位小数。</li><li><strong>else</strong> 与if语句一起使用，表示条件不成立时执行的代码块，也可以与if组合为else if判断。</li><li><strong>enum</strong> 声明枚举类型。</li><li><strong>extends</strong> 声明类继承另一个类，在接口中可以继承多个其他接口，在泛型类中List&lt;? extends Number&gt;表示为类型参数设定上界。</li><li><strong>final</strong> 声明一个变量的值不可修改、一个类不能被继承、一个方法不能被子类重写。</li><li><strong>finally</strong> 声明一个代码块，在异常处理时，无论是否发生异常都会执行。</li><li><strong>float</strong> 基本数据类型，单精度浮点数，表示范围为1.4e-45 到 3.4e+38，精度为6-7位小数。</li><li><strong>for</strong> 创建for循环语句。</li><li><strong>if</strong> 创建条件判断语句。</li><li><strong>implements</strong> 表示一个类实现的接口，可以跟一个或多个接口。</li><li><strong>import</strong> 用于导入包或类。</li><li><strong>instanceof</strong> 用于判断对象是否为指定类型。</li><li><strong>int</strong> 基本数据类型，整数类型，取值范围为-2^31 到 2^31-1。</li><li><strong>interface</strong>：定义接口。</li><li><strong>long</strong> 基本数据类型，长整数类型，取值范围为-2^63 到 2^63-1。</li><li><strong>native</strong> 用于声明一个本地方法，方法的实现使用非Java语言编写，一般为C或C++编写，详情请看JVM篇JNI相关介绍。</li><li><strong>new</strong> 用于实例化对象。</li><li><strong>null</strong> 表示空对象引用。</li><li><strong>package</strong> 用于声明包。</li><li><strong>private</strong> 权限修饰符，表示私有的，仅在类的内部可见。</li><li><strong>protected</strong> 权限修饰符，表示受保护的，仅当前类和子类可见。</li><li><strong>public</strong> 权限修饰符，表示公共的，对所有类可见。</li><li><strong>record</strong> 用于声明记录类型，Java14新增类型。</li><li><strong>return</strong> 用于方法返回值。</li><li><strong>sealed</strong> 用于声明密封类型，Java17新增类型。</li><li><strong>non-sealed</strong> 用于声明类型为非密封类型，Java17新增类型。</li><li><strong>short</strong> 用于声明短整型变量。</li><li><strong>static</strong> 将类、方法、属性声明为静态的。</li><li><strong>strictfp</strong> 用于确保浮点运算结果一致。</li><li><strong>super</strong> 表示父类对象，在泛型类中List&lt;? super Integer&gt;表示为类型参数设定下界，在编写子类构造方法时，默认需要优先执行super()调用父类构造方法（无参情况下可省略）在Java22之后super不再要求强制优先调用。</li><li><strong>switch</strong> 用于多重条件判断，在Java13之后可以使用switch表达式。</li><li><strong>synchronized</strong> 用于线程同步加锁。</li><li><strong>this</strong> 表示当前对象，使用this()可以调用当前类型的构造方法。</li><li><strong>throw</strong> 抛出异常对象。</li><li><strong>throws</strong> 在方法声明中指定可能被抛出的异常。</li><li><strong>transient</strong> 声明变量在对象序列化时不参与序列化。</li><li><strong>try</strong> 异常捕获的起始块。</li><li><strong>void</strong> 表示没有返回值。</li><li><strong>volatile</strong> 用于可能会被多个线程同时修改的变量，使其保证线程之间的可见性，禁止指令重排，但无法保证原子性，详情请见JUC篇视频教程。</li><li><strong>while</strong> 用于创建while循环，当条件满足时执行代码块。</li></ul><h4 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h4><p><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</p><p><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</p><p><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</p><h4 id="continue、break和return区别？"><a href="#continue、break和return区别？" class="headerlink" title="continue、break和return区别？"></a>continue、break和return区别？</h4><p>1.<code>continue</code>: 跳出当前这一次的循环，继续下一次循环</p><p>2.<code>break</code>: 跳出整个循环体，继续执行循环下面的语句。</p><p>3.<code>return</code>: 跳出所在的方法，结束该方法运行。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java中有8种基本数据类型：</p><ul><li>6种数字型：<ul><li>4中整数型：byte、short、int、long</li><li>2种浮点型：float、double</li></ul></li><li>1种字符类型：char</li><li>1种布尔类型：boolean</li></ul><p>对应的包装类型：Byte、Short、Integer、Long、Float、Double、Character、Boolean</p><h3 id="基本数据类型和包装类型的区别？"><a href="#基本数据类型和包装类型的区别？" class="headerlink" title="基本数据类型和包装类型的区别？"></a>基本数据类型和包装类型的区别？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/primitive-type-vs-packaging-type.png" alt="基本类型 vs 包装类型"></p><p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</p><p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p><p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p><p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><h3 id="包装类型的缓存机制？"><a href="#包装类型的缓存机制？" class="headerlink" title="包装类型的缓存机制？"></a>包装类型的缓存机制？</h3><p>Java基本数据类型的包装类型大部分都用到了缓存机制来提升性能。</p><p>Byte、Short、Integer、Long这四种包装类默认创建了数值[-128, 127]的相应类型的缓存数据，Character创建了数值在[0, 127]范围的缓存数据，Boolean直接返回True或者False。</p><p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><h3 id="自动装箱与拆箱？原理？"><a href="#自动装箱与拆箱？原理？" class="headerlink" title="自动装箱与拆箱？原理？"></a>自动装箱与拆箱？原理？</h3><p><strong>什么是自动拆装箱？</strong></p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><p>装箱其实就是调用了包装类的valueOf()方法，拆箱调用了xxxValue()方法。</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><p><strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="成员变量与局部变量的区别"><a href="#成员变量与局部变量的区别" class="headerlink" title="成员变量与局部变量的区别"></a>成员变量与局部变量的区别</h4><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/member-var-vs-local-var.png" alt="成员变量 vs 局部变量"></p><ul><li><p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p></li></ul><h4 id="为什么成员变量有默认值？"><a href="#为什么成员变量有默认值？" class="headerlink" title="为什么成员变量有默认值？"></a>为什么成员变量有默认值？</h4><p>1.变量存储的是内存地址对应的任意随机值，程序读取该值时会出现意外。</p><p>2.默认值有两种设置方式：手动和自动</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="静态方法为什么不能调用非静态成员？"><a href="#静态方法为什么不能调用非静态成员？" class="headerlink" title="静态方法为什么不能调用非静态成员？"></a>静态方法为什么不能调用非静态成员？</h4><p>1.静态方法是属于类的，类加载时就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化后才存在，需要通过类的实例对象去调用。</p><p>2.在类的非静态成员不存在时静态方法就已经存在了，此时内存调用内存中不存在的非静态成员属于非法操作。</p><h4 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h4><p><strong>重载</strong></p><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同，个数不同，顺序不同，返回值和访问修饰符可以不同。</p><p><strong>重写</strong></p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><p>1.方法名】参数列表必须相同，子类方法返回值类型应比父类方法返回值类型相同或更小，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p><p>2.如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p><p>3.构造方法无法被重写</p><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p>两者区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆分成一个个方法，通过一个个方法解决问题。</li><li>面向对象会先抽象出对象，然后对象执行方法来解决问题。</li></ul><p>面向对象开发的程序一般更易维护、易服用、易扩展。</p><h3 id="创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>创建一个对象用什么运算符？对象实体与对象引用有何不同？</h3><p>new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象应用存放在栈内存中）。</p><ul><li>一个对象引用可以指向0或1个对象</li><li>一个对象可以有n个引用指向它</li></ul><h3 id="对象相等和引用相等区别"><a href="#对象相等和引用相等区别" class="headerlink" title="对象相等和引用相等区别"></a>对象相等和引用相等区别</h3><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般指的是指向的内存地址是否相等</li></ul><p><code>==</code>和<code>equals</code></p><h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h3 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h3><h5 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h5><ul><li>都不能被实例化</li><li>都可以包含抽象方法</li><li>都可以有默认实现的方法（Java8可以用default关键字在接口中定义默认方法）</li></ul><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ul><li>接口主要用于对类的行为进行约束，实现某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是<code>public static final</code>类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可以在子类中被重新定义，也可被重新赋值。</li></ul><h3 id="深拷贝和浅拷贝区别？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别？什么是引用拷贝？"></a>深拷贝和浅拷贝区别？什么是引用拷贝？</h3><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><p><strong>引用拷贝</strong>：引用拷贝就是两个不同的引用指向同一个对象。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object类常见方法？"><a href="#Object类常见方法？" class="headerlink" title="Object类常见方法？"></a>Object类常见方法？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals()的区别"></a>&#x3D;&#x3D; 和 equals()的区别</h3><p><code>==</code>对于基本类型和引用类型作用效果是不同的：</p><ul><li>对基本类型来说，<code>==</code>比较的是值。</li><li>对引用数据来说，<code>==</code>比较的是对象的内存地址。</li></ul><p>equals()两种使用方法：</p><ul><li>类没有重写equals()方法：通过equals()比较该类的两个对象是，等价于通过“&#x3D;&#x3D;”比较</li><li>类重写了equals()方法：比较两个对象中的属性是否相等。</li></ul><h3 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode()有什么用？"></a>hashCode()有什么用？</h3><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><h3 id="为什么要有hashCode"><a href="#为什么要有hashCode" class="headerlink" title="为什么要有hashCode?"></a>为什么要有hashCode?</h3><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p><h3 id="那为什么JDK还要同时提供这两个方法呢？"><a href="#那为什么JDK还要同时提供这两个方法呢？" class="headerlink" title="那为什么JDK还要同时提供这两个方法呢？"></a>那为什么JDK还要同时提供这两个方法呢？</h3><p>因为在一些容器里（如HashMap、HashSet）中，有了hashCode()之后，判断元素是否相等效率更高。</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><h3 id="那为什么不只提供hashCode-方法呢？"><a href="#那为什么不只提供hashCode-方法呢？" class="headerlink" title="那为什么不只提供hashCode()方法呢？"></a>那为什么不只提供hashCode()方法呢？</h3><p>因为两个对象的hashcode值相等并不代表两个对象就相等。</p><h3 id="为什么两个对象hashCode相等他们也不一定是相等的？"><a href="#为什么两个对象hashCode相等他们也不一定是相等的？" class="headerlink" title="为什么两个对象hashCode相等他们也不一定是相等的？"></a>为什么两个对象hashCode相等他们也不一定是相等的？</h3><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><h3 id="为什么重写equals-时必须重写hashCode-方法？"><a href="#为什么重写equals-时必须重写hashCode-方法？" class="headerlink" title="为什么重写equals()时必须重写hashCode()方法？"></a>为什么重写equals()时必须重写hashCode()方法？</h3><p>因为两个相等的对象hashCode值必须相等。如果equals方法判断两个对象是否相等的，那么这两个对象的hashCode值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>总结</strong>：</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String、StringBuffer、StringBuilder的区别？"><a href="#String、StringBuffer、StringBuilder的区别？" class="headerlink" title="String、StringBuffer、StringBuilder的区别？"></a>String、StringBuffer、StringBuilder的区别？</h3><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><p>String是不可变的</p><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>String中的对象是不可变的，也就可以理解为常量，线程安全。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ul><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ul><h3 id="字符串常量池作用"><a href="#字符串常量池作用" class="headerlink" title="字符串常量池作用"></a>字符串常量池作用</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Exception和Error区别？"><a href="#Exception和Error区别？" class="headerlink" title="Exception和Error区别？"></a>Exception和Error区别？</h3><p>Java中，所有异常都有一个共同祖先，java.lang包的Throwable类。</p><p>其中两个重要的子类：</p><ul><li>Exception：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li>Error：Error属于程序无法处理的错误。</li></ul><h3 id="finally中的代码一定会执行吗？"><a href="#finally中的代码一定会执行吗？" class="headerlink" title="finally中的代码一定会执行吗？"></a>finally中的代码一定会执行吗？</h3><p>不一定！某些情况下不会。</p><p>比如finally之前虚拟机被终止运行，finally中的代码就不会被执行。</p><p>在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型？作用是什么？"><a href="#什么是泛型？作用是什么？" class="headerlink" title="什么是泛型？作用是什么？"></a>什么是泛型？作用是什么？</h3><p>Java泛型是JDK5引入的新特性，使用泛型参数可以增强代码的可读性以及稳定性。</p><h3 id="泛型的使用方式有哪几种？"><a href="#泛型的使用方式有哪几种？" class="headerlink" title="泛型的使用方式有哪几种？"></a>泛型的使用方式有哪几种？</h3><p>泛型一般有三种使用方式：<strong>泛型类、泛型接口、泛型方法</strong>。</p><p><strong>1.泛型类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.泛型接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现，不指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现，指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.泛型方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">   &#123;</span><br><span class="line">         <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是框架的灵魂，它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p><h3 id="反射的优缺点？"><a href="#反射的优缺点？" class="headerlink" title="反射的优缺点？"></a>反射的优缺点？</h3><p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供的便利。但是，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>]]></content>
    
    
    <summary type="html">Java面试题</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2024/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2024/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-04-23T11:57:32.000Z</published>
    <updated>2024-06-19T07:19:49.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（Simple Responsibility Pinciple，SRP）是最简单的面向对象设计原则，它用于控制类的粒度大小。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cooking</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我会做饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teaching</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我会教书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>People类中功能太多，略显臃肿，应该将各种能力再细分成对应的职业：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cooker</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cooking</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我会做饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teaching</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我会教书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将类的粒度进行更近一步的划分，这样就很清晰了，包括我们以后在设计Mapper、Service、Controller等等，根据不同的业务进行划分，都可以采用单一职责原则，以它作为我们实现高内聚低耦合的指导方针。实际上我们的微服务也是参考了单一职责原则，每个微服务只应担负一个职责。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则（Open Close Principle）也是重要的面向对象设计原则。</p><p><code>软件实体应当对扩展开放，对修改关闭。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义抽象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Code&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">JavaCoder</span> <span class="keyword">extends</span> <span class="title class_">Code</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Java太卷了T_T&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类，只用定义这个类要求的行为，具体实现由需要实现他的类自行实现，有较好的扩展性延续性。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则（Liskov Substitution Principle）是对子类型的特别定义。它由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为 “数据的抽象与层次” 的演说中首先提出。</p><blockquote><p>所有引用基类的地方必须能透明地使用其子类的对象。</p></blockquote><p>简单的说就是，子类可以扩展父类的功能，但不能改变父类原有的功能：</p><ol><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入&#x2F;入参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的输出&#x2F;返回值）要比父类更严格或与父类一样。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会打lol&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我爱学习&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son继承了Father，但是并没有覆盖play方法。符合里氏替换原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会打lol&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我爱学习&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我爱cs&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son覆盖了父类play，他不再具备父类的行为了，违背了里氏替换原则。</p><p>这种情况可以让他们两都继承于一个更高的类<code>People</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;   <span class="comment">//这个行为还是定义出来，但是不实现</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会打lol&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我爱学习&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我爱cs&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>依赖倒转原则（Dependence Inversion Principle）也是我们一直在使用的，最明显的就是我们的Spring框架了。</p><blockquote><p>高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。</p></blockquote><p>在之前，编写项目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//CRUD...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserServiceNew</span> &#123;   <span class="comment">//由于UserServiceNew发生变化，会直接影响到其他高层模块</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserMapper</span>();</span><br><span class="line">        <span class="comment">//业务代码....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;   <span class="comment">//焯，干嘛改底层啊，我这又得重写了</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();   <span class="comment">//哦豁，原来的不能用了</span></span><br><span class="line">        <span class="type">UserServiceNew</span> <span class="variable">serviceNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceNew</span>();   <span class="comment">//只能修改成新的了</span></span><br><span class="line">        <span class="comment">//业务代码....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Spring框架后，使用ServiceImpl来具体实现Service中的方法，Controller直接注入Service接口，这样修改实现也不用修改对应业务的逻辑。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则（Interface Segregation Principle, ISP）实际上是对接口的细化。</p><blockquote><p>客户端不应依赖那些它不需要的接口。  </p></blockquote><p>电脑和风扇都是电子设备，但是电脑拥有CPU显卡等部件，因此不能单单编写一个Device类让他们两个继承，需要细分为电子设备和普通设备，避免过多不需要的属性堆叠。</p><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则（Composite Reuse Principle）的核心就是委派。</p><blockquote><p>优先使用对象组合，而不是通过继承来达到复用的目的。</p></blockquote><p>可以将B中需要的A类当作B的一个属性 A a，在要用到B的时候进行指定A。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则（Law of Demeter）又称最少知识原则，是对程序内部数据交互的限制。</p><blockquote><p>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p></blockquote><p>简单来说就是，一个类&#x2F;模块对其他的类&#x2F;模块有越少的交互越好。当一个类发生改动，那么，与其相关的类（比如用到此类啥方法的类）需要尽可能少的受影响（比如修改了方法名、字段名等，可能其他用到这些方法或是字段的类也需要跟着修改）这样我们在维护项目的时候会更加轻松一些。</p><p>Test方法需要一个A类的name属性，传入时不传入A类，而是传入String name，在外部Main方法，直接提取A中的name传入Test。</p><h1 id="设计模式（创建型）"><a href="#设计模式（创建型）" class="headerlink" title="设计模式（创建型）"></a>设计模式（创建型）</h1><p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>使用<code>简单工厂模式</code>来创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;   <span class="comment">//水果抽象类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fruit</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot;@&quot;</span>+hashCode();   <span class="comment">//打印一下当前水果名称，还有对象的hashCode</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;   <span class="comment">//苹果，继承自水果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;  <span class="comment">//橘子，也是继承自水果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;橘子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，我们直接new就可以得到对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        System.out.println(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们将对象的创建封装到工厂中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里就直接来一个静态方法根据指定类型进行创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 水果类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的水果对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getFruit</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;苹果&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&quot;橘子&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Orange</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就可以使用此工厂来创建对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> FruitFactory.getFruit(<span class="string">&quot;橘子&quot;</span>);   <span class="comment">//直接问工厂要，而不是我们自己去创建</span></span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用对扩展开放，对修改关闭的性质，将<code>简单工厂模式</code>改进为<code>工厂方法模式</code>，那现在既然不让改，那么我们就看看如何去使用扩展的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; &#123;   <span class="comment">//将水果工厂抽象为抽象类，添加泛型T由子类指定水果类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title function_">getFruit</span><span class="params">()</span>;  <span class="comment">//不同的水果工厂，通过此方法生产不同的水果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">extends</span> <span class="title class_">FruitFactory</span>&lt;Apple&gt; &#123;  <span class="comment">//苹果工厂，直接返回Apple，一步到位</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Apple <span class="title function_">getFruit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以使用不同类型的工厂来生产不同类型的水果了，并且如果新增了水果类型，直接创建一个新的工厂类就行，不需要修改之前已经编写好的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">AppleFactory</span>()::getFruit);   <span class="comment">//比如我们现在要吃一个苹果，那么就直接通过苹果工厂来获取苹果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法模拟吃掉一个水果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Supplier&lt;Fruit&gt; supplier)</span>&#123;</span><br><span class="line">        System.out.println(supplier.get()+<span class="string">&quot; 被吃掉了，真好吃。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就简单实现了工厂方法模式，通过工厂来屏蔽对象的创建细节，使用者只需要关心如何去使用对象即可。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>经常看到有很多的框架都为我们提供了形如<code>XXXBuilder</code>的类型，我们一般也是使用这些类来创建我们需要的对象。</p><p>JavaSE中的StringBulider类。。。</p><p>现在有一个学生类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">    String name;</span><br><span class="line">    String college;</span><br><span class="line">    String profession;</span><br><span class="line">    List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, <span class="type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.college = college;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">        <span class="built_in">this</span>.awards = awards;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他的属性很多，直接构造容易出错。所以，我们现在可以使用建造者模式来进行对象的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一律使用建造者来创建，不对外直接开放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, <span class="type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentBuilder <span class="title function_">builder</span><span class="params">()</span>&#123;   <span class="comment">//通过builder方法直接获取建造者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentBuilder</span>&#123;   <span class="comment">//这里就直接创建一个内部类</span></span><br><span class="line">        <span class="comment">//Builder也需要将所有的参数都进行暂时保存，所以Student怎么定义的这里就怎么定义</span></span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> grade;</span><br><span class="line">        String name;</span><br><span class="line">        String college;</span><br><span class="line">        String profession;</span><br><span class="line">        List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">id</span><span class="params">(<span class="type">int</span> id)</span>&#123;    <span class="comment">//直接调用建造者对应的方法，为对应的属性赋值</span></span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;   <span class="comment">//为了支持链式调用，这里直接返回建造者本身，下同</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">awards</span><span class="params">(String... awards)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.awards = Arrays.asList(awards);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">build</span><span class="params">()</span>&#123;    <span class="comment">//最后我们只需要调用建造者提供的build方法即可根据我们的配置返回一个对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(id, age, grade, name, college, profession, awards);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们就可以使用建造者来为我们生成对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder()   <span class="comment">//获取建造者</span></span><br><span class="line">            .id(<span class="number">1</span>)    <span class="comment">//逐步配置各个参数</span></span><br><span class="line">            .age(<span class="number">18</span>)</span><br><span class="line">            .grade(<span class="number">3</span>)</span><br><span class="line">            .name(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">            .awards(<span class="string">&quot;ICPC-ACM 区域赛 金牌&quot;</span>, <span class="string">&quot;LPL 2022春季赛 冠军&quot;</span>)</span><br><span class="line">            .build();   <span class="comment">//最后直接建造我们想要的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>懒汉式和饿汉式</p><p><strong>饿汉式</strong>：在使用这个类时自动进行创建对应实例对象。</p><p><strong>懒汉式</strong>：在使用这个类的单例对象初始化方法时才会创建对象。</p><p>饿汉式<strong>多线程环境下会有问题！</strong>，如果几个线程同时调用，会被创建多次。为了避免这个问题，最简单的是加一个<code>synchronized</code>锁，但是在高并发情况下效率很低。</p><p>优化：在一开始进行if判断，判断需要的单例对象是否为空，但是这样也有可能多个线程同时判断为null进入等锁状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">//内层还要进行一次检查，双重检查锁定</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java中可以使用静态内部类，实现不加锁写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;   <span class="comment">//由静态内部类持有单例对象，但是根据类加载特性，我们仅使用Singleton类时，不会对静态内部类进行初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;   <span class="comment">//只有真正使用内部类时，才会进行类初始化</span></span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;   <span class="comment">//直接获取内部类中的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式与对象的拷贝紧密相关</p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul><li><strong>浅拷贝：</strong> 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象</li></ul><ul><li><strong>深拷贝：</strong> 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</li></ul>]]></content>
    
    
    <summary type="html">设计模式</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数组相关题目</title>
    <link href="http://example.com/2024/04/22/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/04/22/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/</id>
    <published>2024-04-22T09:08:32.000Z</published>
    <updated>2024-06-19T07:20:19.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组总结"><a href="#数组总结" class="headerlink" title="数组总结"></a>数组总结</h1><h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p><p>举一个字符数组的例子，如图所示：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png" alt="img"></p><ul><li><strong>数组的下标都是从0开始的</strong></li><li><strong>数组内存空间都是连续的</strong></li></ul><p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p><p><strong>数组的元素是不能删的，只能覆盖。</strong></p><h2 id="数组的经典题目"><a href="#数组的经典题目" class="headerlink" title="数组的经典题目"></a>数组的经典题目</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p><strong>循环不变量原则</strong></p><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p><h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><p>寻找合适的边界条件。</p>]]></content>
    
    
    <summary type="html">算法题</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="http://example.com/2024/04/21/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>http://example.com/2024/04/21/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</id>
    <published>2024-04-21T06:53:32.000Z</published>
    <updated>2024-06-19T07:19:15.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p><h3 id="模拟转圈的过程"><a href="#模拟转圈的过程" class="headerlink" title="模拟转圈的过程"></a>模拟转圈的过程</h3><p><strong>边界点的处理</strong>（循环不变量）</p><p><code>不变量</code>:对每条边的处理规则 </p><p>使用左闭右开，处理第一个节点，不处理最后一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n矩阵大小</span></span><br><span class="line">startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line">offset = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">loop = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(loop &lt;= n / <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = starty; j &lt; n - offset; j++)&#123;</span><br><span class="line">        nums[startx][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = startx; i &lt; n - offset; i++)&#123;</span><br><span class="line">        nums[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; j &gt; starty; j--)&#123;</span><br><span class="line">        nums[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; i &gt; startx; i--)&#123;</span><br><span class="line">        nums[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    startx++;</span><br><span class="line">    starty++;</span><br><span class="line">    offset++;</span><br><span class="line">    loop++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">    nums[i][j] = count;</span><br></pre></td></tr></table></figure><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="number">0</span>, startY = <span class="number">0</span>;  <span class="comment">// 每一圈的起始点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 矩阵中需要填写的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 记录当前的圈数</span></span><br><span class="line">        <span class="type">int</span> i, j; <span class="comment">// j 代表列, i 代表行;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop &lt;= n / <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 顶部</span></span><br><span class="line">            <span class="comment">// 左闭右开，所以判断循环结束时， j 不能等于 n - offset</span></span><br><span class="line">            <span class="keyword">for</span> (j = startY; j &lt; n - offset; j++) &#123;</span><br><span class="line">                nums[startX][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右列</span></span><br><span class="line">            <span class="comment">// 左闭右开，所以判断循环结束时， i 不能等于 n - offset</span></span><br><span class="line">            <span class="keyword">for</span> (i = startX; i &lt; n - offset; i++) &#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 底部</span></span><br><span class="line">            <span class="comment">// 左闭右开，所以判断循环结束时， j != startY</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; startY; j--) &#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左列</span></span><br><span class="line">            <span class="comment">// 左闭右开，所以判断循环结束时， i != startX</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startX; i--) &#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startX++;</span><br><span class="line">            startY++;</span><br><span class="line">            offset++;</span><br><span class="line">            loop++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// n 为奇数时，单独处理矩阵中心的值</span></span><br><span class="line">            nums[startX][startY] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">代码随想录 (programmercarl.com)</a></p>]]></content>
    
    
    <summary type="html">算法题</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="螺旋矩阵" scheme="http://example.com/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>双指针之滑动窗口</title>
    <link href="http://example.com/2024/04/20/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://example.com/2024/04/20/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2024-04-20T06:13:32.000Z</published>
    <updated>2024-06-19T07:21:19.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针之滑动窗口"><a href="#双指针之滑动窗口" class="headerlink" title="双指针之滑动窗口"></a>双指针之滑动窗口</h1><p>使用一个for循环完成两个for循环，for循环中的变量表示窗口的终止位置。（如何移动起始位置？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i起始位置，j终止位置，sum当前窗口值大小，subL窗口长度</span></span><br><span class="line">result = max;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">    sum += nums[j];</span><br><span class="line">    <span class="comment">//用while不用if，因为是持续寻找最小窗口的过程</span></span><br><span class="line">    <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">        subL = j - i + <span class="number">1</span>;</span><br><span class="line">        result = Math.min(subL, result);</span><br><span class="line">        sum = sum - nums[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p><h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p><h2 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h2><ul><li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li><li><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a></li></ul>]]></content>
    
    
    <summary type="html">算法题</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="双指针之滑动窗口" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>双指针算法</title>
    <link href="http://example.com/2024/04/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2024/04/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</id>
    <published>2024-04-19T07:29:32.000Z</published>
    <updated>2024-06-19T07:20:48.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>一个快指针，一个慢指针。使用一层for循环解决两层for循环做的事情。</p><p><code>快指针</code>：寻找新数组所需要的元素</p><p><code>慢指针</code>：获取新数组中需要更新的位置，新数组下标值就是慢指针，需要更新的下标值就是慢指针。</p><p>​<img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="27.移除元素-双指针法"></p><h4 id="例题：27-移除元素-力扣（LeetCode）"><a href="#例题：27-移除元素-力扣（LeetCode）" class="headerlink" title="例题：27. 移除元素 - 力扣（LeetCode）"></a>例题：<a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素 - 力扣（LeetCode）</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(fast = <span class="number">0</span>; fast &lt; nums.size; fast++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        slow++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br></pre></td></tr></table></figure><h2 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h2><ul><li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26.删除排序数组中的重复项(opens new window)</a></li><li><a href="https://leetcode.cn/problems/move-zeroes/">283.移动零(opens new window)</a></li><li><a href="https://leetcode.cn/problems/backspace-string-compare/">844.比较含退格的字符串(opens new window)</a></li><li><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977.有序数组的平方</a></li></ul><h3 id="length-length-size-区别"><a href="#length-length-size-区别" class="headerlink" title="length,length(),size()区别"></a>length,length(),size()区别</h3><p>首先区分一下length和length()；</p><p><strong>length不是方法，是属性，数组的属性；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] intArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;这个数组的长度为：&quot;</span> + intArray.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>length()是字符串String的一个方法；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;这个字符串的长度为：&quot;</span> + str.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>size()方法，是List集合的一个方法；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;这个list的长度为：&quot;</span> + list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p><strong>length——数组的属性；</strong></p><p><strong>length()——String的方法；</strong></p><p><strong>size()——集合的方法；</strong></p>]]></content>
    
    
    <summary type="html">算法题</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity</title>
    <link href="http://example.com/2024/04/19/SpringSecurity/"/>
    <id>http://example.com/2024/04/19/SpringSecurity/</id>
    <published>2024-04-19T06:53:32.000Z</published>
    <updated>2024-06-19T07:15:24.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><p>SpringSecurity是一个基于Spring开发的非常强大的权限验证框架，其核心功能包括：</p><ul><li>认证 （用户登录）</li><li>授权 （此用户能够做哪些事情）</li><li>攻击防护 （防止伪造身份攻击）</li></ul><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="基于内存验证"><a href="#基于内存验证" class="headerlink" title="基于内存验证"></a>基于内存验证</h3><p>直接以代码的形式配置我们网站的用户和密码，配置方式非常简单，只需要在Security配置类中注册一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//UserDetailsService就是获取用户信息的服务</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//每一个UserDetails就代表一个用户信息，其中包含用户的用户名和密码以及角色</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">                .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)  <span class="comment">//角色目前我们不需要关心，随便写就行，后面会专门讲解</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">admin</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">                .username(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user, admin); </span><br><span class="line">      <span class="comment">//创建一个基于内存的用户信息管理器作为UserDetailsService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>withDefaultPasswordEncoder()被弃用，现在推荐使用BCryptPasswordEncoder()。</p><h3 id="基于数据库校验"><a href="#基于数据库校验" class="headerlink" title="基于数据库校验"></a>基于数据库校验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//手动创建一个AuthenticationManager用于处理密码校验</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(UserDetailsManager manager,</span></span><br><span class="line"><span class="params">                                                        PasswordEncoder encoder)</span>&#123;</span><br><span class="line">        <span class="type">DaoAuthenticationProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoAuthenticationProvider</span>();</span><br><span class="line">        provider.setUserDetailsService(manager);</span><br><span class="line">        provider.setPasswordEncoder(encoder);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProviderManager</span>(provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsManager <span class="title function_">userDetailsService</span><span class="params">(DataSource dataSource,</span></span><br><span class="line"><span class="params">                                                 PasswordEncoder encoder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JdbcUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcUserDetailsManager</span>(dataSource);</span><br><span class="line">      <span class="comment">//为UserDetailsManager设置AuthenticationManager即可开启重置密码的时的校验</span></span><br><span class="line">        manager.setAuthenticationManager(authenticationManager(manager, encoder));</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h3><p>Service内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> mapper.findUserByName(username);</span><br><span class="line">        <span class="keyword">if</span>(account == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> User</span><br><span class="line">                .withUsername(username)</span><br><span class="line">                .password(account.getPassword())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h2><p>配置config</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line"><span class="comment">//如果你学习过SpringSecurity 5.X版本，可能会发现新版本的配置方式完全不一样</span></span><br><span class="line">    <span class="comment">//新版本全部采用lambda形式进行配置，无法再使用之前的and()方法进行连接了</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                <span class="comment">//以下是验证请求拦截和放行配置</span></span><br><span class="line">                .authorizeHttpRequests(auth -&gt; &#123;</span><br><span class="line">                    auth.anyRequest().authenticated();    <span class="comment">//将所有请求全部拦截，一律需要验证</span></span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//以下是表单登录相关配置</span></span><br><span class="line">                .formLogin(conf -&gt; &#123;</span><br><span class="line">                    conf.loginPage(<span class="string">&quot;/login&quot;</span>);   <span class="comment">//将登录页设置为我们自己的登录页面</span></span><br><span class="line">                    conf.loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>); <span class="comment">//登录表单提交的地址，可以自定义</span></span><br><span class="line">                    conf.defaultSuccessUrl(<span class="string">&quot;/&quot;</span>);   <span class="comment">//登录成功后跳转的页面</span></span><br><span class="line">                    conf.permitAll();    <span class="comment">//将登录相关的地址放行，否则未登录的用户连登录界面都进不去</span></span><br><span class="line">                  <span class="comment">//用户名和密码的表单字段名称，不过默认就是这个，可以不配置，除非有特殊需求</span></span><br><span class="line">                    conf.usernameParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">                    conf.passwordParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到<code>302</code>看有没有放行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是csrf相关配置</span></span><br><span class="line">               .csrf(conf -&gt; &#123;</span><br><span class="line">                   conf.disable();   <span class="comment">//此方法可以直接关闭全部的csrf校验，一步到位</span></span><br><span class="line">                   conf.ignoringRequestMatchers(<span class="string">&quot;/xxx/**&quot;</span>);   <span class="comment">//此方法可以根据情况忽略某些地址的csrf校验</span></span><br><span class="line">               &#125;)</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍了SpringSecurity的认证方法</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="SpringSecurity" scheme="http://example.com/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>单例模式 singleton</title>
    <link href="http://example.com/2024/04/18/%E7%AC%94%E8%AE%B02/"/>
    <id>http://example.com/2024/04/18/%E7%AC%94%E8%AE%B02/</id>
    <published>2024-04-18T06:53:32.000Z</published>
    <updated>2024-06-19T07:16:41.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式-singleton"><a href="#单例模式-singleton" class="headerlink" title="单例模式 singleton"></a>单例模式 singleton</h2><p>IOC容器每次创建bean对象，都是同一个。</p><p>当Bean的作用域为单例模式时，他会在一开始（容器加载配置时）就被创建，之后拿到的都是这个对象。（可以配置<strong>lazy</strong>懒加载，不在一开始就创建对象）</p><h2 id="原型模式-prototype"><a href="#原型模式-prototype" class="headerlink" title="原型模式 prototype"></a>原型模式 prototype</h2><p>每次调用都新建一个对象。</p><p>处于原型模式时，只有在被获取时才会被创建，也就是说，在单例模式下Bean会被IOC容器存储，只要容器没有被销毁，那么此对象将会一直存在，而原型模式才相当于在要用的时候直接new一个对象，并不会被保存。</p><h1 id="controller控制器"><a href="#controller控制器" class="headerlink" title="controller控制器"></a>controller控制器</h1><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>@RequestMapping(“&#x2F;index”)可以多个路径-&gt;@RequestMapping({“&#x2F;index”, “&#x2F;hello”})</p><p>放在当前Controller类名上时，当前controller中的所有Mapping映射前面都需要加一个这个路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/yyds&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/index&quot;, &quot;/test&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径还支持使用通配符进行匹配：</p><ul><li><p>?：表示任意一个字符，比如<code>@RequestMapping(&quot;/index/x?&quot;)</code>可以匹配&#x2F;index&#x2F;xa、&#x2F;index&#x2F;xb等等。</p></li><li><p>*：表示任意0-n个字符，比如<code>@RequestMapping(&quot;/index/*&quot;)</code>可以匹配&#x2F;index&#x2F;lbwnb、&#x2F;index&#x2F;yyds等。</p></li><li><p>**：表示当前目录或基于当前目录的多级目录，比如<code>@RequestMapping(&quot;/index/**&quot;)</code>可以匹配&#x2F;index、&#x2F;index&#x2F;xxx等。</p><p>RequestMapping可以在内部设置method来定义允许访问的类型。也可以直接明确书写 @PostMapping或@GetMapping、@DeletedMapping等</p><h2 id="RequestParam和-RequestHeader"><a href="#RequestParam和-RequestHeader" class="headerlink" title="@RequestParam和@RequestHeader"></a>@RequestParam和@RequestHeader</h2><p>获取请求中的参数，只需要在方法上添加一个形参，形参前面加上@RequestParam：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">index</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们需要在<code>@RequestParam</code>中填写参数名称，参数的值会自动传递给形式参数，我们可以直接在方法中使用，注意，如果参数名称与形式参数名称相同，即使不添加<code>@RequestParam</code>也能获取到参数值。</p></blockquote></li></ul><p>一旦添加<code>@RequestParam</code>，那么此请求必须携带指定参数，我们也可以将require属性设定为false来将属性设定为非必须。</p><h2 id="RestFul风格"><a href="#RestFul风格" class="headerlink" title="RestFul风格"></a>RestFul风格</h2><p>中文释义为<strong>“表现层状态转换”</strong>（名字挺高大上的），它不是一种标准，而是一种设计风格。它的主要作用是充分并正确利用HTTP协议的特性，规范资源获取的URI路径。通俗的讲，RESTful风格的设计允许将参数通过URL拼接传到服务端，目的是让URL看起来更简洁实用，并且我们可以充分使用多种HTTP请求方式（POST&#x2F;GET&#x2F;PUT&#x2F;DELETE），来执行相同请求地址的不同类型操作。</p><p>这种风格的连接，我们就可以直接从请求路径中读取参数，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/mvc/index/123456</span><br></pre></td></tr></table></figure><p>我们可以直接将index的下一级路径作为请求参数进行处理，也就是说现在的请求参数包含在了请求路径中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/index/&#123;str&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(<span class="meta">@PathVariable</span> String str)</span> &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以按照不同功能进行划分：</p><ul><li>POST <a href="http://localhost:8080/mvc/index">http://localhost:8080/mvc/index</a> -  添加用户信息，携带表单数据</li><li>GET <a href="http://localhost:8080/mvc/index/%7Bid%7D">http://localhost:8080/mvc/index/{id}</a> -  获取用户信息，id直接放在请求路径中</li><li>PUT <a href="http://localhost:8080/mvc/index">http://localhost:8080/mvc/index</a> -  修改用户信息，携带表单数据</li><li>DELETE <a href="http://localhost:8080/mvc/index/%7Bid%7D">http://localhost:8080/mvc/index/{id}</a> -  删除用户信息，id直接放在请求路径中</li></ul><p>我们分别编写四个请求映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String text)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取用户：&quot;</span>+text);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">post</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户：&quot;</span>+username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String text)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户：&quot;</span>+text);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index&quot;, method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改用户：&quot;</span>+username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">杂项</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>IOC（对象的创建权）</title>
    <link href="http://example.com/2023/11/20/IOC%EF%BC%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9D%83%EF%BC%89/"/>
    <id>http://example.com/2023/11/20/IOC%EF%BC%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9D%83%EF%BC%89/</id>
    <published>2023-11-20T12:19:32.000Z</published>
    <updated>2024-06-19T07:00:18.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IOC（对象的创建权）"><a href="#IOC（对象的创建权）" class="headerlink" title="IOC（对象的创建权）"></a>IOC（对象的创建权）</h2><p>创建多个Bean来管理类，新建一个容器用来存放Beans，每次要使用哪个类，通过类id去容器里面使用对应的bean创建类。</p><p>实现了控制反转，将原来手动创建类变成了交给容器创建。</p><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>singleton和prototype</p><p>singleton(单例模式):使用这个模式的Bean创建出来的对象每次就一个，创建多次都是同一个。</p><p>prototype(多例模式):使用这个模式的Bean每次创建对象都是创建一个新的对象。</p><h2 id="DI（对象的维护权）"><a href="#DI（对象的维护权）" class="headerlink" title="DI（对象的维护权）"></a>DI（对象的维护权）</h2>]]></content>
    
    
    <summary type="html">IOC概念</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="IoC" scheme="http://example.com/tags/IoC/"/>
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="http://example.com/2023/10/18/%E7%AC%94%E8%AE%B01/"/>
    <id>http://example.com/2023/10/18/%E7%AC%94%E8%AE%B01/</id>
    <published>2023-10-18T06:53:32.000Z</published>
    <updated>2024-06-19T07:16:08.676Z</updated>
    
    <content type="html"><![CDATA[<p><code>class Solution &#123;</code><br>  <code>public long maxKelements(int[] nums, int k) &#123;</code><br><code>​    PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;((a,b) -&gt; b - a);</code><br><code>​    for(int num : nums)&#123;</code><br><code>​      q.offer(num);</code><br><code>​    &#125;</code><br><code>​    long ans = 0;</code><br><code>​    for(int i = 0; i &lt; k ; i++)&#123;</code><br><code>​      int x = q.poll();</code><br><code>​      ans += x;</code><br><code>​      q.offer((x+2) / 3);</code><br><code>​    &#125;</code><br><code>​    return ans;</code><br>  <code>&#125;</code><br><code>&#125;</code></p><h3 id="ProiorityQueue-q-优先队列"><a href="#ProiorityQueue-q-优先队列" class="headerlink" title="ProiorityQueue q 优先队列"></a>ProiorityQueue<T> q 优先队列</h3><p>保留了队列先进先出的性质，另外可以通过添加条件来使特定的元素存储在最前面。</p><p>（a，b） -&gt; b - a  如果a&lt;b则b-a为正数为真，则符合条件。用来设置这个队列中按照从大到小排列。</p><p>String.valueOf(); 可以将对象转换为String类型</p>]]></content>
    
    
    <summary type="html">优先队列算法</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="优先队列" scheme="http://example.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
