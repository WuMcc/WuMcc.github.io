<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello, Blog!</title>
    <url>/2024/05/21/%E7%BB%99%20SheepMango%EF%BC%9A/</url>
    <content><![CDATA[<h1 id="给-SheepMango："><a href="#给-SheepMango：" class="headerlink" title="给 SheepMango："></a>给 SheepMango：</h1><h2 id="搭建了一个个人小博客，保佑找到好工作！🥭🐏"><a href="#搭建了一个个人小博客，保佑找到好工作！🥭🐏" class="headerlink" title="搭建了一个个人小博客，保佑找到好工作！🥭🐏"></a>搭建了一个个人小博客，保佑找到好工作！🥭🐏</h2>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>❤</tag>
      </tags>
  </entry>
  <entry>
    <title>31 你了解Java应用开发中的注入攻击吗？</title>
    <url>/2024/09/22/2024-09-22-31-%E4%BD%A0%E4%BA%86%E8%A7%A3Java%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="31-你了解Java应用开发中的注入攻击吗？"><a href="#31-你了解Java应用开发中的注入攻击吗？" class="headerlink" title="31 你了解Java应用开发中的注入攻击吗？"></a>31 你了解Java应用开发中的注入攻击吗？</h1><p>安全是软件开发领域永远的主题之一，随着新技术浪潮的兴起，安全的重要性愈发凸显出来，对于金融等行业，甚至可以说安全是企业的生命线。不论是移动设备、普通 PC、小型机，还是大规模分布式系统，以及各种主流操作系统，Java 作为软件开发的基础平台之一，可以说是无处不在，自然也就成为安全攻击的首要目标之一。</p>
<p>今天我要问你的问题是，<strong>你了解 Java 应用开发中的注入攻击吗？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>注入式（Inject）攻击是一类非常常见的攻击方式，其基本特征是程序允许攻击者将不可信的动态内容注入到程序中，并将其执行，这就可能完全改变最初预计的执行过程，产生恶意效果。</p>
<p>下面是几种主要的注入式攻击途径，原则上提供动态执行能力的语言特性，都需要提防发生注入攻击的可能。</p>
<p>首先，就是最常见的 SQL 注入攻击。一个典型的场景就是 Web 系统的用户登录功能，根据用户输入的用户名和密码，我们需要去后端数据库核实信息。</p>
<p>假设应用逻辑是，后端程序利用界面输入动态生成类似下面的 SQL，然后让 JDBC 执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from use_info <span class="type">where</span> <span class="variable">username</span> <span class="operator">=</span> “input_usr_name” <span class="type">and</span> <span class="variable">password</span> <span class="operator">=</span> “input_pwd”</span><br></pre></td></tr></table></figure>

<p>但是，如果我输入的 input_pwd 是类似下面的文本，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">“ or “”=”</span><br></pre></td></tr></table></figure>

<p>那么，拼接出的 SQL 字符串就变成了下面的条件，OR 的存在导致输入什么名字都是复合条件的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from use_info <span class="type">where</span> <span class="variable">username</span> <span class="operator">=</span> “input_usr_name” <span class="type">and</span> <span class="variable">password</span> <span class="operator">=</span> “” or “” = “”</span><br></pre></td></tr></table></figure>

<p>这里只是举个简单的例子，它是利用了期望输入和可能输入之间的偏差。上面例子中，期望用户输入一个数值，但实际输入的则是 SQL 语句片段。类似场景可以利用注入的不同 SQL 语句，进行各种不同目的的攻击，甚至还可以加上“;delete xxx”之类语句，如果数据库权限控制不合理，攻击效果就可能是灾难性的。</p>
<p>第二，操作系统命令注入。Java 语言提供了类似 Runtime.exec(…) 的 API，可以用来执行特定命令，假设我们构建了一个应用，以输入文本作为参数，执行下面的命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ls –la input_file_name</span><br></pre></td></tr></table></figure>

<p>但是如果用户输入是 “input_file_name;rm –rf &#x2F;*”，这就有可能出现问题了。当然，这只是个举例，Java 标准类库本身进行了非常多的改进，所以类似这种编程错误，未必可以真的完成攻击，但其反映的一类场景是真实存在的。</p>
<p>第三，XML 注入攻击。Java 核心类库提供了全面的 XML 处理、转换等各种 API，而 XML 自身是可以包含动态内容的，例如 XPATH，如果使用不当，可能导致访问恶意内容。</p>
<p>还有类似 LDAP 等允许动态内容的协议，都是可能利用特定命令，构造注入式攻击的，包括 XSS（Cross-site Scripting）攻击，虽然并不和 Java 直接相关，但也可能在 JSP 等动态页面中发生。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是安全领域的入门题目，我简单介绍了最常见的几种注入场景作为示例。安全本身是个非常大的主题，在面试中，面试官可能会考察安全问题，但如果不是特定安全专家岗位，了解基础的安全实践就可以满足要求了。</p>
<p>Java 工程师未必都要成为安全专家，但了解基础的安全领域常识，有利于发现和规避日常开发中的风险。今天我会侧重和 Java 开发相关的安全内容，希望可以起到一个抛砖引玉的作用，让你对 Java 开发安全领域有个整体印象。</p>
<ul>
<li>谈到 Java 应用安全，主要涉及哪些安全机制？</li>
<li>到底什么是安全漏洞？对于前面提到的 SQL 注入等典型攻击，我们在开发中怎么避免？</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，一起来看看哪些 Java API 和工具构成了 Java 安全基础。很多方面我在专栏前面的讲解中已经有所涉及，可以简单归为三个主要组成部分：</p>
<p>第一，运行时安全机制。可以简单认为，就是限制 Java 运行时的行为，不要做越权或者不靠谱的事情，具体来看：</p>
<ul>
<li>在类加载过程中，进行字节码验证，以防止不合规的代码影响 JVM 运行或者载入其他恶意代码。</li>
<li>类加载器本身也可以对代码之间进行隔离，例如，应用无法获取启动类加载器（Bootstrap Class-Loader）对象实例，不同的类加载器也可以起到容器的作用，隔离模块之间不必要的可见性等。目前，Java Applet、RMI 等特性已经或逐渐退出历史舞台，类加载等机制总体上反倒在不断简化。</li>
<li>利用 SecurityManger 机制和相关的组件，限制代码的运行时行为能力，其中，你可以定制 policy 文件和各种粒度的权限定义，限制代码的作用域和权限，例如对文件系统的操作权限，或者监听某个网络端口的权限等。我画了一个简单的示意图，对运行时安全的不同层次进行了整理。</li>
</ul>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/b48e754c6ebb11b6934f4697b7091854-20221127210846-v5vub90.png" alt="img"></p>
<p>可以看到，Java 的安全模型是以代码为中心的，贯穿了从类加载，如 URLClassLoader 加载网络上的 Java 类等，到应用程序运行时权限检查等全过程。</p>
<ul>
<li>另外，从原则上来说，Java 的 GC 等资源回收管理机制，都可以看作是运行时安全的一部分，如果相应机制失效，就会导致 JVM 出现 OOM 等错误，可看作是另类的拒绝服务。</li>
</ul>
<p>第二，Java 提供的安全框架 API，这是构建安全通信等应用的基础。例如：</p>
<ul>
<li>加密、解密 API。</li>
<li>授权、鉴权 API。</li>
<li>安全通信相关的类库，比如基本 HTTPS 通信协议相关标准实现，如<a href="http://openjdk.java.net/jeps/332">TLS 1.3</a>；或者附属的类似证书撤销状态判断（<a href="https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol">OSCP</a>）等协议实现。</li>
</ul>
<p>注意，这一部分 API 内部实现是和厂商相关的，不同 JDK 厂商往往会定制自己的加密算法实现。</p>
<p>第三， 就是 JDK 集成的各种安全工具，例如：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html">keytool</a>，这是个强大的工具，可以管理安全场景中不可或缺的秘钥、证书等，并且可以管理 Java 程序使用的 keystore 文件。</li>
<li><a href="https://docs.oracle.com/javase/9/tools/jarsigner.htm#JSWOR-GUID-925E7A1B-B3F3-44D2-8B49-0B3FA2C54864">jarsigner</a>，用于对 jar 文件进行签名或者验证。</li>
</ul>
<p>在应用实践中，如果对安全要求非常高，建议打开 SecurityManager，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Djava.security.manager</span><br></pre></td></tr></table></figure>

<p>请注意其开销，通常只要开启 SecurityManager，就会导致 10% ~ 15% 的性能下降，在 JDK 9 以后，这个开销有所改善。</p>
<p>理解了基础 Java 安全机制，接下来我们来一起探讨安全漏洞（<a href="https://en.wikipedia.org/wiki/Vulnerability_(computing)">Vulnerability</a>）。</p>
<p>按照传统的定义，任何可以用来<strong>绕过系统安全策略限制</strong>的程序瑕疵，都可以算作安全漏洞。具体原因可能非常多，设计或实现中的疏漏、配置错误等，任何不慎都有可能导致安全漏洞出现，例如恶意代码绕过了 Java 沙箱的限制，获取了特权等。如果你想了解更多安全漏洞的信息，可以从<a href="https://cve.mitre.org/">通用安全漏洞库</a>（CVE）等途径获取，了解安全漏洞<a href="https://www.first.org/cvss/calculator/3.0">评价</a>标准。</p>
<p>但是，要达到攻击的目的，未必都需要绕过权限限制。比如利用哈希碰撞发起拒绝服务攻击（DOS，Denial-Of-Service attack），常见的场景是，攻击者可以事先构造大量相同哈希值的数据，然后以 JSON 数据的形式发送给服务器端，服务器端在将其构建成为 Java 对象过程中，通常以 Hastable 或 HashMap 等形式存储，哈希碰撞将导致哈希表发生严重退化，算法复杂度可能上升一个数量级（HashMap 后续进行了改进，我在【专栏第 9 讲】介绍了树化机制），进而耗费大量 CPU 资源。</p>
<p>像这种攻击方式，无关于权限，可以看作是程序实现的瑕疵，给了攻击者以低成本进行进攻的机会。</p>
<p>我在开头提到的各种注入式攻击，可以有不同角度、不同层面的解决方法，例如针对 SQL 注入：</p>
<ul>
<li>在数据输入阶段，填补期望输入和可能输入之间的鸿沟。可以进行输入校验，限定什么类型的输入是合法的，例如，不允许输入标点符号等特殊字符，或者特定结构的输入。</li>
<li>在 Java 应用进行数据库访问时，如果不用完全动态的 SQL，而是利用 PreparedStatement，可以有效防范 SQL 注入。不管是 SQL 注入，还是 OS 命令注入，程序利用字符串拼接生成运行逻辑都是个可能的风险点！</li>
<li>在数据库层面，如果对查询、修改等权限进行了合理限制，就可以在一定程度上避免被注入删除等高破坏性的代码。</li>
</ul>
<p>在安全领域，有一句准则：安全倾向于 “明显没有漏洞”，而不是“没有明显漏洞”。所以，为了更加安全可靠的服务，我们最好是采取整体性的安全设计和综合性的防范手段，而不是头痛医头、脚痛医脚的修修补补，更不能心存侥幸。</p>
<p>一个比较普适的建议是，尽量使用较新版本的 JDK，并使用推荐的安全机制和标准。如果你有看过 JDK release notes，例如<a href="http://www.oracle.com/technetwork/java/javase/8u141-relnotes-3720385.html">8u141</a>，你会发现 JDK 更新会修复已知的安全漏洞，并且会对安全机制等进行增强。但现实情况是，相当一部分应用还在使用很古老的不安全版本 JDK 进行开发，并且很多信息处理的也很随意，或者通过明文传输、存储，这些都存在暴露安全隐患的可能。</p>
<p>今天我首先介绍了典型的注入攻击，然后整理了 Java 内部的安全机制，并探讨了到底什么是安全漏洞和典型的表现形式，以及如何防范 SQL 注入攻击等，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title>29 Java内存模型中的happen-before是什么？</title>
    <url>/2024/09/22/2024-09-22-29-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84happen-before%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="29-Java内存模型中的happen-before是什么？"><a href="#29-Java内存模型中的happen-before是什么？" class="headerlink" title="29 Java内存模型中的happen-before是什么？"></a>29 Java内存模型中的happen-before是什么？</h1><p>Java 语言在设计之初就引入了线程的概念，以充分利用现代处理器的计算能力，这既带来了强大、灵活的多线程机制，也带来了线程安全等令人混淆的问题，而 Java 内存模型（Java Memory Model，JMM）为我们提供了一个在纷乱之中达成一致的指导准则。</p>
<p>今天我要问你的问题是，<strong>Java 内存模型中的 happen-before 是什么？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>Happen-before 关系，是 Java 内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。</p>
<p>它的具体表现形式，包括但远不止是我们直觉中的 synchronized、volatile、lock 操作顺序等方面，例如：</p>
<ul>
<li>线程内执行的每个操作，都保证 happen-before 后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。</li>
<li>对于 volatile 变量，对它的写操作，保证 happen-before 在随后对该变量的读取操作。</li>
<li>对于一个锁的解锁操作，保证 happen-before 加锁操作。</li>
<li>对象构建完成，保证 happen-before 于 finalizer 的开始动作。</li>
<li>甚至是类似线程内部操作的完成，保证 happen-before 其他 Thread.join() 的线程等。</li>
</ul>
<p>这些 happen-before 关系是存在着传递性的，如果满足 a happen-before b 和 b happen-before c，那么 a happen-before c 也成立。</p>
<p>前面我一直用 happen-before，而不是简单说前后，是因为它不仅仅是对执行时间的保证，也包括对内存读、写操作顺序的保证。仅仅是时钟顺序上的先后，并不能保证线程交互的可见性。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是一个常见的考察 Java 内存模型基本概念的问题，我前面给出的回答尽量选择了和日常开发相关的规则。</p>
<p>JMM 是面试的热点，可以看作是深入理解 Java 并发编程、编译器和 JVM 内部机制的必要条件，但这同时也是个容易让初学者无所适从的主题。对于学习 JMM，我有一些个人建议：</p>
<ul>
<li>明确目的，克制住技术的诱惑。除非你是编译器或者 JVM 工程师，否则我建议不要一头扎进各种 CPU 体系结构，纠结于不同的缓存、流水线、执行单元等。这些东西虽然很酷，但其复杂性是超乎想象的，很可能会无谓增加学习难度，也未必有实践价值。</li>
<li>克制住对“秘籍”的诱惑。有些时候，某些编程方式看起来能起到特定效果，但分不清是实现差异导致的“表现”，还是“规范”要求的行为，就不要依赖于这种“表现”去编程，尽量遵循语言规范进行，这样我们的应用行为才能更加可靠、可预计。</li>
</ul>
<p>在这一讲中，兼顾面试和编程实践，我会结合例子梳理下面两点：</p>
<ul>
<li>为什么需要 JMM，它试图解决什么问题？</li>
<li>JMM 是如何解决可见性等各种问题的？类似 volatile，体现在具体用例中有什么效果？</li>
</ul>
<p>注意，专栏中 Java 内存模型就是特指 JSR-133 中重新定义的 JMM 规范。在特定的上下文里，也许会与 JVM（Java）内存结构等混淆，并不存在绝对的对错，但一定要清楚面试官的本意，有的面试官也会特意考察是否清楚这两种概念的区别。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>为什么需要 JMM，它试图解决什么问题？</p>
<p>Java 是最早尝试提供内存模型的语言，这是简化多线程编程、保证程序可移植性的一个飞跃。早期类似 C、C++ 等语言，并不存在内存模型的概念（C++ 11 中也引入了标准内存模型），其行为依赖于处理器本身的<a href="https://en.wikipedia.org/wiki/Memory_ordering">内存一致性模型</a>，但不同的处理器可能差异很大，所以一段 C++ 程序在处理器 A 上运行正常，并不能保证其在处理器 B 上也是一致的。</p>
<p>即使如此，最初的 Java 语言规范仍然是存在着缺陷的，当时的目标是，希望 Java 程序可以充分利用现代硬件的计算能力，同时保持“书写一次，到处执行”的能力。</p>
<p>但是，显然问题的复杂度被低估了，随着 Java 被运行在越来越多的平台上，人们发现，过于泛泛的内存模型定义，存在很多模棱两可之处，对 synchronized 或 volatile 等，类似指令重排序时的行为，并没有提供清晰规范。这里说的指令重排序，既可以是<a href="https://en.wikipedia.org/wiki/Instruction_scheduling">编译器优化行为</a>，也可能是源自于现代处理器的<a href="https://en.wikipedia.org/wiki/Out-of-order_execution">乱序执行</a>等。</p>
<p>换句话说：</p>
<ul>
<li>既不能保证一些多线程程序的正确性，例如最著名的就是双检锁（Double-Checked Locking，DCL）的失效问题，具体可以参考我在【第 14 讲】对单例模式的说明，双检锁可能导致未完整初始化的对象被访问，理论上这叫并发编程中的安全发布（Safe Publication）失败。</li>
<li>也不能保证同一段程序在不同的处理器架构上表现一致，例如有的处理器支持缓存一致性，有的不支持，各自都有自己的内存排序模型。</li>
</ul>
<p>所以，Java 迫切需要一个完善的 JMM，能够让普通 Java 开发者和编译器、JVM 工程师，能够<strong>清晰地</strong>达成共识。换句话说，可以相对简单并准确地判断出，多线程程序什么样的执行序列是符合规范的。</p>
<p>所以：</p>
<ul>
<li>对于编译器、JVM 开发者，关注点可能是如何使用类似<a href="https://en.wikipedia.org/wiki/Memory_barrier">内存屏障</a>（Memory-Barrier）之类技术，保证执行结果符合 JMM 的推断。</li>
<li>对于 Java 应用开发者，则可能更加关注 volatile、synchronized 等语义，如何利用类似 happen-before 的规则，写出可靠的多线程应用，而不是利用一些“秘籍”去糊弄编译器、JVM。</li>
</ul>
<p>我画了一个简单的角色层次图，不同工程师分工合作，其实所处的层面是有区别的。JMM 为 Java 工程师隔离了不同处理器内存排序的区别，这也是为什么我通常不建议过早深入处理器体系结构，某种意义上来说，这样本就违背了 JMM 的初衷。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/5d74ad650fa5d1cdf80df3b3062357e5-20221127202433-5fecxim.png" alt="img"></p>
<p><strong>JMM 是怎么解决可见性等问题的呢？</strong></p>
<p>在这里，我有必要简要介绍一下典型的问题场景。</p>
<p>我在【第 25 讲】里介绍了 JVM 内部的运行时数据区，但是真正程序执行，实际是要跑在具体的处理器内核上。你可以简单理解为，把本地变量等数据从内存加载到缓存、寄存器，然后运算结束写回主内存。你可以从下面示意图，看这两种模型的对应。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/ff8afc2561e8891bc74a0112905fed61-20221127202433-00hc9rs.png" alt="img"></p>
<p>看上去很美好，但是当多线程共享变量时，情况就复杂了。试想，如果处理器对某个共享变量进行了修改，可能只是体现在该内核的缓存里，这是个本地状态，而运行在其他内核上的线程，可能还是加载的旧状态，这很可能导致一致性的问题。从理论上来说，多线程共享引入了复杂的数据依赖性，不管编译器、处理器怎么做重排序，都必须尊重数据依赖性的要求，否则就打破了正确性！这就是 JMM 所要解决的问题。</p>
<p>JMM 内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现了各种 happen-before 规则。与此同时，更多复杂度在于，需要尽量确保各种编译器、各种体系结构的处理器，都能够提供一致的行为。</p>
<p>我以 volatile 为例，看看如何利用内存屏障实现 JMM 定义的可见性？</p>
<p>对于一个 volatile 变量：</p>
<ul>
<li>对该变量的写操作<strong>之后</strong>，编译器会插入一个<strong>写屏障</strong>。</li>
<li>对该变量的读操作<strong>之前</strong>，编译器会插入一个<strong>读屏障</strong>。</li>
</ul>
<p>内存屏障能够在类似变量读、写操作之后，保证其他线程对 volatile 变量的修改对当前线程可见，或者本地修改对其他线程提供可见性。换句话说，线程写入，写屏障会通过类似强迫刷出处理器缓存的方式，让其他线程能够拿到最新数值。</p>
<p>如果你对更多内存屏障的细节感兴趣，或者想了解不同体系结构的处理器模型，建议参考 JSR-133<a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">相关文档</a>，我个人认为这些都是和特定硬件相关的，内存屏障之类只是实现 JMM 规范的技术手段，并不是规范的要求。</p>
<p><strong>从应用开发者的角度，JMM 提供的可见性，体现在类似 volatile 上，具体行为是什么样呢？</strong></p>
<p>我这里循序渐进的举两个例子。</p>
<p>首先，前几天有同学问我一个问题，请看下面的代码片段，希望达到的效果是，当 condition 被赋值为 false 时，线程 A 能够从循环中退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread A</span></span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread B</span></span><br><span class="line">condition = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>这里就需要 condition 被定义为 volatile 变量，不然其数值变化，往往并不能被线程 A 感知，进而无法退出。当然，也可以在 while 中，添加能够直接或间接起到类似效果的代码。</p>
<p>第二，我想举 Brian Goetz 提供的一个经典用例，使用 volatile 作为守卫对象，实现某种程度上轻量级的同步，请看代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="type">char</span>[] configText;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Thread A</span></span><br><span class="line">configOptions = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Thread B</span></span><br><span class="line"><span class="keyword">while</span> (!initialized)</span><br><span class="line">  sleep();</span><br><span class="line"><span class="comment">// use configOptions</span></span><br></pre></td></tr></table></figure>

<p>JSR-133 重新定义的 JMM 模型，能够保证线程 B 获取的 configOptions 是更新后的数值。</p>
<p>也就是说 volatile 变量的可见性发生了增强，能够起到守护其上下文的作用。线程 A 对 volatile 变量的赋值，会强制将该变量自己和当时其他变量的状态都刷出缓存，为线程 B 提供可见性。当然，这也是以一定的性能开销作为代价的，但毕竟带来了更加简单的多线程行为。</p>
<p>我们经常会说 volatile 比 synchronized 之类更加轻量，但轻量也仅仅是相对的，volatile 的读、写仍然要比普通的读写要开销更大，所以如果你是在性能高度敏感的场景，除非你确定需要它的语义，不然慎用。</p>
<p>今天，我从 happen-before 关系开始，帮你理解了什么是 Java 内存模型。为了更方便理解，我作了简化，从不同工程师的角色划分等角度，阐述了问题的由来，以及 JMM 是如何通过类似内存屏障等技术实现的。最后，我以 volatile 为例，分析了可见性在多线程场景中的典型用例。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存模型</tag>
        <tag>happen-before</tag>
      </tags>
  </entry>
  <entry>
    <title>30 Java程序运行在Docker等容器环境有哪些新问题？</title>
    <url>/2024/09/22/2024-09-22-30-Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9C%A8Docker%E7%AD%89%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="30-Java程序运行在Docker等容器环境有哪些新问题？"><a href="#30-Java程序运行在Docker等容器环境有哪些新问题？" class="headerlink" title="30 Java程序运行在Docker等容器环境有哪些新问题？"></a>30 Java程序运行在Docker等容器环境有哪些新问题？</h1><p>如今，Docker 等容器早已不是新生事物，正在逐步成为日常开发、部署环境的一部分。Java 能否无缝地运行在容器环境，是否符合微服务、Serverless 等新的软件架构和场景，在一定程度上也会影响未来的技术栈选择。当然，Java 对 Docker 等容器环境的支持也在不断增强，自然地，Java 在容器场景的实践也逐渐在面试中被涉及。我希望通过专栏今天这一讲，能够帮你能做到胸有成竹。</p>
<p>今天我要问你的问题是，<strong>Java 程序运行在 Docker 等容器环境有哪些新问题？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>对于 Java 来说，Docker 毕竟是一个较新的环境，例如，其内存、CPU 等资源限制是通过 CGroup（Control Group）实现的，早期的 JDK 版本（8u131 之前）并不能识别这些限制，进而会导致一些基础问题：</p>
<ul>
<li>如果未配置合适的 JVM 堆和元数据区、直接内存等参数，Java 就有可能试图使用超过容器限制的内存，最终被容器 OOM kill，或者自身发生 OOM。</li>
<li>错误判断了可获取的 CPU 资源，例如，Docker 限制了 CPU 的核数，JVM 就可能设置不合适的 GC 并行线程数等。</li>
</ul>
<p>从应用打包、发布等角度出发，JDK 自身就比较大，生成的镜像就更为臃肿，当我们的镜像非常多的时候，镜像的存储等开销就比较明显了。</p>
<p>如果考虑到微服务、Serverless 等新的架构和场景，Java 自身的大小、内存占用、启动速度，都存在一定局限性，因为 Java 早期的优化大多是针对长时间运行的大型服务器端应用。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是个针对特定场景和知识点的问题，我给出的回答简单总结了目前业界实践中发现的一些问题。</p>
<p>如果我是面试官，针对这种问题，如果你确实没有太多 Java 在 Docker 环境的使用经验，直接说不知道，也算是可以接受的，毕竟没有人能够掌握所有知识点嘛。</p>
<p>但我们要清楚，有经验的面试官，一般不会以纯粹偏僻的知识点作为面试考察的目的，更多是考察思考问题的思路和解决问题的方法。所以，如果有基础的话，可以从操作系统、容器原理、JVM 内部机制、软件开发实践等角度，展示系统性分析新问题、新场景的能力。毕竟，变化才是世界永远的主题，能够在新变化中找出共性与关键，是优秀工程师的必备能力。</p>
<p>今天我会围绕下面几个方面展开：</p>
<ul>
<li>面试官可能会进一步问到，有没有想过为什么类似 Docker 这种容器环境，会有点“欺负”Java？从 JVM 内部机制来说，问题出现在哪里？</li>
<li>我注意到有种论调说“没人在容器环境用 Java”，不去争论这个观点正确与否，我会从工程实践出发，梳理问题原因和相关解决方案，并探讨下新场景下的最佳实践。</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们先来搞清楚 Java 在容器环境的局限性来源，<strong>Docker 到底有什么特别</strong>？</p>
<p>虽然看起来 Docker 之类容器和虚拟机非常相似，例如，它也有自己的 shell，能独立安装软件包，运行时与其他容器互不干扰。但是，如果深入分析你会发现，Docker 并不是一种完全的<strong>虚拟化</strong>技术，而更是一种轻量级的<strong>隔离</strong>技术。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/a069a294d32d7778f3410192221358fb-20221127203320-fe0xuv1.png" alt="img"></p>
<p>上面的示意图，展示了 Docker 与虚拟机的区别。从技术角度，基于 namespace，Docker 为每个容器提供了单独的命名空间，对网络、PID、用户、IPC 通信、文件系统挂载点等实现了隔离。对于 CPU、内存、磁盘 IO 等计算资源，则是通过 CGroup 进行管理。如果你想了解更多 Docker 的细节，请参考相关<a href="https://medium.freecodecamp.org/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b">技术文档</a>。</p>
<p>Docker 仅在类似 Linux 内核之上实现了有限的隔离和虚拟化，并不是像传统虚拟化软件那样，独立运行一个新的操作系统。如果是虚拟化的操作系统，不管是 Java 还是其他程序，只要调用的是同一个系统 API，都可以透明地获取所需的信息，基本不需要额外的兼容性改变。</p>
<p>容器虽然省略了虚拟操作系统的开销，实现了轻量级的目标，但也带来了额外复杂性，它限制对于应用不是透明的，需要用户理解 Docker 的新行为。所以，有专家曾经说过，“幸运的是 Docker 没有完全隐藏底层信息，但是不幸的也是 Docker 没有隐藏底层信息！”</p>
<p>对于 Java 平台来说，这些未隐藏的底层信息带来了很多意外的困难，主要体现在几个方面：</p>
<p>第一，容器环境对于计算资源的管理方式是全新的，CGroup 作为相对比较新的技术，历史版本的 Java 显然并不能自然地理解相应的资源限制。</p>
<p>第二，namespace 对于容器内的应用细节增加了一些微妙的差异，比如 jcmd、jstack 等工具会依赖于“&#x2F;proc&#x2F;&#x2F;”下面提供的部分信息，但是 Docker 的设计改变了这部分信息的原有结构，我们需要对原有工具进行<a href="https://bugs.openjdk.java.net/browse/JDK-8179498">修改</a>以适应这种变化。</p>
<p><strong>从 JVM 运行机制的角度，为什么这些“沟通障碍”会导致 OOM 等问题呢？</strong></p>
<p>你可以思考一下，这个问题实际是反映了 JVM 如何根据系统资源（内存、CPU 等）情况，在启动时设置默认参数。</p>
<p>这就是所谓的<a href="https://docs.oracle.com/javase/10/gctuning/ergonomics.htm#JSGCT-GUID-DB4CAE94-2041-4A16-90EC-6AE3D91EC1F1">Ergonomics</a>机制，例如：</p>
<ul>
<li>JVM 会大概根据检测到的内存大小，设置最初启动时的堆大小为系统内存的 1&#x2F;64；并将堆最大值，设置为系统内存的 1&#x2F;4。</li>
<li>而 JVM 检测到系统的 CPU 核数，则直接影响到了 Parallel GC 的并行线程数目和 JIT complier 线程数目，甚至是我们应用中 ForkJoinPool 等机制的并行等级。</li>
</ul>
<p>这些默认参数，是根据通用场景选择的初始值。但是由于容器环境的差异，Java 的判断很可能是基于错误信息而做出的。这就类似，我以为我住的是整栋别墅，实际上却只有一个房间是给我住的。</p>
<p>更加严重的是，JVM 的一些原有诊断或备用机制也会受到影响。为保证服务的可用性，一种常见的选择是依赖“-XX:OnOutOfMemoryError”功能，通过调用处理脚本的形式来做一些补救措施，比如自动重启服务等。但是，这种机制是基于 fork 实现的，当 Java 进程已经过度提交内存时，fork 新的进程往往已经不可能正常运行了。</p>
<p>根据前面的总结，似乎问题非常棘手，那我们在实践中，<strong>如何解决这些问题呢？</strong></p>
<p>首先，如果你能够<strong>升级到最新的 JDK 版本</strong>，这个问题就迎刃而解了。</p>
<ul>
<li>针对这种情况，JDK 9 中引入了一些实验性的参数，以方便 Docker 和 Java“沟通”，例如针对内存限制，可以使用下面的参数设置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions</span><br><span class="line">-XX:+UseCGroupMemoryLimitForHeap</span><br></pre></td></tr></table></figure>

<p>注意，这两个参数是顺序敏感的，并且只支持 Linux 环境。而对于 CPU 核心数限定，Java 已经被修正为可以正确理解“–cpuset-cpus”等设置，无需单独设置参数。</p>
<ul>
<li>如果你可以切换到 JDK 10 或者更新的版本，问题就更加简单了。Java 对容器（Docker）的支持已经比较完善，默认就会自适应各种资源限制和实现差异。前面提到的实验性参数“UseCGroupMemoryLimitForHeap”已经被标记为废弃。</li>
</ul>
<p>与此同时，新增了参数用以明确指定 CPU 核心的数目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:ActiveProcessorCount=N</span><br></pre></td></tr></table></figure>

<p>如果实践中发现有问题，也可以使用“-XX:-UseContainerSupport”，关闭 Java 的容器支持特性，这可以作为一种防御性机制，避免新特性破坏原有基础功能。当然，也欢迎你向 OpenJDK 社区反馈问题。</p>
<ul>
<li>幸运的是，JDK 9 中的实验性改进已经被移植到 Oracle JDK 8u131 之中，你可以直接下载相应<a href="https://store.docker.com/images/oracle-serverjre-8">镜像</a>，并配置“UseCGroupMemoryLimitForHeap”，后续很有可能还会进一步将 JDK 10 中相关的增强，应用到 JDK 8 最新的更新中。</li>
</ul>
<p>但是，如果我暂时只能使用老版本的 JDK 怎么办？</p>
<p>我这里有几个建议：</p>
<ul>
<li>明确设置堆、元数据区等内存区域大小，保证 Java 进程的总大小可控。</li>
</ul>
<p>例如，我们可能在环境中，这样限制容器内存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --name yourcontainer -p <span class="number">8080</span>:<span class="number">8080</span> -m 800M repo/your-java-container:openjdk</span><br></pre></td></tr></table></figure>

<p>那么，就可以额外配置下面的环境变量，直接指定 JVM 堆大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-e JAVA_OPTIONS=<span class="string">&#x27;-Xmx300m&#x27;</span></span><br></pre></td></tr></table></figure>

<p>明确配置 GC 和 JIT 并行线程数目，以避免二者占用过多计算资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:ParallelGCThreads</span><br><span class="line">-XX:CICompilerCount</span><br></pre></td></tr></table></figure>

<p>除了我前面介绍的 OOM 等问题，在很多场景中还发现 Java 在 Docker 环境中，似乎会意外使用 Swap。具体原因待查，但很有可能也是因为 Ergonomics 机制失效导致的，我建议配置下面参数，明确告知 JVM 系统内存限额。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MaxRAM=`cat /sys/fs/cgroup/memory/memory.limit_in_bytes`</span><br></pre></td></tr></table></figure>

<p>也可以指定 Docker 运行参数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--memory-swappiness=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这是受操作系统<a href="https://en.wikipedia.org/wiki/Swappiness">Swappiness</a>机制影响，当内存消耗达到一定门限，操作系统会试图将不活跃的进程换出（Swap out），上面的参数有显式关闭 Swap 的作用。所以可以看到，Java 在 Docker 中的使用，从操作系统、内核到 JVM 自身机制，需要综合运用我们所掌握的知识。</p>
<p>回顾我在专栏第 25 讲 JVM 内存区域的介绍，JVM 内存消耗远不止包括堆，很多时候仅仅设置 Xmx 是不够的，MaxRAM 也有助于 JVM 合理分配其他内存区域。如果应用需要设置更多 Java 启动参数，但又不确定什么数值合理，可以试试一些社区提供的<a href="https://github.com/cloudfoundry/java-buildpack-memory-calculator">工具</a>，但要注意通用工具的局限性。</p>
<p>更进一步来说，对于容器镜像大小的问题，如果你使用的是 JDK 9 以后的版本，完全可以使用 jlink 工具定制最小依赖的 Java 运行环境，将 JDK 裁剪为几十 M 的大小，这样运行起来并不困难。</p>
<p>今天我从 Docker 环境中 Java 可能出现的问题开始，分析了为什么容器环境对应用并不透明，以及这种偏差干扰了 JVM 的相关机制。最后，我从实践出发，介绍了主要问题的解决思路，希望对你在实际开发时有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>28 谈谈你的GC调优思路</title>
    <url>/2024/09/22/2024-09-22-28-%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84GC%E8%B0%83%E4%BC%98%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="28-谈谈你的GC调优思路"><a href="#28-谈谈你的GC调优思路" class="headerlink" title="28 谈谈你的GC调优思路"></a>28 谈谈你的GC调优思路</h1><p>我发现，目前不少外部资料对 G1 的介绍大多还停留在 JDK 7 或更早期的实现，很多结论已经存在较大偏差，甚至一些过去的 GC 选项已经不再推荐使用。所以，今天我会选取新版 JDK 中的默认 G1 GC 作为重点进行详解，并且我会从调优实践的角度，分析典型场景和调优思路。下面我们一起来更新下这方面的知识。</p>
<p>今天我要问你的问题是，<strong>谈谈你的 GC 调优思路？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>谈到调优，这一定是针对特定场景、特定目的的事情， 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput），大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他 GC 相关的场景，例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。</p>
<p>基本的调优思路可以总结为：</p>
<ul>
<li>理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。</li>
<li>掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。</li>
<li>这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。</li>
<li>通过分析确定具体调整的参数或者软硬件配置。</li>
<li>验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。</li>
</ul>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天考察的 GC 调优问题是 JVM 调优的一个基础方面，很多 JVM 调优需求，最终都会落实在 GC 调优上或者与其相关，我提供的是一个常见的思路。</p>
<p>真正快速定位和解决具体问题，还是需要对 JVM 和 GC 知识的掌握，以及实际调优经验的总结，有的时候甚至是源自经验积累的直觉判断。面试官可能会继续问项目中遇到的真实问题，如果你能清楚、简要地介绍其上下文，然后将诊断思路和调优实践过程表述出来，会是个很好的加分项。</p>
<p>专栏虽然无法提供具体的项目经验，但是可以帮助你掌握常见的调优思路和手段，这不管是面试还是在实际工作中都是很有帮助的。另外，我会还会从下面不同角度进行补充：</p>
<ul>
<li>【上一讲】中我已经谈到，涉及具体的 GC 类型，JVM 的实际表现要更加复杂。目前，G1 已经成为新版 JDK 的默认选择，所以值得你去深入理解。</li>
<li>因为 G1 GC 一直处在快速发展之中，我会侧重它的演进变化，尤其是行为和配置相关的变化。并且，同样是因为 JVM 的快速发展，即使是收集 GC 日志等方面也发生了较大改进，这也是为什么我在上一讲留给你的思考题是有关日志相关选项，看完讲解相信你会很惊讶。</li>
<li>从 GC 调优实践的角度，理解通用问题的调优思路和手段。</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，先来整体了解一下 G1 GC 的内部结构和主要机制。</p>
<p>从内存区域的角度，G1 同样存在着年代的概念，但是与我前面介绍的内存结构很不一样，其内部是类似棋盘状的一个个 region 组成，请参考下面的示意图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/a662fda0de8af087c37c40a86a9cf3f1-20221127201847-5jy7hef.png" alt="img"></p>
<p>region 的大小是一致的，数值是在 1M 到 32M 字节之间的一个 2 的幂值数，JVM 会尽量划分 2048 个左右、同等大小的 region，这点可以从源码<a href="http://hg.openjdk.java.net/jdk/jdk/file/fa2f93f99dbc/src/hotspot/share/gc/g1/heapRegionBounds.hpp">heapRegionBounds.hpp</a>中看到。当然这个数字既可以手动调整，G1 也会根据堆大小自动进行调整。</p>
<p>在 G1 实现中，年代是个逻辑概念，具体体现在，一部分 region 是作为 Eden，一部分作为 Survivor，除了意料之中的 Old region，G1 会将超过 region 50% 大小的对象（在应用中，通常是 byte 或 char 数组）归类为 Humongous 对象，并放置在相应的 region 中。逻辑上，Humongous region 算是老年代的一部分，因为复制这样的大对象是很昂贵的操作，并不适合新生代 GC 的复制算法。</p>
<p>你可以思考下 region 设计有什么副作用？</p>
<p>例如，region 大小和大对象很难保证一致，这会导致空间的浪费。不知道你有没有注意到，我的示意图中有的区域是 Humongous 颜色，但没有用名称标记，这是为了表示，特别大的对象是可能占用超过一个 region 的。并且，region 太小不合适，会令你在分配大对象时更难找到连续空间，这是一个长久存在的情况，请参考<a href="http://mail.openjdk.java.net/pipermail/hotspot-gc-use/2017-November/002726.html">OpenJDK 社区的讨论</a>。这本质也可以看作是 JVM 的 bug，尽管解决办法也非常简单，直接设置较大的 region 大小，参数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:G1HeapRegionSize=&lt;N, 例如<span class="number">16</span>&gt;M</span><br></pre></td></tr></table></figure>

<p>从 GC 算法的角度，G1 选择的是复合算法，可以简化理解为：</p>
<ul>
<li>在新生代，G1 采用的仍然是并行的复制算法，所以同样会发生 Stop-The-World 的暂停。</li>
<li>在老年代，大部分情况下都是并发标记，而整理（Compact）则是和新生代 GC 时捎带进行，并且不是整体性的整理，而是增量进行的。</li>
</ul>
<p>我在【上一讲】曾经介绍过，习惯上人们喜欢把新生代 GC（Young GC）叫作 Minor GC，老年代 GC 叫作 Major GC，区别于整体性的 Full GC。但是现代 GC 中，这种概念已经不再准确，对于 G1 来说：</p>
<ul>
<li>Minor GC 仍然存在，虽然具体过程会有区别，会涉及 Remembered Set 等相关处理。</li>
<li>老年代回收，则是依靠 Mixed GC。并发标记结束后，JVM 就有足够的信息进行垃圾收集，Mixed GC 不仅同时会清理 Eden、Survivor 区域，而且还会清理部分 Old 区域。可以通过设置下面的参数，指定触发阈值，并且设定最多被包含在一次 Mixed GC 中的 region 比例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">–XX:G1MixedGCLiveThresholdPercent</span><br><span class="line">–XX:G1OldCSetRegionThresholdPercent</span><br></pre></td></tr></table></figure>

<p>从 G1 内部运行的角度，下面的示意图描述了 G1 正常运行时的状态流转变化，当然，在发生逃逸失败等情况下，就会触发 Full GC。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/47dddbd91ad0e0adbd164632eb9facec-20221127201847-p5gmfe2.png" alt="img"></p>
<p>G1 相关概念非常多，有一个重点就是 Remembered Set，用于记录和维护 region 之间对象的引用关系。为什么需要这么做呢？试想，新生代 GC 是复制算法，也就是说，类似对象从 Eden 或者 Survivor 到 to 区域的“移动”，其实是“复制”，本质上是一个新的对象。在这个过程中，需要必须保证老年代到新生代的跨区引用仍然有效。下面的示意图说明了相关设计。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/eb50bb2b270478bc6f525aa615d4a3d3-20221127201847-xdo0zp2.png" alt="img"></p>
<p>G1 的很多开销都是源自 Remembered Set，例如，它通常约占用 Heap 大小的 20% 或更高，这可是非常可观的比例。并且，我们进行对象复制的时候，因为需要扫描和更改 Card Table 的信息，这个速度影响了复制的速度，进而影响暂停时间。</p>
<p>描述 G1 内部的资料很多，我就不重复了，如果你想了解更多内部结构和算法等，我建议参考一些具体的<a href="https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All">介绍</a>，书籍方面我推荐 Charlie Hunt 等撰写的《Java Performance Companion》。</p>
<p>接下来，我介绍下大家可能还不了解的 G1 行为变化，它们在一定程度上解决了专栏其他讲中提到的部分困扰，如类型卸载不及时的问题。</p>
<ul>
<li>上面提到了 Humongous 对象的分配和回收，这是很多内存问题的来源，Humongous region 作为老年代的一部分，通常认为它会在并发标记结束后才进行回收，但是在新版 G1 中，Humongous 对象回收采取了更加激进的策略。</li>
<li>我们知道 G1 记录了老年代 region 间对象引用，Humongous 对象数量有限，所以能够快速的知道是否有老年代对象引用它。如果没有，能够阻止它被回收的唯一可能，就是新生代是否有对象引用了它，但这个信息是可以在 Young GC 时就知道的，所以完全可以在 Young GC 中就进行 Humongous 对象的回收，不用像其他老年代对象那样，等待并发标记结束。</li>
<li>我在【专栏第 5 讲】，提到了在 8u20 以后字符串排重的特性，在垃圾收集过程中，G1 会把新创建的字符串对象放入队列中，然后在 Young GC 之后，并发地（不会 STW）将内部数据（char 数组，JDK 9 以后是 byte 数组）一致的字符串进行排重，也就是将其引用同一个数组。你可以使用下面参数激活：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UseStringDeduplication</span><br></pre></td></tr></table></figure>

<p>注意，这种排重虽然可以节省不少内存空间，但这种并发操作会占用一些 CPU 资源，也会导致 Young GC 稍微变慢。</p>
<p>类型卸载是个长期困扰一些 Java 应用的问题，在【专栏第 25 讲】中，我介绍了一个类只有当加载它的自定义类加载器被回收后，才能被卸载。元数据区替换了永久代之后有所改善，但还是可能出现问题。</p>
<p>G1 的类型卸载有什么改进吗？很多资料中都谈到，G1 只有在发生 Full GC 时才进行类型卸载，但这显然不是我们想要的。你可以加上下面的参数查看类型卸载：</p>
<p>幸好现代的 G1 已经不是如此了，8u40 以后，G1 增加并默认开启下面的选项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+TraceClassUnloading</span><br></pre></td></tr></table></figure>

<p>也就是说，在并发标记阶段结束后，JVM 即进行类型卸载。</p>
<ul>
<li>我们知道老年代对象回收，基本要等待并发标记结束。这意味着，如果并发标记结束不及时，导致堆已满，但老年代空间还没完成回收，就会触发 Full GC，所以触发并发标记的时机很重要。早期的 G1 调优中，通常会设置下面参数，但是很难给出一个普适的数值，往往要根据实际运行结果调整</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent</span><br></pre></td></tr></table></figure>

<p>在 JDK 9 之后的 G1 实现中，这种调整需求会少很多，因为 JVM 只会将该参数作为初始值，会在运行时进行采样，获取统计数据，然后据此动态调整并发标记启动时机。对应的 JVM 参数如下，默认已经开启：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+G1UseAdaptiveIHOP</span><br></pre></td></tr></table></figure>

<ul>
<li>在现有的资料中，大多指出 G1 的 Full GC 是最差劲的单线程串行 GC。其实，如果采用的是最新的 JDK，你会发现 Full GC 也是并行进行的了，在通用场景中的表现还优于 Parallel GC 的 Full GC 实现。</li>
</ul>
<p>当然，还有很多其他的改变，比如更快的 Card Table 扫描等，这里不再展开介绍，因为它们并不带来行为的变化，基本不影响调优选择。</p>
<p>前面介绍了 G1 的内部机制，并且穿插了部分调优建议，下面从整体上给出一些调优的建议。</p>
<p>首先，<strong>建议尽量升级到较新的 JDK 版本</strong>，从上面介绍的改进就可以看到，很多人们常常讨论的问题，其实升级 JDK 就可以解决了。</p>
<p>第二，掌握 GC 调优信息收集途径。掌握尽量全面、详细、准确的信息，是各种调优的基础，不仅仅是 GC 调优。我们来看看打开 GC 日志，这似乎是很简单的事情，可是你确定真的掌握了吗？</p>
<p>除了常用的两个选项，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br></pre></td></tr></table></figure>

<p>还有一些非常有用的日志选项，很多特定问题的诊断都是要依赖这些选项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintAdaptiveSizePolicy <span class="comment">// 打印G1 Ergonomics相关信息</span></span><br></pre></td></tr></table></figure>

<p>我们知道 GC 内部一些行为是适应性的触发的，利用 PrintAdaptiveSizePolicy，我们就可以知道为什么 JVM 做出了一些可能我们不希望发生的动作。例如，G1 调优的一个基本建议就是避免进行大量的 Humongous 对象分配，如果 Ergonomics 信息说明发生了这一点，那么就可以考虑要么增大堆的大小，要么直接将 region 大小提高。</p>
<p>如果是怀疑出现引用清理不及时的情况，则可以打开下面选项，掌握到底是哪里出现了堆积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintReferenceGC</span><br></pre></td></tr></table></figure>

<p>另外，建议开启选项下面的选项进行并行引用处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintReferenceGC</span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，JDK 9 中 JVM 和 GC 日志机构进行了重构，其实我前面提到的 <strong>PrintGCDetails 已经被标记为废弃</strong>，而 <strong>PrintGCDateStamps 已经被移除</strong>，指定它会导致 JVM 无法启动。可以使用下面的命令查询新的配置参数。</p>
<p>最后，来看一些通用实践，理解了我前面介绍的内部结构和机制，很多结论就一目了然了，例如：</p>
<ul>
<li>如果发现 Young GC 非常耗时，这很可能就是因为新生代太大了，我们可以考虑减小新生代的最小比例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:G1NewSizePercent</span><br></pre></td></tr></table></figure>

<p>降低其最大值同样对降低 Young GC 延迟有帮助。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:G1MaxNewSizePercent</span><br></pre></td></tr></table></figure>

<p>如果我们直接为 G1 设置较小的延迟目标值，也会起到减小新生代的效果，虽然会影响吞吐量。</p>
<ul>
<li>如果是 Mixed GC 延迟较长，我们应该怎么做呢？</li>
</ul>
<p>还记得前面说的，部分 Old region 会被包含进 Mixed GC，减少一次处理的 region 个数，就是个直接的选择之一。</p>
<p>我在上面已经介绍了 G1OldCSetRegionThresholdPercent 控制其最大值，还可以利用下面参数提高 Mixed GC 的个数，当前默认值是 8，Mixed GC 数量增多，意味着每次被包含的 region 减少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:G1MixedGCCountTarget</span><br></pre></td></tr></table></figure>

<p>今天的内容算是抛砖引玉，更多内容你可以参考<a href="https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector-tuning.htm#JSGCT-GUID-4914A8D4-DE41-4250-B68E-816B58D4E278">G1 调优指南</a>等，远不是几句话可以囊括的。需要注意的是，也要避免过度调优，G1 对大堆非常友好，其运行机制也需要浪费一定的空间，有时候稍微多给堆一些空间，比进行苛刻的调优更加实用。</p>
<p>今天我梳理了基本的 GC 调优思路，并对 G1 内部结构以及最新的行为变化进行了详解。总的来说，G1 的调优相对简单、直观，因为可以直接设定暂停时间等目标，并且其内部引入了各种智能的自适应机制，希望这一切的努力，能够让你在日常应用开发时更加高效。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GC</tag>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>27 Java常见的垃圾收集器有哪些？</title>
    <url>/2024/09/22/2024-09-22-27-Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="27-Java常见的垃圾收集器有哪些？"><a href="#27-Java常见的垃圾收集器有哪些？" class="headerlink" title="27 Java常见的垃圾收集器有哪些？"></a>27 Java常见的垃圾收集器有哪些？</h1><p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展， Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
<p>今天我要问你的问题是，<strong>Java 常见的垃圾收集器有哪些？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>实际上，垃圾收集器（GC，Garbage Collector）是和具体 JVM 实现紧密相关的，不同厂商（IBM、Oracle），不同版本的 JVM，提供的选择也不同。接下来，我来谈谈最主流的 Oracle JDK。</p>
<ul>
<li>Serial GC，它是最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。</li>
</ul>
<p>从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了标记 - 整理（Mark-Compact）算法，区别于新生代的复制算法。</p>
<p>Serial GC 的对应 JVM 参数是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>

<ul>
<li>ParNew GC，很明显是个新生代 GC 实现，它实际是 Serial GC 的多线程版本，最常见的应用场景是配合老年代的 CMS GC 工作，下面是对应参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br></pre></td></tr></table></figure>

<ul>
<li>CMS（Concurrent Mark Sweep） GC，基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。</li>
<li>Parallel GC，在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是并行进行的，在常见的服务器环境中更加高效。</li>
</ul>
<p>开启选项是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure>

<p>另外，Parallel GC 引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标，JVM 会自动进行适应性调整，例如下面参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=value</span><br><span class="line">-XX:GCTimeRatio=N <span class="comment">// GC时间和用户时间比例 = 1 / (N+1)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>G1 GC 这是一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<p>G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</p>
<p>G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时 CMS 已经在 JDK 9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是考察你对 GC 的了解，GC 是 Java 程序员的面试常见题目，但是并不是每个人都有机会或者必要对 JVM、GC 进行深入了解，我前面的总结是为不熟悉这部分内容的同学提供一个整体的印象。</p>
<p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。在今天的讲解中，我侧重介绍比较通用、基础性的部分：</p>
<ul>
<li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li>
<li>垃圾收集器工作的基本流程。</li>
</ul>
<p>另外，Java 一直处于非常迅速的发展之中，在最新的 JDK 实现中，还有多种新的 GC，我会在最后补充，除了前面提到的垃圾收集器，看看还有哪些值得关注的选择。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><strong>垃圾收集的原理和基础概念</strong></p>
<p>第一，自动垃圾收集的前提是清楚哪些内存可以被释放。这一点可以结合我前面对 Java 类加载和内存结构的分析，来思考一下。</p>
<p>主要就是两个方面，最主要部分就是对象实例，都是存储在堆上的；还有就是方法区中的元数据等信息，例如类型不再使用，卸载该 Java 类似乎是很合理的。</p>
<p>对于对象实例收集，主要是两种基本算法，<a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">引用计数</a>和可达性分析。</p>
<ul>
<li>引用计数算法，顾名思义，就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为 0，即表示对象可回收。这是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li>
</ul>
<p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p>
<ul>
<li>另外就是 Java 选择的可达性分析，Java 的各种引用关系，在某种程度上，将可达性问题还进一步复杂化，具体请参考【专栏第 4 讲】，这种类型的垃圾收集通常叫作追踪性垃圾收集（<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">Tracing Garbage Collection</a>）。其原理简单来说，就是将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和 GC Roots 之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。JVM 会把虚拟机栈和本地方法栈中正在引用的对象、静态属性引用的对象和常量，作为 GC Roots。</li>
</ul>
<p>方法区无用元数据的回收比较复杂，我简单梳理一下。还记得我对类加载器的分类吧，一般来说初始化类加载器加载的类型是不会进行类卸载（unload）的；而普通的类型的卸载，往往是要求相应自定义类加载器本身被回收，所以大量使用动态类型的场合，需要防止元数据区（或者早期的永久代）不会 OOM。在 8u40 以后的 JDK 中，下面参数已经是默认的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+ClassUnloadingWithConcurrentMark</span><br></pre></td></tr></table></figure>

<p>第二，常见的垃圾收集算法，我认为总体上有个了解，理解相应的原理和优缺点，就已经足够了，其主要分为三类：</p>
<ul>
<li>复制（Copying）算法，我前面讲到的新生代 GC，基本都是基于复制算法，过程就如[专栏上一讲](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java">https://learn.lianglianglee.com/专栏/Java</a> 核心技术面试精讲&#x2F;27  Java常见的垃圾收集器有哪些？-极客时间.md)所介绍的，将活着的对象复制到 to 区域，拷贝过程中将对象顺序放置，就可以避免内存碎片化。</li>
</ul>
<p>这么做的代价是，既然要进行复制，既要提前预留内存空间，有一定的浪费；另外，对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，这个开销也不小，不管是内存占用或者时间开销。</p>
<ul>
<li>标记 - 清除（Mark-Sweep）算法，首先进行标记工作，标识出所有要回收的对象，然后进行清除。这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现 Full GC，暂停时间可能根本无法接受。</li>
<li>标记 - 整理（Mark-Compact），类似于标记 - 清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间。</li>
</ul>
<p>注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>
<p>如果对这方面的算法有兴趣，可以参考一本比较有意思的书《垃圾回收的算法与实现》，虽然其内容并不是围绕 Java 垃圾收集，但是对通用算法讲解比较形象。</p>
<p><strong>垃圾收集过程的理解</strong></p>
<p>我在【专栏上一讲】对堆结构进行了比较详细的划分，在垃圾收集的过程，对应到 Eden、Survivor、Tenured 等区域会发生什么变化呢？</p>
<p>这实际上取决于具体的 GC 方式，先来熟悉一下通常的垃圾收集流程，我画了一系列示意图，希望能有助于你理解清楚这个过程。</p>
<p>第一，Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间占用达到一定阈值时，触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。注意，我给存活对象标记了“数字 1”，这是为了表明对象的存活时间。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/44d4a92e8e20f46e6646eae53442256d-20221127201245-g6za8ir.png" alt="img"></p>
<p>第二， 经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件，这时候，另外一个 Survivor 区域则会成为 to 区域，Eden 区域的存活对象和 From 区域对象，都会被复制到 to 区域，并且存活的年龄计数会被加 1。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/3be4ac4834e2790a8211252f2bebfd48-20221127201245-d8cwioy.png" alt="img"></p>
<p>第三， 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定：</p>
<p>-XX:MaxTenuringThreshold&#x3D;<strong>&lt;**N**&gt;</strong></p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/dbcb15c99b368773145b358734e10e8d-20221127201245-bw0m0v6.png" alt="img"></p>
<p>后面就是老年代 GC，具体取决于选择的 GC 选项，对应不同的算法。下面是一个简单标记 - 整理算法过程示意图，老年代中的无用对象被清除后， GC 会将对象进行整理，以防止内存碎片化。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/399a0c23d1d57e08a2603fb76f328e25-20221127201245-xc44grb.png" alt="img"></p>
<p>通常我们把老年代 GC 叫作 Major GC，将对整个堆进行的清理叫作 Full GC，但是这个也没有那么绝对，因为不同的老年代 GC 算法其实表现差异很大，例如 CMS，“concurrent”就体现在清理工作是与工作线程一起并发运行的。</p>
<p><strong>GC 的新发展</strong></p>
<p>GC 仍然处于飞速发展之中，目前的默认选项 G1 GC 在不断的进行改进，很多我们原来认为的缺点，例如串行的 Full GC、Card Table 扫描的低效等，都已经被大幅改进，例如， JDK 10 以后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行 Full GC 实现。</p>
<p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台。</p>
<p>比较不幸的是 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但是已经被标记为废弃，如果没有组织主动承担 CMS 的维护，很有可能会在未来版本移除。</p>
<p>如果你有关注目前尚处于开发中的 JDK 11，你会发现，JDK 又增加了两种全新的 GC 方式，分别是：</p>
<ul>
<li><a href="http://openjdk.java.net/jeps/318">Epsilon GC</a>，简单说就是个不做垃圾收集的 GC，似乎有点奇怪，有的情况下，例如在进行性能测试的时候，可能需要明确判断 GC 本身产生了多大的开销，这就是其典型应用场景。</li>
<li><a href="http://openjdk.java.net/jeps/333">ZGC</a>，这是 Oracle 开源出来的一个超级 GC 实现，具备令人惊讶的扩展能力，比如支持 T bytes 级别的堆大小，并且保证绝大部分情况下，延迟都不会超过 10 ms。虽然目前还处于实验阶段，仅支持 Linux 64 位的平台，但其已经表现出的能力和潜力都非常令人期待。</li>
</ul>
<p>当然，其他厂商也提供了各种独具一格的 GC 实现，例如比较有名的低延迟 GC，<a href="https://www.infoq.com/articles/azul_gc_in_detail">Zing</a>和<a href="https://wiki.openjdk.java.net/display/shenandoah/Main">Shenandoah</a>等，有兴趣请参考我提供的链接。</p>
<p>今天，作为 GC 系列的第一讲，我从整体上梳理了目前的主流 GC 实现，包括基本原理和算法，并结合我前面介绍过的内存结构，对简要的垃圾收集过程进行了介绍，希望能够对你的相关实践有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GC</tag>
        <tag>垃圾收集</tag>
      </tags>
  </entry>
  <entry>
    <title>26 如何监控和诊断JVM堆内和堆外内存使用？</title>
    <url>/2024/09/22/2024-09-22-26-%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%92%8C%E8%AF%8A%E6%96%ADJVM%E5%A0%86%E5%86%85%E5%92%8C%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="26-如何监控和诊断JVM堆内和堆外内存使用？"><a href="#26-如何监控和诊断JVM堆内和堆外内存使用？" class="headerlink" title="26 如何监控和诊断JVM堆内和堆外内存使用？"></a>26 如何监控和诊断JVM堆内和堆外内存使用？</h1><p>上一讲我介绍了 JVM 内存区域的划分，总结了相关的一些概念，今天我将结合 JVM 参数、工具等方面，进一步分析 JVM 内存结构，包括外部资料相对较少的堆外部分。</p>
<p>今天我要问你的问题是，<strong>如何监控和诊断 JVM 堆内和堆外内存使用？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>了解 JVM 内存的方法有很多，具体能力范围也有区别，简单总结如下：</p>
<ul>
<li>可以使用综合性的图形化工具，如 JConsole、VisualVM（注意，从 Oracle JDK 9 开始，VisualVM 已经不再包含在 JDK 安装包中）等。这些工具具体使用起来相对比较直观，直接连接到 Java 进程，然后就可以在图形化界面里掌握内存使用情况。</li>
</ul>
<p>以 JConsole 为例，其内存页面可以显示常见的<strong>堆内存</strong>和<strong>各种堆外部分</strong>使用状态。</p>
<ul>
<li>也可以使用命令行工具进行运行时查询，如 jstat 和 jmap 等工具都提供了一些选项，可以查看堆、方法区等使用数据。</li>
<li>或者，也可以使用 jmap 等提供的命令，生成堆转储（Heap Dump）文件，然后利用 jhat 或 Eclipse MAT 等堆转储分析工具进行详细分析。</li>
<li>如果你使用的是 Tomcat、Weblogic 等 Java EE 服务器，这些服务器同样提供了内存管理相关的功能。</li>
<li>另外，从某种程度上来说，GC 日志等输出，同样包含着丰富的信息。</li>
</ul>
<p>这里有一个相对特殊的部分，就是是堆外内存中的直接内存，前面的工具基本不适用，可以使用 JDK 自带的 Native Memory Tracking（NMT）特性，它会从 JVM 本地内存分配的角度进行解读。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天选取的问题是 Java 内存管理相关的基础实践，对于普通的内存问题，掌握上面我给出的典型工具和方法就足够了。这个问题也可以理解为考察两个基本方面能力，第一，你是否真的理解了 JVM 的内部结构；第二，具体到特定内存区域，应该使用什么工具或者特性去定位，可以用什么参数调整。</p>
<p>对于 JConsole 等工具的使用细节，我在专栏里不再赘述，如果你还没有接触过，你可以参考<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">JConsole 官方教程</a>。我这里特别推荐<a href="http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html">Java Mission Control</a>（JMC），这是一个非常强大的工具，不仅仅能够使用<a href="https://en.wikipedia.org/wiki/Java_Management_Extensions">JMX</a>进行普通的管理、监控任务，还可以配合<a href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH171">Java Flight Recorder</a>（JFR）技术，以非常低的开销，收集和分析 JVM 底层的 Profiling 和事件等信息。目前， Oracle 已经将其开源，如果你有兴趣请可以查看 OpenJDK 的<a href="http://openjdk.java.net/projects/jmc/">Mission Control</a>项目。</p>
<p>关于内存监控与诊断，我会在知识扩展部分结合 JVM 参数和特性，尽量从庞杂的概念和 JVM 参数选项中，梳理出相对清晰的框架：</p>
<ul>
<li>细化对各部分内存区域的理解，堆内结构是怎样的？如何通过参数调整？</li>
<li>堆外内存到底包括哪些部分？具体大小受哪些因素影响？</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>今天的分析，我会结合相关 JVM 参数和工具，进行对比以加深你对内存区域更细粒度的理解。</p>
<p>首先，堆内部是什么结构？</p>
<p>对于堆内存，我在上一讲介绍了最常见的新生代和老年代的划分，其内部结构随着 JVM 的发展和新 GC 方式的引入，可以有不同角度的理解，下图就是年代视角的堆结构示意图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/721e97abc93449fbdb4c071f7b3b5289-20221127200452-30vopt9.png" alt="img"></p>
<p>你可以看到，按照通常的 GC 年代方式划分，Java 堆内分为：</p>
<ol>
<li>新生代</li>
</ol>
<p>新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 Eden 区域，作为对象初始分配的区域；两个 Survivor，有时候也叫 from、to 区域，被用来放置从 Minor GC 中保留下来的对象。</p>
<ul>
<li>JVM 会随意选取一个 Survivor 区域作为“to”，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 from 区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</li>
<li>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，Hotspot JVM 还有一个概念叫做 Thread Local Allocation Buffer（TLAB），据我所知所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计。这是 JVM 为每个线程分配的一个私有缓存区域，否则，多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，进而影响分配速度，你可以参考下面的示意图。从图中可以看出，TLAB 仍然在堆上，它是分配在 Eden 区域内的。其内部结构比较直观易懂，start、end 就是起始地址，top（指针）则表示已经分配到哪里了。所以我们分配新对象，JVM 就会移动 top，当 top 和 end 相遇时，即表示该缓存已满，JVM 会试图再从 Eden 里分配一块儿。</li>
</ul>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/f546839e98ea5d43b595235849b0f2bd-20221127200452-omd69u4.png" alt="img"></p>
<ol>
<li>老年代</li>
</ol>
<p>放置长生命周期的对象，通常都是从 Survivor 区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。</p>
<ol>
<li>永久代</li>
</ol>
<p>这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存，在 JDK 8 之后就不存在永久代这块儿了。</p>
<p>那么，我们如何利用 JVM 参数，直接影响堆和内部区域的大小呢？我来简单总结一下：</p>
<ul>
<li>最大堆体积</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xmx value</span><br></pre></td></tr></table></figure>

<ul>
<li>初始的最小堆体积</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms value</span><br></pre></td></tr></table></figure>

<ul>
<li>老年代和新生代的比例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:NewRatio=value</span><br></pre></td></tr></table></figure>

<p>默认情况下，这个数值是 2，意味着老年代是新生代的 2 倍大；换句话说，新生代是堆大小的 1&#x2F;3。</p>
<ul>
<li>当然，也可以不用比例的方式调整新生代的大小，直接指定下面的参数，设定具体的内存大小数值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:NewSize=value</span><br></pre></td></tr></table></figure>

<ul>
<li>Eden 和 Survivor 的大小是按照比例设置的，如果 SurvivorRatio 是 8，那么 Survivor 区域就是 Eden 的 1⁄8 大小，也就是新生代的 1&#x2F;10，因为 YoungGen&#x3D;Eden + 2*Survivor，JVM 参数格式是</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:SurvivorRatio=value</span><br></pre></td></tr></table></figure>

<ul>
<li>TLAB 当然也可以调整，JVM 实现了复杂的适应策略，如果你有兴趣可以参考这篇<a href="https://blogs.oracle.com/jonthecollector/the-real-thing">说明</a>。</li>
</ul>
<p>不知道你有没有注意到，我在年代视角的堆结构示意图也就是第一张图中，还标记出了 Virtual 区域，这是块儿什么区域呢？</p>
<p>在 JVM 内部，如果 Xms 小于 Xmx，堆的大小并不会直接扩展到其上限，也就是说保留的空间（reserved）大于实际能够使用的空间（committed）。当内存需求不断增长的时候，JVM 会逐渐扩展新生代等区域的大小，所以 Virtual 区域代表的就是暂时不可用（uncommitted）的空间。</p>
<p>第二，分析完堆内空间，我们一起来看看 JVM 堆外内存到底包括什么？</p>
<p>在 JMC 或 JConsole 的内存管理界面，会统计部分非堆内存，但提供的信息相对有限，下图就是 JMC 活动内存池的截图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/fa491795ffe21c1f49982de8b7810c2e-20221127200452-65wzojy.png" alt="img"></p>
<p>接下来我会依赖 NMT 特性对 JVM 进行分析，它所提供的详细分类信息，非常有助于理解 JVM 内部实现。</p>
<p>首先来做些准备工作，开启 NMT 并选择 summary 模式，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:NativeMemoryTracking=summary</span><br></pre></td></tr></table></figure>

<p>为了方便获取和对比 NMT 输出，选择在应用退出时打印 NMT 统计信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics</span><br></pre></td></tr></table></figure>

<p>然后，执行一个简单的在标准输出打印 HelloWorld 的程序，就可以得到下面的输出</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/55f1c7f0550adbbcc885c97a4dd426bb-20221127200452-x524vio.png" alt="img"></p>
<p>我来仔细分析一下，NMT 所表征的 JVM 本地内存使用：</p>
<ul>
<li>第一部分非常明显是 Java 堆，我已经分析过使用什么参数调整，不再赘述。</li>
<li>第二部分是 Class 内存占用，它所统计的就是 Java 类元数据所占用的空间，JVM 可以通过类似下面的参数调整其大小：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MaxMetaspaceSize=value</span><br></pre></td></tr></table></figure>

<p>对于本例，因为 HelloWorld 没有什么用户类库，所以其内存占用主要是启动类加载器（Bootstrap）加载的核心类库。你可以使用下面的小技巧，调整启动类加载器元数据区，这主要是为了对比以加深理解，也许只有在 hack JDK 时才有实际意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitialBootClassLoaderMetaspaceSize=<span class="number">30720</span></span><br></pre></td></tr></table></figure>

<ul>
<li>下面是 Thread，这里既包括 Java 线程，如程序主线程、Cleaner 线程等，也包括 GC 等本地线程。你有没有注意到，即使是一个 HelloWorld 程序，这个线程数量竟然还有 25。似乎有很多浪费，设想我们要用 Java 作为 Serverless 运行时，每个 function 是非常短暂的，如何降低线程数量呢？</li>
</ul>
<p>如果你充分理解了专栏讲解的内容，对 JVM 内部有了充分理解，思路就很清晰了：</p>
<p>JDK 9 的默认 GC 是 G1，虽然它在较大堆场景表现良好，但本身就会比传统的 Parallel GC 或者 Serial GC 之类复杂太多，所以要么降低其并行线程数目，要么直接切换 GC 类型；</p>
<p>JIT 编译默认是开启了 TieredCompilation 的，将其关闭，那么 JIT 也会变得简单，相应本地线程也会减少。</p>
<p>我们来对比一下，这是默认参数情况的输出：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/97d060b306e44af3a8443f932a0a4d42-20221127200452-82f1nys.png" alt="img"></p>
<p>下面是替换了默认 GC，并关闭 TieredCompilation 的命令行</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/b07d6da56f588cbfadbb7b381346213b-20221127200452-bgi456f.png" alt="img"></p>
<p>得到的统计信息如下，线程数目从 25 降到了 17，消耗的内存也下降了大概 1&#x2F;3。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/593735623f6917695602095fd249d527-20221127200452-gnelyd5.png" alt="img"></p>
<ul>
<li>接下来是 Code 统计信息，显然这是 CodeCache 相关内存，也就是 JIT compiler 存储编译热点方法等信息的地方，JVM 提供了一系列参数可以限制其初始值和最大值等，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitialCodeCacheSize=value</span><br><span class="line"></span><br><span class="line">-XX:ReservedCodeCacheSize=value</span><br></pre></td></tr></table></figure>

<p>你可以设置下列 JVM 参数，也可以只设置其中一个，进一步判断不同参数对 CodeCache 大小的影响。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/945740c37433f783d2d877c67dcc1170-20221127200452-f78thcr.png" alt="img"></p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/82d1fbc9ca09698c01ccff18fb97c8cd-20221127200452-s12gvko.png" alt="img"></p>
<p>很明显，CodeCache 空间下降非常大，这是因为我们关闭了复杂的 TieredCompilation，而且还限制了其初始大小。</p>
<ul>
<li>下面就是 GC 部分了，就像我前面介绍的，G1 等垃圾收集器其本身的设施和数据结构就非常复杂和庞大，例如 Remembered Set 通常都会占用 20%~30% 的堆空间。如果我把 GC 明确修改为相对简单的 Serial GC，会有什么效果呢？</li>
</ul>
<p>使用命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>

<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/6eeee6624c7dc6be54bfce5e93064233-20221127200452-gmepacj.png" alt="img"></p>
<p>可见，不仅总线程数大大降低（25 → 13），而且 GC 设施本身的内存开销就少了非常多。据我所知，AWS Lambda 中 Java 运行时就是使用的 Serial GC，可以大大降低单个 function 的启动和运行开销。</p>
<ul>
<li>Compiler 部分，就是 JIT 的开销，显然关闭 TieredCompilation 会降低内存使用。</li>
<li>其他一些部分占比都非常低，通常也不会出现内存使用问题，请参考<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr022.html#BABCBGFA">官方文档</a>。唯一的例外就是 Internal（JDK 11 以后在 Other 部分）部分，其统计信息<strong>包含着 Direct Buffer 的直接内存</strong>，这其实是堆外内存中比较敏感的部分，很多堆外内存 OOM 就发生在这里，请参考专栏第 12 讲的处理步骤。原则上 Direct Buffer 是不推荐频繁创建或销毁的，如果你怀疑直接内存区域有问题，通常可以通过类似 instrument 构造函数等手段，排查可能的问题。</li>
</ul>
<p>JVM 内部结构就介绍到这里，主要目的是为了加深理解，很多方面只有在定制或调优 JVM 运行时才能真正涉及，随着微服务和 Serverless 等技术的兴起，JDK 确实存在着为新特征的工作负载进行定制的需求。</p>
<p>今天我结合 JVM 参数和特性，系统地分析了 JVM 堆内和堆外内存结构，相信你一定对 JVM 内存结构有了比较深入的了解，在定制 Java 运行时或者处理 OOM 等问题的时候，思路也会更加清晰。JVM 问题千奇百怪，如果你能快速将问题缩小，大致就能清楚问题可能出在哪里，例如如果定位到问题可能是堆内存泄漏，往往就已经有非常清晰的<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks004.html#CIHIEEFH">思路和工具</a>可以去解决了。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>内存监控</tag>
      </tags>
  </entry>
  <entry>
    <title>25 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError</title>
    <url>/2024/09/22/2024-09-22-25-%E8%B0%88%E8%B0%88JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%88%92%E5%88%86%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9FOutOfMemoryError/</url>
    <content><![CDATA[<h1 id="25-谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError"><a href="#25-谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError" class="headerlink" title="25 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError"></a>25 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError</h1><p>今天，我将从内存管理的角度，进一步探索 Java 虚拟机（JVM）。垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得 JVM 内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是 Java 工程师进阶的必备能力。</p>
<p>今天我要问你的问题是，<strong>谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>通常可以把 JVM 内存区域分为下面几个方面，其中，有的区域是以线程为单位，而有的区域则是整个 JVM 进程唯一的。</p>
<p>首先，<strong>程序计数器</strong>（PC，Program Counter Register）。在 JVM 规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。</p>
<p>第二，<strong>Java 虚拟机栈</strong>（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。</p>
<p>前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。</p>
<p>栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。</p>
<p>第三，<strong>堆</strong>（Heap），它是 Java 内存管理的核心区域，用来放置 Java 对象实例，几乎所有创建的 Java 对象实例都是被直接分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定的“Xmx”之类参数就是用来指定最大堆空间等指标。</p>
<p>理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</p>
<p>第四，<strong>方法区</strong>（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、字段、方法代码等。</p>
<p>由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8 中将永久代移除，同时增加了元数据区（Metaspace）。</p>
<p>第五，<strong>运行时常量池</strong>（Run-Time Constant Pool），这是方法区的一部分。如果仔细分析过反编译的类文件结构，你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java 的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</p>
<p>第六，<strong>本地方法栈</strong>（Native Method Stack）。它和 Java 虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>这是个 JVM 领域的基础题目，我给出的答案依据的是<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5">JVM 规范</a>中运行时数据区定义，这也和大多数书籍和资料解读的角度类似。</p>
<p>JVM 内部的概念庞杂，对于初学者比较晦涩，我的建议是在工作之余，还是要去阅读经典书籍，比如我推荐过多次的《深入理解 Java 虚拟机》。</p>
<p>今天这一讲作为 Java 虚拟机内存管理的开篇，我会侧重于：</p>
<ul>
<li>分析广义上的 JVM 内存结构或者说 Java 进程内存结构。</li>
<li>谈到 Java 内存模型，不可避免的要涉及 OutOfMemory（OOM）问题，那么在 Java 里面存在哪些种 OOM 的可能性，分别对应哪个内存区域的异常状况呢？</li>
</ul>
<p>注意，具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。我在下面的分析中，还会介绍 Oracle Hotspot JVM 的部分设计变化。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，为了让你有个更加直观、清晰的印象，我画了一个简单的内存结构图，里面展示了我前面提到的堆、线程栈等区域，并从数量上说明了什么是线程私有，例如，程序计数器、Java 栈等，以及什么是 Java 进程唯一。另外，还额外划分出了直接内存等区域。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/360b8f453e016cb641208a6a8fb589bc-20221127200058-2ojyun4.png" alt="img"></p>
<p>这张图反映了实际中 Java 进程内存占用，与规范中定义的 JVM 运行时数据区之间的差别，它可以看作是运行时数据区的一个超集。毕竟理论上的视角和现实中的视角是有区别的，规范侧重的是通用的、无差别的部分，而对于应用开发者来说，只要是 Java 进程在运行时会占用，都会影响到我们的工程实践。</p>
<p>我这里简要介绍两点区别：</p>
<ul>
<li>直接内存（Direct Memory）区域，它就是我在【专栏第 12 讲】中谈到的 Direct Buffer 所直接分配的内存，也是个容易出现问题的地方。尽管，在 JVM 工程师的眼中，并不认为它是 JVM 内部内存的一部分，也并未体现 JVM 内存模型中。</li>
<li>JVM 本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT Compiler 在运行时对热点方法进行编译，就会将编译后的方法储存在 Code Cache 里面；GC 等功能需要运行在本地线程之中，类似部分都需要占用内存空间。这些是实现 JVM JIT 等功能的需要，但规范中并不涉及。</li>
</ul>
<p>如果深入到 JVM 的实现细节，你会发现一些结论似乎有些模棱两可，比如：</p>
<ul>
<li>Java 对象是不是都创建在堆上的呢？</li>
</ul>
<p>我注意到有一些观点，认为通过<a href="https://en.wikipedia.org/wiki/Escape_analysis">逃逸分析</a>，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis">文档</a>里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>
<ul>
<li>目前很多书籍还是基于 JDK 7 以前的版本，JDK 已经发生了很大变化，Intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，Intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</li>
</ul>
<p>接下来，我们来看看什么是 OOM 问题，它可能在哪些内存区域发生？</p>
<p>首先，OOM 如果通俗点儿说，就是 JVM 内存不够用了，javadoc 中对<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/OutOfMemoryError.html">OutOfMemoryError</a>的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>
<p>这里面隐含着一层意思是，在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间，例如：</p>
<ul>
<li>我在【专栏第 4 讲】的引用机制分析中，已经提到了 JVM 会去尝试回收软引用指向的对象等。</li>
<li>在<a href="http://hg.openjdk.java.net/jdk/jdk/file/9f62267e79df/src/java.base/share/classes/java/nio/Bits.java">java.nio.BIts.reserveMemory()</a> 方法中，我们能清楚的看到，System.gc() 会被调用，以清理空间，这也是为什么在大量使用 NIO 的 Direct Buffer 之类时，通常建议不要加下面的参数，毕竟是个最后的尝试，有可能避免一定的内存不足问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+DisableExplicitGC</span><br></pre></td></tr></table></figure>

<p>当然，也不是在任何情况下垃圾收集器都会被触发的，比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。</p>
<p>从我前面分析的数据区的角度，除了程序计数器，其他区域都有可能会因为可能的空间不足发生 OutOfMemoryError，简单总结如下：</p>
<ul>
<li>堆内存不足是最常见的 OOM 原因之一，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap space”，原因可能千奇百怪，例如，可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小；或者出现 JVM 处理引用不及时，导致堆积起来，内存无法释放等。</li>
<li>而对于 Java 虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。</li>
<li>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 Intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”。</li>
<li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM，异常信息则变成了：“java.lang.OutOfMemoryError: Metaspace”。</li>
<li>直接内存不足，也会导致 OOM，这个已经【专栏第 11 讲】介绍过。</li>
</ul>
<p>今天是 JVM 内存部分的第一讲，算是我们先进行了热身准备，我介绍了主要的内存区域，以及在不同版本 Hotspot JVM 内部的变化，并且分析了各区域是否可能产生 OutOfMemoryError，以及 OOME 发生的典型情况。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>24 有哪些方法可以在运行时动态生成一个Java类？</title>
    <url>/2024/09/22/2024-09-22-24-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AAJava%E7%B1%BB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="24-有哪些方法可以在运行时动态生成一个Java类？"><a href="#24-有哪些方法可以在运行时动态生成一个Java类？" class="headerlink" title="24 有哪些方法可以在运行时动态生成一个Java类？"></a>24 有哪些方法可以在运行时动态生成一个Java类？</h1><p>在开始今天的学习前，我建议你先复习一下【专栏第 6 讲】有关动态代理的内容。作为 Java 基础模块中的内容，考虑到不同基础的同学以及一个循序渐进的学习过程，我当时并没有在源码层面介绍动态代理的实现技术，仅进行了相应的技术比较。但是，有了【上一讲】的类加载的学习基础后，我想是时候该进行深入分析了。</p>
<p>今天我要问你的问题是，<strong>有哪些方法可以在运行时动态生成一个 Java 类？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>我们可以从常见的 Java 类来源分析，通常的开发过程是，开发者编写 Java 代码，调用 javac 编译成 class 文件，然后通过类加载机制载入 JVM，就成为应用运行时可以使用的 Java 类了。</p>
<p>从上面过程得到启发，其中一个直接的方式是从源码入手，可以利用 Java 程序生成一段源码，然后保存到文件等，下面就只需要解决编译问题了。</p>
<p>有一种笨办法，直接用 ProcessBuilder 之类启动 javac 进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</p>
<p>前面的方法，本质上还是在当前程序进程之外编译的，那么还有没有不这么 low 的办法呢？</p>
<p>你可以考虑使用 Java Compiler API，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能，具体请参考<a href="https://docs.oracle.com/javase/9/docs/api/javax/tools/package-summary.html">java.compiler</a>相关文档。</p>
<p>进一步思考，我们一直围绕 Java 源码编译成为 JVM 可以理解的字节码，换句话说，只要是符合 JVM 规范的字节码，不管它是如何生成的，是不是都可以被 JVM 加载呢？我们能不能直接生成相应的字节码，然后交给类加载器去加载呢？</p>
<p>当然也可以，不过直接去写字节码难度太大，通常我们可以利用 Java 字节码操纵工具和类库来实现，比如在【专栏第 6 讲】中提到的<a href="https://asm.ow2.io/">ASM</a>、<a href="http://www.javassist.org/">Javassist</a>、cglib 等。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>虽然曾经被视为黑魔法，但在当前复杂多变的开发环境中，在运行时动态生成逻辑并不是什么罕见的场景。重新审视我们谈到的动态代理，本质上不就是在特定的时机，去修改已有类型实现，或者创建新的类型。</p>
<p>明白了基本思路后，我还是围绕类加载机制进行展开，面试过程中面试官很可能从技术原理或实践的角度考察：</p>
<ul>
<li>字节码和类加载到底是怎么无缝进行转换的？发生在整个类加载过程的哪一步？</li>
<li>如何利用字节码操纵技术，实现基本的动态代理逻辑？除了动态代理，字节码操纵技术还有那些应用</li>
<li>场景？</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们来理解一下，类从字节码到 Class 对象的转换，在类加载过程中，这一步是通过下面的方法提供的功能，或者 defineClass 的其他本地对等实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                   ProtectionDomain protectionDomain)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,</span><br><span class="line">                                   ProtectionDomain protectionDomain)</span><br></pre></td></tr></table></figure>

<p>我这里只选取了最基础的两个典型的 defineClass 实现，Java 重载了几个不同的方法。</p>
<p>可以看出，只要能够生成出规范的字节码，不管是作为 byte 数组的形式，还是放到 ByteBuffer 里，都可以平滑地完成字节码到 Java 对象的转换过程。</p>
<p>JDK 提供的 defineClass 方法，最终都是本地代码实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass1(ClassLoader loader, String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                  ProtectionDomain pd, String source);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass2(ClassLoader loader, String name, java.nio.ByteBuffer b,</span><br><span class="line">                                  <span class="type">int</span> off, <span class="type">int</span> len, ProtectionDomain pd,</span><br><span class="line">                                  String source);</span><br></pre></td></tr></table></figure>

<p>更进一步，我们来看看 JDK dynamic proxy 的<a href="http://hg.openjdk.java.net/jdk/jdk/file/29169633327c/src/java.base/share/classes/java/lang/reflect/Proxy.java">实现代码</a>。你会发现，对应逻辑是实现在 ProxyBuilder 这个静态内部类中，ProxyGenerator 生成字节码，并以 byte 数组的形式保存，然后通过调用 Unsafe 提供的 defineClass 入口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">      proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Class&lt;?&gt; pc = UNSAFE.defineClass(proxyName, proxyClassFile,</span><br><span class="line">                                   <span class="number">0</span>, proxyClassFile.length,</span><br><span class="line">                                   loader, <span class="literal">null</span>);</span><br><span class="line">  reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);</span><br><span class="line">  <span class="keyword">return</span> pc;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line"><span class="comment">// 如果出现ClassFormatError，很可能是输入参数有问题，比如，ProxyGenerator有bug</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面理顺了二进制的字节码信息到 Class 对象的转换过程，似乎我们还没有分析如何生成自己需要的字节码，接下来一起来看看相关的字节码操纵逻辑。</p>
<p>JDK 内部动态代理的逻辑，可以参考<a href="http://hg.openjdk.java.net/jdk/jdk/file/29169633327c/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java">java.lang.reflect.ProxyGenerator</a>的内部实现。我觉得可以认为这是种另类的字节码操纵技术，其利用了<a href="https://docs.oracle.com/javase/9/docs/api/java/io/DataOutputStream.html">DataOutputStrem</a>提供的能力，配合 hard-coded 的各种 JVM 指令实现方法，生成所需的字节码数组。你可以参考下面的示例代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">codeLocalLoadStore</span><span class="params">(<span class="type">int</span> lvar, <span class="type">int</span> opcode, <span class="type">int</span> opcode_0,</span></span><br><span class="line"><span class="params">                              DataOutputStream out)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">assert</span> lvar &gt;= <span class="number">0</span> &amp;&amp; lvar &lt;= <span class="number">0xFFFF</span>;</span><br><span class="line">  <span class="comment">// 根据变量数值，以不同格式，dump操作码</span></span><br><span class="line">    <span class="keyword">if</span> (lvar &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">      out.writeByte(opcode_0 + lvar);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lvar &lt;= <span class="number">0xFF</span>) &#123;</span><br><span class="line">      out.writeByte(opcode);</span><br><span class="line">      out.writeByte(lvar &amp; <span class="number">0xFF</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用宽指令修饰符，如果变量索引不能用无符号byte</span></span><br><span class="line">      out.writeByte(opc_wide);</span><br><span class="line">      out.writeByte(opcode);</span><br><span class="line">      out.writeShort(lvar &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现方式的好处是没有太多依赖关系，简单实用，但是前提是你需要懂各种<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">JVM 指令</a>，知道怎么处理那些偏移地址等，实际门槛非常高，所以并不适合大多数的普通开发场景。</p>
<p>幸好，Java 社区专家提供了各种从底层到更高抽象水平的字节码操作类库，我们不需要什么都自己从头做。JDK 内部就集成了 ASM 类库，虽然并未作为公共 API 暴露出来，但是它广泛应用在，如<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/instrument/package-summary.html">java.lang.instrumentation</a> API 底层实现，或者<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/CallSite.html">Lambda Call Site</a>生成的内部逻辑中，这些代码的实现我就不在这里展开了，如果你确实有兴趣或有需要，可以参考类似 LamdaForm 的字节码生成逻辑：<a href="http://hg.openjdk.java.net/jdk/jdk/file/29169633327c/src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java">java.lang.invoke.InvokerBytecodeGenerator</a>。</p>
<p>从相对实用的角度思考一下，实现一个简单的动态代理，都要做什么？如何使用字节码操纵技术，走通这个过程呢？</p>
<p>对于一个普通的 Java 动态代理，其实现过程可以简化成为：</p>
<ul>
<li>提供一个基础的接口，作为被调用类型（com.mycorp.HelloImpl）和代理类之间的统一入口，如 com.mycorp.Hello。</li>
<li>实现<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/reflect/InvocationHandler.html">InvocationHandler</a>，对代理对象方法的调用，会被分派到其 invoke 方法来真正实现动作。</li>
<li>通过 Proxy 类，调用其 newProxyInstance 方法，生成一个实现了相应基础接口的代理类实例，可以看下面的方法签名。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                    Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                    InvocationHandler h)</span></span><br></pre></td></tr></table></figure>

<p>我们分析一下，动态代码生成是具体发生在什么阶段呢？</p>
<p>不错，就是在 newProxyInstance 生成代理类实例的时候。我选取了 JDK 自己采用的 ASM 作为示例，一起来看看用 ASM 实现的简要过程，请参考下面的示例代码片段。</p>
<p>第一步，生成对应的类，其实和我们去写 Java 代码很类似，只不过改为用 ASM 方法和指定参数，代替了我们书写的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line"></span><br><span class="line">cw.visit(V1_8,                      <span class="comment">// 指定Java版本</span></span><br><span class="line">      ACC_PUBLIC,               <span class="comment">// 说明是public类型</span></span><br><span class="line">        <span class="string">&quot;com/mycorp/HelloProxy&quot;</span>,  <span class="comment">// 指定包和类的名称</span></span><br><span class="line">      <span class="literal">null</span>,                     <span class="comment">// 签名，null表示不是泛型</span></span><br><span class="line">      <span class="string">&quot;java/lang/Object&quot;</span>,               <span class="comment">// 指定父类</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">String</span>[]&#123; <span class="string">&quot;com/mycorp/Hello&quot;</span> &#125;); <span class="comment">// 指定需要实现的接口</span></span><br></pre></td></tr></table></figure>

<p>更进一步，我们可以按照需要为代理对象实例，生成需要的方法和逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodVisitor</span> <span class="variable">mv</span> <span class="operator">=</span> cw.visitMethod(</span><br><span class="line">      ACC_PUBLIC,               <span class="comment">// 声明公共方法</span></span><br><span class="line">      <span class="string">&quot;sayHello&quot;</span>,               <span class="comment">// 方法名称</span></span><br><span class="line">      <span class="string">&quot;()Ljava/lang/Object;&quot;</span>,   <span class="comment">// 描述符</span></span><br><span class="line">      <span class="literal">null</span>,                     <span class="comment">// 签名，null表示不是泛型</span></span><br><span class="line">      <span class="literal">null</span>);                      <span class="comment">// 可能抛出的异常，如果有，则指定字符串数组</span></span><br><span class="line"></span><br><span class="line">mv.visitCode();</span><br><span class="line"><span class="comment">// 省略代码逻辑实现细节</span></span><br><span class="line">cw.visitEnd();                      <span class="comment">// 结束类字节码生成</span></span><br></pre></td></tr></table></figure>

<p>上面的代码虽然有些晦涩，但总体还是能多少理解其用意，不同的 visitX 方法提供了创建类型，创建各种方法等逻辑。ASM API，广泛的使用了<a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a>模式，如果你熟悉这个模式，就会知道它所针对的场景是将算法和对象结构解耦，非常适合字节码操纵的场合，因为我们大部分情况都是依赖于特定结构修改或者添加新的方法、变量或者类型等。</p>
<p>按照前面的分析，字节码操作最后大都应该是生成 byte 数组，ClassWriter 提供了一个简便的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cw.toByteArray();</span><br></pre></td></tr></table></figure>

<p>然后，就可以进入我们熟知的类加载过程了，我就不再赘述了，如果你对 ASM 的具体用法感兴趣，可以参考这个<a href="https://www.baeldung.com/java-asm">教程</a>。</p>
<p>最后一个问题，字节码操纵技术，除了动态代理，还可以应用在什么地方？</p>
<p>这个技术似乎离我们日常开发遥远，但其实已经深入到各个方面，也许很多你现在正在使用的框架、工具就应用该技术，下面是我能想到的几个常见领域。</p>
<ul>
<li>各种 Mock 框架</li>
<li>ORM 框架</li>
<li>IOC 容器</li>
<li>部分 Profiler 工具，或者运行时诊断工具等</li>
<li>生成形式化代码的工具</li>
</ul>
<p>甚至可以认为，字节码操纵技术是工具和基础框架必不可少的部分，大大减少了开发者的负担。</p>
<p>今天我们探讨了更加深入的类加载和字节码操作方面技术。为了理解底层的原理，我选取的例子是比较偏底层的、能力全面的类库，如果实际项目中需要进行基础的字节码操作，可以考虑使用更加高层次视角的类库，例如<a href="http://bytebuddy.net/#/">Byte Buddy</a>等。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态生成</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>23 请介绍类加载过程，什么是双亲委派模型？</title>
    <url>/2024/09/22/2024-09-22-23-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="23-请介绍类加载过程，什么是双亲委派模型？"><a href="#23-请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="23 请介绍类加载过程，什么是双亲委派模型？"></a>23 请介绍类加载过程，什么是双亲委派模型？</h1><p>Java 通过引入字节码和 JVM 机制，提供了强大的跨平台能力，理解 Java 的类加载机制是深入 Java 开发的必要条件，也是个面试考察热点。</p>
<p>今天我要问你的问题是，<strong>请介绍类加载过程，什么是双亲委派模型？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>一般来说，我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html">Java 虚拟机规范</a>里有非常详细的定义。</p>
<p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p>
<p>加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p>
<p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p>
<ul>
<li>验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</li>
<li>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</li>
<li>解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3">Java 虚拟机规范</a>中，详细介绍了类、接口、方法和字段等各个方面的解析。</li>
</ul>
<p>最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
<p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是关于 JVM 类加载方面的基础问题，我前面给出的回答参考了 Java 虚拟机规范中的主要条款。如果你在面试中回答这个问题，在这个基础上还可以举例说明。</p>
<p>我们来看一个经典的延伸问题，准备阶段谈到静态变量，那么对于常量和不同静态变量有什么区别？</p>
<p>需要明确的是，没有人能够精确的理解和记忆所有信息，如果碰到这种问题，有直接答案当然最好；没有的话，就说说自己的思路。</p>
<p>我们定义下面这样的类型，分别提供了普通静态变量、静态常量，常量又考虑到原始类型和引用类型可能有区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLPreparation</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并反编译一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Javac CLPreparation.java</span><br><span class="line">Javap –v CLPreparation.class</span><br></pre></td></tr></table></figure>

<p>可以在字节码中看到这样的额外初始化逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span>: bipush      <span class="number">100</span></span><br><span class="line"> <span class="number">2</span>: putstatic   #<span class="number">2</span>                <span class="comment">// Field a:I</span></span><br><span class="line"> <span class="number">5</span>: sipush      <span class="number">10000</span></span><br><span class="line"> <span class="number">8</span>: invokestatic  #<span class="number">3</span>                <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line"><span class="number">11</span>: putstatic   #<span class="number">4</span>                  <span class="comment">// Field INTEGER_CONSTANT:Ljava/lang/Integer;</span></span><br></pre></td></tr></table></figure>

<p>这能让我们更清楚，普通原始类型静态变量和引用类型（即使是常量），是需要额外调用 putstatic 等 JVM 指令的，这些是在显式初始化阶段执行，而不是准备阶段调用；而原始类型常量，则不需要这样的步骤。</p>
<p>关于类加载过程的更多细节，有非常多的优秀资料进行介绍，你可以参考大名鼎鼎的《深入理解 Java 虚拟机》，一本非常好的入门书籍。我的建议是不要仅看教程，最好能够想出代码实例去验证自己对某个方面的理解和判断，这样不仅能加深理解，还能够在未来的应用开发中使用到。</p>
<p>其实，类加载机制的范围实在太大，我从开发和部署的不同角度，各选取了一个典型扩展问题供你参考：</p>
<ul>
<li>如果要真正理解双亲委派模型，需要理解 Java 中类加载器的架构和职责，至少要懂具体有哪些内建的类加载器，这些是我上面的回答里没有提到的；以及如何自定义类加载器？</li>
<li>从应用角度，解决某些类加载问题，例如我的 Java 程序启动较慢，有没有办法尽量减小 Java 类加载的开销？</li>
</ul>
<p>另外，需要注意的是，在 Java 9 中，Jigsaw 项目为 Java 提供了原生的模块化支持，内建的类加载器结构和机制发生了明显变化。我会对此进行讲解，希望能够避免一些未来升级中可能发生的问题。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，从架构角度，一起来看看 Java 8 以前各种类加载器的结构，下面是三种 Oracle JDK 内建的类加载器。</p>
<ul>
<li>启动类加载器（Bootstrap Class-Loader），加载 jre&#x2F;lib 下面的 jar 文件，如 rt.jar。它是个超级公民，即使是在开启了 Security Manager 的时候，JDK 仍赋予了它加载的程序 AllPermission。</li>
</ul>
<p>对于做底层开发的工程师，有的时候可能不得不去试图修改 JDK 的基础代码，也就是通常意义上的核心类库，我们可以使用下面的命令行参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 指定新的bootclasspath，替换java.*包的内部实现</span><br><span class="line">java -Xbootclasspath:&lt;your_boot_classpath&gt; your_App</span><br><span class="line"> </span><br><span class="line"># a意味着append，将指定目录添加到bootclasspath后面</span><br><span class="line">java -Xbootclasspath/a:&lt;your_dir&gt; your_App</span><br><span class="line"> </span><br><span class="line"># p意味着prepend，将指定目录添加到bootclasspath前面</span><br><span class="line">java -Xbootclasspath/p:&lt;your_dir&gt; your_App</span><br></pre></td></tr></table></figure>

<p>用法其实很易懂，例如，使用最常见的 “&#x2F;p”，既然是前置，就有机会替换个别基础类的实现。</p>
<p>我们一般可以使用下面方法获取父加载器，但是在通常的 JDK&#x2F;JRE 实现中，扩展类加载器 getParent() 都只能返回 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>扩展类加载器（Extension or Ext Class-Loader），负责加载我们放到 jre&#x2F;lib&#x2F;ext&#x2F; 目录下面的 jar 包，这就是所谓的 extension 机制。该目录也可以通过设置 “java.ext.dirs”来覆盖。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -Djava.ext.dirs=your_ext_dir HelloWorld</span><br></pre></td></tr></table></figure>

<ul>
<li>应用类加载器（Application or App Class-Loader），就是加载我们最熟悉的 classpath 的内容。这里有一个容易混淆的概念，系统（System）类加载器，通常来说，其默认就是 JDK 内建的应用类加载器，但是它同样是可能修改的，比如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -Djava.system.class.loader=com.yourcorp.YourClassLoader HelloWorld</span><br></pre></td></tr></table></figure>

<p>如果我们指定了这个参数，JDK 内建的应用类加载器就会成为定制加载器的父亲，这种方式通常用在类似需要改变双亲委派模式的场景。</p>
<p>具体请参考下图：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/35a3bc241d779ddcc357639547917ca1-20221031221125-ksudoc9.png" alt="img"></p>
<p>至于前面被问到的双亲委派模型，参考这个结构图更容易理解。试想，如果不同类加载器都自己加载需要的某个类型，那么就会出现多次重复加载，完全是种浪费。</p>
<p>通常类加载机制有三个基本特征：</p>
<ul>
<li>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider&#x2F;<a href="https://docs.oracle.com/javase/9/docs/api/java/util/ServiceLoader.html">ServiceLoader</a>机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。 例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li>
</ul>
<p>在 JDK 9 中，由于 Jigsaw 项目引入了 Java 平台模块化系统（JPMS），Java SE 的源代码被划分为一系列模块。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/15138305829ed15f45dd53ec38bd8379-20221031221125-qsqsusp.png" alt="img"></p>
<p>类加载器，类文件容器等都发生了非常大的变化，我这里总结一下：</p>
<ul>
<li>前面提到的 -Xbootclasspath 参数不可用了。API 已经被划分到具体的模块，所以上文中，利用“-Xbootclasspath&#x2F;p”替换某个 Java 核心类型代码，实际上变成了对相应的模块进行的修补，可以采用下面的解决方案：</li>
</ul>
<p>首先，确认要修改的类文件已经编译好，并按照对应模块（假设是 java.base）结构存放， 然后，给模块打补丁：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java --patch-module java.base=your_patch yourApp</span><br></pre></td></tr></table></figure>

<ul>
<li>扩展类加载器被重命名为平台类加载器（Platform Class-Loader），而且 extension 机制则被移除。也就意味着，如果我们指定 java.ext.dirs 环境变量，或者 lib&#x2F;ext 目录存在，JVM 将直接返回<strong>错误</strong>！建议解决办法就是将其放入 classpath 里。</li>
<li>部分不需要 AllPermission 的 Java 基础模块，被降级到平台类加载器中，相应的权限也被更精细粒度地限制起来。</li>
<li>rt.jar 和 tools.jar 同样是被移除了！JDK 的核心类库以及相关资源，被存储在 jimage 文件中，并通过新的 JRT 文件系统访问，而不是原有的 JAR 文件系统。虽然看起来很惊人，但幸好对于大部分软件的兼容性影响，其实是有限的，更直接地影响是 IDE 等软件，通常只要升级到新版本就可以了。</li>
<li>增加了 Layer 的抽象， JVM 启动默认创建 BootLayer，开发者也可以自己去定义和实例化 Layer，可以更加方便的实现类似容器一般的逻辑抽象。</li>
</ul>
<p>结合了 Layer，目前的 JVM 内部结构就变成了下面的层次，内建类加载器都在 BootLayer 中，其他 Layer 内部有自定义的类加载器，不同版本模块可以同时工作在不同的 Layer。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/20a6a22ae11c1be3e08c6fa0bc8a8c00-20221031221125-es9588u.png" alt="img"></p>
<p>谈到类加载器，绕不过的一个话题是自定义类加载器，常见的场景有：</p>
<ul>
<li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是<a href="https://www.oracle.com/java/technologies/java-ee-glance.html">Java EE</a>和<a href="https://en.wikipedia.org/wiki/OSGi">OSGI</a>、<a href="https://en.wikipedia.org/wiki/Java_Platform_Module_System">JPMS</a>等框架。</li>
<li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。</li>
<li>或者是需要自己操纵字节码，动态修改或者生成类型。</li>
</ul>
<p>我们可以总体上简单理解自定义类加载过程：</p>
<ul>
<li>通过指定名称，找到其二进制实现，这里往往就是自定义类加载器会“定制”的部分，例如，在特定数据源根据名字获取字节码，或者修改或生成字节码。</li>
<li>然后，创建 Class 对象，并完成类加载过程。二进制信息到 Class 对象的转换，通常就依赖<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html#defineClass-java.lang.String-byte:A-int-int-">defineClass</a>，我们无需自己实现，它是 final 方法。有了 Class 对象，后续完成加载过程就顺理成章了。</li>
</ul>
<p>具体实现我建议参考这个<a href="https://www.baeldung.com/java-classloaders">用例</a>。</p>
<p>我在【专栏第 1 讲】中，就提到了由于字节码是平台无关抽象，而不是机器码，所以 Java 需要类加载和解释、编译，这些都导致 Java 启动变慢。谈了这么多类加载，有没有什么通用办法，不需要代码和其他工作量，就可以降低类加载的开销呢？</p>
<p>这个，可以有。</p>
<ul>
<li>在第 1 讲中提到的 AOT，相当于直接编译成机器码，降低的其实主要是解释和编译开销。但是其目前还是个试验特性，支持的平台也有限，比如，JDK 9 仅支持 Linux x64，所以局限性太大，先暂且不谈。</li>
<li>还有就是较少人知道的 AppCDS（Application Class-Data Sharing），CDS 在 Java 5 中被引进，但仅限于 Bootstrap Class-loader，在 8u40 中实现了 AppCDS，支持其他的类加载器，在目前 2018 年初发布的 JDK 10 中已经开源。</li>
</ul>
<p>简单来说，AppCDS 基本原理和工作过程是：</p>
<p>首先，JVM 将类信息加载， 解析成为元数据，并根据是否需要修改，将其分类为 Read-Only 部分和 Read-Write 部分。然后，将这些元数据直接存储在文件系统中，作为所谓的 Shared Archive。命令很简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Java -Xshare:dump -XX:+UseAppCDS -XX:SharedArchiveFile=&lt;jsa&gt;  \</span><br><span class="line">         -XX:SharedClassListFile=&lt;classlist&gt; -XX:SharedArchiveConfigFile=&lt;config_file&gt;</span><br></pre></td></tr></table></figure>

<p>第二，在应用程序启动时，指定归档文件，并开启 AppCDS。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Java -Xshare:on -XX:+UseAppCDS -XX:SharedArchiveFile=&lt;jsa&gt; yourApp</span><br></pre></td></tr></table></figure>

<p>通过上面的命令，JVM 会通过内存映射技术，直接映射到相应的地址空间，免除了类加载、解析等各种开销。</p>
<p>AppCDS 改善启动速度非常明显，传统的 Java EE 应用，一般可以提高 20%~30% 以上；实验中使用 Spark KMeans 负载，20 个 slave，可以提高 11% 的启动速度。</p>
<p>与此同时，降低内存 footprint，因为同一环境的 Java 进程间可以共享部分数据结构。前面谈到的两个实验，平均可以减少 10% 以上的内存消耗。</p>
<p>当然，也不是没有局限性，如果恰好大量使用了运行时动态类加载，它的帮助就有限了。</p>
<p>今天我梳理了一下类加载的过程，并针对 Java 新版中类加载机制发生的变化，进行了相对全面的总结，最后介绍了一个改善类加载速度的特性，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>类加载</tag>
        <tag>双亲委派</tag>
      </tags>
  </entry>
  <entry>
    <title>22 AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</title>
    <url>/2024/09/22/2024-09-22-22-AtomicInteger%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%A7%E5%93%81%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%BA%94%E7%94%A8CAS%E6%93%8D%E4%BD%9C%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="22-AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"><a href="#22-AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？" class="headerlink" title="22 AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"></a>22 AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</h1><p>在今天这一讲中，我来分析一下并发包内部的组成，一起来看看各种同步结构、线程池等，是基于什么原理来设计和实现的。</p>
<p>今天我要问你的问题是，<strong>AtomicInteger 底层实现原理是什么？如何在自己的产品代码中应用 CAS 操作？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（<a href="https://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap</a>）技术。</p>
<p>所谓 CAS，表征的是一系列操作的集合，获取当前数值，进行一些运算，利用 CAS 指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</p>
<p>从 AtomicInteger 的内部属性可以看出，它依赖于 Unsafe 提供的一些底层能力，进行底层操作；以 volatile 的 value 字段，记录数值，以保证可见性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.<span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">VALUE</span> <span class="operator">=</span> U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<p>具体的原子操作细节，可以参考任意一个原子更新方法，比如下面的 getAndIncrement。</p>
<p>Unsafe 会利用 value 字段的内存地址偏移，直接完成操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 getAndIncrement 需要返归数值，所以需要添加失败重试逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而类似 compareAndSet 这种返回 boolean 类型的函数，因为其返回值表现的就是成功与否，所以不需要重试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span></span><br></pre></td></tr></table></figure>

<p>CAS 是 Java 并发中所谓 lock-free 机制的基础。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题有点偏向于 Java 并发机制的底层了，虽然我们在开发中未必会涉及 CAS 的实现层面，但是理解其机制，掌握如何在 Java 中运用该技术，还是十分有必要的，尤其是这也是个并发编程的面试热点。</p>
<p>有的同学反馈面试官会问 CAS 更加底层是如何实现的，这依赖于 CPU 提供的特定指令，具体根据体系结构的不同还存在着明显区别。比如，x86 CPU 提供 cmpxchg 指令；而在精简指令集的体系架构中，则通常是靠一对儿指令（如“load and reserve”和“store conditional”）实现的，在大多数处理器上 CAS 都是个非常轻量级的操作，这也是其优势所在。</p>
<p>大部分情况下，掌握到这个程度也就够用了，我认为没有必要让每个 Java 工程师都去了解到指令级别，我们进行抽象、分工就是为了让不同层面的开发者在开发中，可以尽量屏蔽不相关的细节。</p>
<p>如果我作为面试官，很有可能深入考察这些方向：</p>
<ul>
<li>在什么场景下，可以采用 CAS 技术，调用 Unsafe 毕竟不是大多数场景的最好选择，有没有更加推荐的方式呢？毕竟我们掌握一个技术，cool 不是目的，更不是为了应付面试，我们还是希望能在实际产品中有价值。</li>
<li>对 ReentrantLock、CyclicBarrier 等并发结构底层的实现技术的理解。</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>关于 CAS 的使用，你可以设想这样一个场景：在数据库产品中，为保证索引的一致性，一个常见的选择是，保证只有一个线程能够排他性地修改一个索引分区，如何在数据库抽象层面实现呢？</p>
<p>可以考虑为索引分区对象添加一个逻辑上的锁，例如，以当前独占的线程 ID 作为锁的数值，然后通过原子操作设置 lock 数值，来实现加锁和释放锁，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicBTreePartition</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> lock;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireLock</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseeLock</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在 Java 代码中，我们怎么实现锁操作呢？Unsafe 似乎不是个好的选择，例如，我就注意到类似 Cassandra 等产品，因为 Java 9 中移除了 Unsafe.moniterEnter()&#x2F;moniterExit()，导致无法平滑升级到新的 JDK 版本。目前 Java 提供了两种公共 API，可以实现这种 CAS 操作，比如使用 java.util.concurrent.atomic.AtomicLongFieldUpdater，它是基于反射机制创建，我们需要保证类型和字段名称正确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLongFieldUpdater&lt;AtomicBTreePartition&gt; lockFieldUpdater =</span><br><span class="line">        AtomicLongFieldUpdater.newUpdater(AtomicBTreePartition.class, <span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">acquireLock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="keyword">while</span> (!lockFieldUpdater.compareAndSet(<span class="built_in">this</span>, <span class="number">0L</span>, t))&#123;</span><br><span class="line">        <span class="comment">// 等待一会儿，数据库操作可能比较慢</span></span><br><span class="line">         …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/atomic/package-summary.html">Atomic 包</a>提供了最常用的原子性数据类型，甚至是引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选。</p>
<p>我在专栏第七讲中曾介绍使用原子数据类型和 Atomic*FieldUpdater，创建更加紧凑的计数器实现，以替代 AtomicLong。优化永远是针对特定需求、特定目的，我这里的侧重点是介绍可能的思路，具体还是要看需求。如果仅仅创建一两个对象，其实完全没有必要进行前面的优化，但是如果对象成千上万或者更多，就要考虑紧凑性的影响了。而 atomic 包提供的<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/atomic/LongAdder.html">LongAdder</a>，在高度竞争环境下，可能就是比 AtomicLong 更佳的选择，尽管它的本质是空间换时间。</p>
<p>回归正题，如果是 Java 9 以后，我们完全可以采用另外一种方式实现，也就是 Variable Handle API，这是源自于<a href="http://openjdk.java.net/jeps/193">JEP 193</a>，提供了各种粒度的原子或者有序性的操作等。我将前面的代码修改为如下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">VarHandle</span> <span class="variable">HANDLE</span> <span class="operator">=</span> MethodHandles.lookup().findStaticVarHandle</span><br><span class="line">        (AtomicBTreePartition.class, <span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">acquireLock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="keyword">while</span> (!HANDLE.compareAndSet(<span class="built_in">this</span>, <span class="number">0L</span>, t))&#123;</span><br><span class="line">        <span class="comment">// 等待一会儿，数据库操作可能比较慢</span></span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程非常直观，首先，获取相应的变量句柄，然后直接调用其提供的 CAS 方法。</p>
<p>一般来说，我们进行的类似 CAS 操作，可以并且推荐使用 Variable Handle API 去实现，其提供了精细粒度的公共底层 API。我这里强调公共，是因为其 API 不会像内部 API 那样，发生不可预测的修改，这一点提供了对于未来产品维护和升级的基础保障，坦白说，很多额外工作量，都是源于我们使用了 Hack 而非 Solution 的方式解决问题。</p>
<p>CAS 也并不是没有副作用，试想，其常用的失败重试机制，隐含着一个假设，即竞争情况是短暂的。大多数应用场景中，确实大部分重试只会发生一次就获得了成功，但是总是有意外情况，所以在有需要的时候，还是要考虑限制自旋的次数，以免过度消耗 CPU。</p>
<p>另外一个就是著名的<a href="https://en.wikipedia.org/wiki/ABA_problem">ABA</a>问题，这是通常只在 lock-free 算法下暴露的问题。我前面说过 CAS 是在更新时比较前值，如果对方只是恰好相同，例如期间发生了 A -&gt; B -&gt; A 的更新，仅仅判断数值是 A，可能导致不合理的修改操作。针对这种情况，Java 提供了 AtomicStampedReference 工具类，通过为引用建立类似版本号（stamp）的方式，来保证 CAS 的正确性，具体用法请参考这里的<a href="http://tutorials.jenkov.com/java-util-concurrent/atomicstampedreference.html">介绍</a>。</p>
<p>前面介绍了 CAS 的场景与实现，幸运的是，大多数情况下，Java 开发者并不需要直接利用 CAS 代码去实现线程安全容器等，更多是通过并发包等间接享受到 lock-free 机制在扩展性上的好处。</p>
<p>下面我来介绍一下 AbstractQueuedSynchronizer（AQS），其是 Java 并发包中，实现各种同步结构和部分其他组成单元（如线程池中的 Worker）的基础。</p>
<p>学习 AQS，如果上来就去看它的一系列方法（下图所示），很有可能把自己看晕，这种似懂非懂的状态也没有太大的实践意义。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/e3b4b7fe5a94a88ca2feb04d734b9c36-20221031215703-53www3f.png" alt="img"></p>
<p>我建议的思路是，尽量简化一下，理解为什么需要 AQS，如何使用 AQS，<strong>至少</strong>要做什么，再进一步结合 JDK 源代码中的实践，理解 AQS 的原理与应用。</p>
<p><a href="https://en.wikipedia.org/wiki/Doug_Lea">Doug Lea</a>曾经介绍过 AQS 的设计初衷。从原理上，一种同步结构往往是可以利用其他的结构实现的，例如我在专栏第 19 讲中提到过可以使用 Semaphore 实现互斥锁。但是，对某种同步结构的倾向，会导致复杂、晦涩的实现逻辑，所以，他选择了将基础的同步相关操作抽象在 AbstractQueuedSynchronizer 中，利用 AQS 为我们构建同步结构提供了范本。</p>
<p>AQS 内部数据和方法，可以简单拆分为：</p>
<ul>
<li>一个 volatile 的整数成员表征状态，同时提供了 setState 和 getState 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个先入先出（FIFO）的等待线程队列，以实现多线程间竞争和等待，这是 AQS 机制的核心之一。</li>
<li>各种基于 CAS 的基础操作方法，以及各种期望具体同步结构去实现的 acquire&#x2F;release 方法。</li>
</ul>
<p>利用 AQS 实现一个同步结构，至少要实现两个基本类型的方法，分别是 acquire 操作，获取资源的独占权；还有就是 release 操作，释放对某个资源的独占。</p>
<p>以 ReentrantLock 为例，它内部通过扩展 AQS 实现了 Sync 类型，以 AQS 的 state 来反映锁的持有情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123; …&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 ReentrantLock 对应 acquire 和 release 操作，如果是 CountDownLatch 则可以看作是 await()&#x2F;countDown()，具体实现也有区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排除掉一些细节，整体地分析 acquire 方法逻辑，其直接实现是在 AQS 内部，调用了 tryAcquire 和 acquireQueued，这是两个需要搞清楚的基本部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们来看看 tryAcquire。在 ReentrantLock 中，tryAcquire 逻辑实现在 NonfairSync 和 FairSync 中，分别提供了进一步的非公平或公平性方法，而 AQS 内部 tryAcquire 仅仅是个接近未实现的方法（直接抛异常），这是留个实现者自己定义的操作。</p>
<p>我们可以看到公平性在 ReentrantLock 构建时如何指定的，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(); <span class="comment">// 默认是非公平的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以非公平的 tryAcquire 为例，其内部实现了如何配合状态与 CAS 获取锁，注意，对比公平版本的 tryAcquire，它在锁无人占有时，并不检查是否有其他等待者，这里体现了非公平的语义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();<span class="comment">// 获取当前AQS内部状态量</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 0表示无人占有，则直接用CAS修改状态位，</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">// 不检查排队情况，直接争抢</span></span><br><span class="line">          setExclusiveOwnerThread(current);  <span class="comment">//并设置当前线程独占锁</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//即使状态不是0，也可能当前线程是锁持有者，因为这是再入锁</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我再来分析 acquireQueued，如果前面的 tryAcquire 失败，代表着锁争抢失败，进入排队竞争阶段。这里就是我们所说的，利用 FIFO 队列，实现线程间对锁的竞争的部分，算是是 AQS 的核心逻辑。</p>
<p>当前线程会被包装成为一个排他模式的节点（EXCLUSIVE），通过 addWaiter 方法添加到队列中。acquireQueued 的逻辑，简要来说，就是如果当前节点的前面是头节点，则试图获取锁，一切顺利则成为新的头节点；否则，有必要则等待，具体处理逻辑请参考我添加的注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;<span class="comment">// 循环</span></span><br><span class="line">          <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 获取前一个节点</span></span><br><span class="line">          <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果前一个节点是头结点，表示当前节点合适去tryAcquire</span></span><br><span class="line">              setHead(node); <span class="comment">// acquire成功，则设置新的头节点</span></span><br><span class="line">              p.next = <span class="literal">null</span>; <span class="comment">// 将前面节点对当前节点的引用清空</span></span><br><span class="line">              <span class="keyword">return</span> interrupted;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)) <span class="comment">// 检查是否失败后需要park</span></span><br><span class="line">              interrupted |= parkAndCheckInterrupt();</span><br><span class="line">      &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      cancelAcquire(node);<span class="comment">// 出现异常，取消</span></span><br><span class="line">      <span class="keyword">if</span> (interrupted)</span><br><span class="line">              selfInterrupt();</span><br><span class="line">      <span class="keyword">throw</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里线程试图获取锁的过程基本展现出来了，tryAcquire 是按照特定场景需要开发者去实现的部分，而线程间竞争则是 AQS 通过 Waiter 队列与 acquireQueued 提供的，在 release 方法中，同样会对队列进行对应操作。</p>
<p>今天我介绍了 Atomic 数据类型的底层技术 CAS，并通过实例演示了如何在产品代码中利用 CAS，最后介绍了并发包的基础技术 AQS，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>原子变量</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>21 Java并发类库提供的线程池有哪几种？分别有什么特点？</title>
    <url>/2024/09/22/2024-09-22-21-Java%E5%B9%B6%E5%8F%91%E7%B1%BB%E5%BA%93%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="21-Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#21-Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="21 Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>21 Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h1><p>我在【专栏第 17 讲】中介绍过线程是不能够重复启动的，创建或销毁线程存在一定的开销，所以利用线程池技术来提高系统资源利用效率，并简化线程管理，已经是非常成熟的选择。</p>
<p>今天我要问你的问题是，Java 并发类库提供的线程池有哪几种？ 分别有什么特点？</p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>通常开发者都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。</p>
<p>Executors 目前提供了 5 种不同的线程池创建配置：</p>
<ul>
<li>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。</li>
<li>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</li>
<li>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</li>
<li>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>，利用<a href="https://en.wikipedia.org/wiki/Work_stealing">Work-Stealing</a>算法，并行地处理任务，不保证处理顺序。</li>
</ul>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>Java 并发包中的 Executor 框架无疑是并发编程中的重点，今天的题目考察的是对几种标准线程池的了解，我提供的是一个针对最常见的应用方式的回答。</p>
<p>在大多数应用场景下，使用 Executors 提供的 5 个静态工厂方法就足够了，但是仍然可能需要直接利用 ThreadPoolExecutor 等构造函数创建，这就要求你对线程构造方式有进一步的了解，你需要明白线程池的设计和结构。</p>
<p>另外，线程池这个定义就是个容易让人误解的术语，因为 ExecutorService 除了通常意义上“池”的功能，还提供了更全面的线程管理、任务提交等方法。</p>
<ul>
<li>Executor 框架可不仅仅是线程池，我觉得至少下面几点值得深入学习：</li>
<li>掌握 Executor 框架的主要内容，至少要了解组成与职责，掌握基本开发用例中的使用。</li>
<li>对线程池和相关并发工具类型的理解，甚至是源码层面的掌握。</li>
<li>实践中有哪些常见问题，基本的诊断思路是怎样的。</li>
<li>如何根据自身应用特点合理使用线程池。</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们来看看 Executor 框架的基本组成，请参考下面的类图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/fc70c37867c7fbfb672fa3e37fe14b5b-20221031214414-sszxr4j.png" alt="img"></p>
<p>我们从整体上把握一下各个类型的主要设计目的：</p>
<ul>
<li>Executor 是一个基础的接口，其初衷是将任务提交和任务执行细节解耦，这一点可以体会其定义的唯一方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br></pre></td></tr></table></figure>

<p>Executor 的设计是源于 Java 早期线程 API 使用的教训，开发者在实现应用逻辑时，被太多线程创建、调度等不相关细节所打扰。就像我们进行 HTTP 通信，如果还需要自己操作 TCP 握手，开发效率低下，质量也难以保证。</p>
<ul>
<li>ExecutorService 则更加完善，不仅提供 service 的管理功能，比如 shutdown 等方法，也提供了更加全面的提交任务机制，如返回<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Future.html">Future</a>而不是 void 的 submit 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br></pre></td></tr></table></figure>

<p>注意，这个例子输入的可是<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Callable.html">Callable</a>，它解决了 Runnable 无法返回结果的困扰。</p>
<ul>
<li>Java 标准类库提供了几种基础实现，比如<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">ScheduledThreadPoolExecutor</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>。这些线程池的设计特点在于其高度的可调节性和灵活性，以尽量满足复杂多变的实际应用场景，我会进一步分析其构建部分的源码，剖析这种灵活性的源头。</li>
<li>Executors 则从简化使用的角度，为我们提供了各种方便的静态工厂方法。</li>
</ul>
<p>下面我就从源码角度，分析线程池的设计与实现，我将主要围绕最基础的 ThreadPoolExecutor 源码。ScheduledThreadPoolExecutor 是 ThreadPoolExecutor 的扩展，主要是增加了调度逻辑，如想深入了解，你可以参考相关<a href="https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example">教程</a>。而 ForkJoinPool 则是为 ForkJoinTask 定制的线程池，与通常意义的线程池有所不同。</p>
<p>这部分内容比较晦涩，罗列概念也不利于你去理解，所以我会配合一些示意图来说明。在现实应用中，理解应用与线程池的交互和线程池的内部工作过程，你可以参考下图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/18b64aee22c67f488171a73133e4d465-20221031214414-9filki5.png" alt="img"></p>
<p>简单理解一下：</p>
<ul>
<li>工作队列负责存储用户提交的各个任务，这个工作队列，可以是容量为 0 的 SynchronousQueue（使用 newCachedThreadPool），也可以是像固定大小线程池（newFixedThreadPool）那样使用 LinkedBlockingQueue。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br></pre></td></tr></table></figure>

<ul>
<li>内部的“线程池”，这是指保持工作线程的集合，线程池需要在运行过程中管理线程创建、销毁。例如，对于带缓存的线程池，当任务压力较大时，线程池会创建新的工作线程；当业务压力退去，线程池会在闲置一段时间（默认 60 秒）后结束线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>线程池的工作线程被抽象为静态内部类 Worker，基于<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html">AQS</a>实现。</p>
<ul>
<li>ThreadFactory 提供上面所需要的创建线程逻辑。</li>
<li>如果任务提交时被拒绝，比如线程池已经处于 SHUTDOWN 状态，需要为其提供处理逻辑，Java 标准库提供了类似<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html">ThreadPoolExecutor.AbortPolicy</a>等默认实现，也可以按照实际需求自定义。</li>
</ul>
<p>从上面的分析，就可以看出线程池的几个基本组成部分，一起都体现在线程池的构造函数中，从字面我们就可以大概猜测到其用意：</p>
<ul>
<li>corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目（除非设置了 allowCoreThreadTimeOut）。对于不同的线程池，这个值可能会有很大区别，比如 newFixedThreadPool 会将其设置为 nThreads，而对于 newCachedThreadPool 则是为 0。</li>
<li>maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数。同样进行对比，对于 newFixedThreadPool，当然就是 nThreads，因为其要求是固定大小，而 newCachedThreadPool 则是 Integer.MAX_VALUE。</li>
<li>keepAliveTime 和 TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。</li>
<li>workQueue，工作队列，必须是 BlockingQueue。</li>
</ul>
<p>通过配置不同的参数，我们就可以创建出行为大相径庭的线程池，这就是线程池高度灵活性的基础。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                        <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                        TimeUnit unit,</span></span><br><span class="line"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                        ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                        RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<p>进一步分析，线程池既然有生命周期，它的状态是如何表征的呢？</p>
<p>这里有一个非常有意思的设计，ctl 变量被赋予了双重角色，通过高低位的不同，既表示线程池状态，又表示工作线程数目，这是一个典型的高效优化。试想，实际系统中，虽然我们可以指定线程极限为 Integer.MAX_VALUE，但是因为资源限制，这只是个理论值，所以完全可以将空闲位赋予其他意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 真正决定了工作线程数的理论上限 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 线程池状态，存储在数字的高位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span> <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">…</span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; ~COUNT_MASK; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; COUNT_MASK; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>为了让你能对线程生命周期有个更加清晰的印象，我这里画了一个简单的状态流转图，对线程池的可能状态和其内部方法之间进行了对应，如果有不理解的方法，请参考 Javadoc。<strong>注意</strong>，实际 Java 代码中并不存在所谓 Idle 状态，我添加它仅仅是便于理解。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/c50ce5f2ff4ae723c6267185699ccda1-20221031214414-bedodgj.png" alt="img"></p>
<p>前面都是对线程池属性和构建等方面的分析，下面我选择典型的 execute 方法，来看看其是如何工作的，具体逻辑请参考我添加的注释，配合代码更加容易理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">…</span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"><span class="comment">// 检查工作线程数目，低于corePoolSize则添加Worker</span></span><br><span class="line">  <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">      <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      c = ctl.get();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// isRunning就是检查线程池是否被shutdown</span></span><br><span class="line"><span class="comment">// 工作队列可能是有界的，offer是比较友好的入队方式</span></span><br><span class="line">  <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"><span class="comment">// 再次进行防御性检查</span></span><br><span class="line">      <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">          reject(command);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">          addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 尝试添加一个worker，如果失败意味着已经饱和或者被shutdown了</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">      reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池实践</strong></p>
<p>线程池虽然为提供了非常强大、方便的功能，但是也不是银弹，使用不当同样会导致问题。我这里介绍些典型情况，经过前面的分析，很多方面可以自然的推导出来。</p>
<ul>
<li>避免任务堆积。前面我说过 newFixedThreadPool 是创建指定数目的线程，但是其工作队列是无界的，如果工作线程数目太少，导致处理跟不上入队的速度，这就很有可能占用大量系统内存，甚至是出现 OOM。诊断时，你可以使用 jmap 之类的工具，查看是否有大量的任务对象入队。</li>
<li>避免过度扩展线程。我们通常在处理大量短时任务时，使用缓存的线程池，比如在最新的 HTTP&#x2F;2 client API 中，目前的默认实现就是如此。我们在创建线程池的时候，并不能准确预计任务压力有多大、数据特征是什么样子（大部分请求是 1K 、100K 还是 1M 以上？），所以很难明确设定一个线程数目。</li>
<li>另外，如果线程数目不断增长（可以使用 jstack 等工具检查），也需要警惕另外一种可能性，就是线程泄漏，这种情况往往是因为任务逻辑有问题，导致工作线程迟迟不能被释放。建议你排查下线程栈，很有可能多个线程都是卡在近似的代码处。</li>
<li>避免死锁等同步问题，对于死锁的场景和排查，你可以复习【专栏第 18 讲】。</li>
<li>尽量避免在使用线程池时操作 ThreadLocal，同样是【专栏第 17 讲】已经分析过的，通过今天的线程池学习，应该更能理解其原因，工作线程的生命周期通常都会超过任务的生命周期。</li>
</ul>
<p><strong>线程池大小的选择策略</strong></p>
<p>上面我已经介绍过，线程池大小不合适，太多或太少，都会导致麻烦，所以我们需要去考虑一个合适的线程池大小。虽然不能完全确定，但是有一些相对普适的规则和思路。</p>
<ul>
<li>如果我们的任务主要是进行计算，那么就意味着 CPU 的处理能力是稀缺的资源，我们能够通过大量增加线程数提高计算能力吗？往往是不能的，如果线程太多，反倒可能导致大量的上下文切换开销。所以，这种情况下，通常建议按照 CPU 核的数目 N 或者 N+1。</li>
<li>如果是需要较多等待的任务，例如 I&#x2F;O 操作比较多，可以参考 Brain Goetz 推荐的计算方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程数 = CPU核数 × 目标CPU利用率 ×（<span class="number">1</span> + 平均等待时间/平均工作时间）</span><br></pre></td></tr></table></figure>

<p>这些时间并不能精准预计，需要根据采样或者概要分析等方式进行计算，然后在实际中验证和调整。</p>
<ul>
<li>上面是仅仅考虑了 CPU 等限制，实际还可能受各种系统资源限制影响，例如我最近就在 Mac OS X 上遇到了大负载时<a href="http://danielmendel.github.io/blog/2013/04/07/benchmarkers-beware-the-ephemeral-port-limit/">ephemeral 端口受限</a>的情况。当然，我是通过扩大可用端口范围解决的，如果我们不能调整资源的容量，那么就只能限制工作线程的数目了。这里的资源可以是文件句柄、内存等。</li>
</ul>
<p>另外，在实际工作中，不要把解决问题的思路全部指望到调整线程池上，很多时候架构上的改变更能解决问题，比如利用背压机制的<a href="http://www.reactive-streams.org/">Reactive Stream</a>、合理的拆分等。</p>
<p>今天，我从 Java 创建的几种线程池开始，对 Executor 框架的主要组成、线程池结构与生命周期等方面进行了讲解和分析，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>20 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</title>
    <url>/2024/09/22/2024-09-22-20-%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84ConcurrentLinkedQueue%E5%92%8CLinkedBlockingQueue%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="20-并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"><a href="#20-并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？" class="headerlink" title="20 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"></a>20 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</h1><p>在上一讲中，我分析了 Java 并发包中的部分内容，今天我来介绍一下线程安全队列。Java 标准库提供了非常多的线程安全队列，很容易混淆。</p>
<p>今天我要问你的问题是，<strong>并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>有时候我们把并发包下面的所有容器都习惯叫作并发容器，但是严格来讲，类似 ConcurrentLinkedQueue 这种“Concurrent*”容器，才是真正代表并发。</p>
<p>关于问题中它们的区别：</p>
<ul>
<li>Concurrent 类型基于 lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。</li>
<li>而 LinkedBlockingQueue 内部则是基于锁，并提供了 BlockingQueue 的等待性方法。</li>
</ul>
<p>不知道你有没有注意到，java.util.concurrent 包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为 Concurrent*、CopyOnWrite和 Blocking等三类，同样是线程安全容器，可以简单认为：</p>
<ul>
<li>Concurrent 类型没有类似 CopyOnWrite 之类容器相对较重的修改开销。</li>
<li>但是，凡事都是有代价的，Concurrent 往往提供了较低的遍历一致性。你可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。</li>
<li>与弱一致性对应的，就是我介绍过的同步容器常见的行为“fail-fast”，也就是检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。</li>
<li>弱一致性的另外一个体现是，size 等操作准确性是有限的，未必是 100% 准确。</li>
<li>与此同时，读取的性能具有一定的不确定性。</li>
</ul>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是又是一个引子，考察你是否了解并发包内部不同容器实现的设计目的和实现区别。</p>
<p>队列是非常重要的数据结构，我们日常开发中很多线程间数据传递都要依赖于它，Executor 框架提供的各种线程池，同样无法离开队列。面试官可以从不同角度考察，比如：</p>
<ul>
<li>哪些队列是有界的，哪些是无界的？（很多同学反馈了这个问题）</li>
<li>针对特定场景需求，如何选择合适的队列实现？</li>
<li>从源码的角度，常见的线程安全队列是如何实现的，并进行了哪些改进以提高性能表现？</li>
</ul>
<p>为了能更好地理解这一讲，需要你掌握一些基本的队列本身和数据结构方面知识，如果这方面知识比较薄弱，《数据结构与算法分析》是一本比较全面的参考书，专栏还是尽量专注于 Java 领域的特性。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><strong>线程安全队列一览</strong></p>
<p>我在【专栏第 8 讲】中介绍过，常见的集合中如 LinkedList 是个 Deque，只不过不是线程安全的。下面这张图是 Java 并发类库提供的各种各样的<strong>线程安全</strong>队列实现，注意，图中并未将非线程安全部分包含进来。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/791750d6fe7ef88ecb3897e1d029f079-20221031211708-9oo5slt.png" alt="img"></p>
<p>我们可以从不同的角度进行分类，从基本的数据结构的角度分析，有两个特别的<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html">Deque</a>实现，ConcurrentLinkedDeque 和 LinkedBlockingDeque。Deque 的侧重点是支持对队列头尾都进行插入和删除，所以提供了特定的方法，如:</p>
<ul>
<li>尾部插入时需要的<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#addLast-E-">addLast(e)</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#offerLast-E-">offerLast(e)</a>。</li>
<li>尾部删除所需要的<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#removeLast--">removeLast()</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#pollLast--">pollLast()</a>。</li>
</ul>
<p>从上面这些角度，能够理解 ConcurrentLinkedDeque 和 LinkedBlockingQueue 的主要功能区别，也就足够日常开发的需要了。但是如果我们深入一些，通常会更加关注下面这些方面。</p>
<p>从行为特征来看，绝大部分 Queue 都是实现了 BlockingQueue 接口。在常规队列操作基础上，Blocking 意味着其提供了特定的等待性操作，获取时（take）等待元素进队，或者插入时（put）等待队列出现空位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取并移除队列头结点，如果必要，其会等待直到队列出现元素</span></span><br><span class="line"><span class="comment">…</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素，如果队列已满，则等待直到队列出现空闲空间</span></span><br><span class="line"><span class="comment">   …</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;  </span><br></pre></td></tr></table></figure>

<p>另一个 BlockingQueue 经常被考察的点，就是是否有界（Bounded、Unbounded），这一点也往往会影响我们在应用开发中的选择，我这里简单总结一下。</p>
<ul>
<li>ArrayBlockingQueue 是最典型的的有界队列，其内部以 final 的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建 ArrayBlockingQueue 时，都要指定容量，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LinkedBlockingQueue，容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为 Integer.MAX_VALUE，成为了无界队列。</li>
<li>SynchronousQueue，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。</li>
<li>PriorityBlockingQueue 是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响。</li>
<li>DelayedQueue 和 LinkedTransferQueue 同样是无边界的队列。对于无边界的队列，有一个自然的结果，就是 put 操作永远也不会发生其他 BlockingQueue 的那种等待情况。</li>
</ul>
<p>如果我们分析不同队列的底层实现，BlockingQueue 基本都是基于锁实现，一起来看看典型的 LinkedBlockingQueue。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br></pre></td></tr></table></figure>

<p>我在介绍 ReentrantLock 的条件变量用法的时候分析过 ArrayBlockingQueue，不知道你有没有注意到，其条件变量与 LinkedBlockingQueue 版本的实现是有区别的。notEmpty、notFull 都是同一个再入锁的条件变量，而 LinkedBlockingQueue 则改进了锁操作的粒度，头、尾操作使用不同的锁，所以在通用场景下，它的吞吐量相对要更好一些。</p>
<p>下面的 take 方法与 ArrayBlockingQueue 中的实现，也是有不同的，由于其内部结构是链表，需要自己维护元素数量值，请参考下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> E x;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似 ConcurrentLinkedQueue 等，则是基于 CAS 的无锁技术，不需要在每个操作时使用锁，所以扩展性表现要更加优异。</p>
<p>相对比较另类的 SynchronousQueue，在 Java 6 中，其实现发生了非常大的变化，利用 CAS 替换掉了原本基于锁的逻辑，同步开销比较小。它是 Executors.newCachedThreadPool() 的默认队列。</p>
<p><strong>队列使用场景与典型用例</strong></p>
<p>在实际开发中，我提到过 Queue 被广泛使用在生产者 - 消费者场景，比如利用 BlockingQueue 来实现，由于其提供的等待机制，我们可以少操心很多协调工作，你可以参考下面样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXIT_MSG</span>  <span class="operator">=</span> <span class="string">&quot;Good bye!&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 使用较小的队列，以更好地在输出中展示其影响</span></span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;String&gt; q)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5L</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Message&quot;</span> + i;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced new item: &quot;</span> + msg);</span><br><span class="line">                    queue.put(msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Time to say good bye!&quot;</span>);</span><br><span class="line">                queue.put(EXIT_MSG);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; q)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.queue=q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                String msg;</span><br><span class="line">                <span class="keyword">while</span>(!EXIT_MSG.equalsIgnoreCase( (msg = queue.take())))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed item: &quot;</span> + msg);</span><br><span class="line">                    Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Got exit message, bye!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个典型的生产者 - 消费者样例，如果使用非 Blocking 的队列，那么我们就要自己去实现轮询、条件判断（如检查 poll 返回值是否 null）等逻辑，如果没有特别的场景要求，Blocking 实现起来代码更加简单、直观。</p>
<p>前面介绍了各种队列实现，在日常的应用开发中，如何进行选择呢？</p>
<p>以 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue 为例，我们一起来分析一下，根据需求可以从很多方面考量：</p>
<ul>
<li>考虑应用场景中对队列边界的要求。ArrayBlockingQueue 是有明确的容量限制的，而 LinkedBlockingQueue 则取决于我们是否在创建时指定，SynchronousQueue 则干脆不能缓存任何元素。</li>
<li>从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。</li>
<li>通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。</li>
<li>ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。</li>
<li>如果我们需要实现的是两个线程之间接力性（handoff）的场景，按照【专栏上一讲】的例子，你可能会选择 CountDownLatch，但是<a href="https://www.baeldung.com/java-synchronous-queue">SynchronousQueue</a>也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。</li>
<li>可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。</li>
</ul>
<p>今天我分析了 Java 中让人眼花缭乱的各种线程安全队列，试图从几个角度，让每个队列的特点更加明确，进而希望减少你在日常工作中使用时的困扰。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>19 Java并发包提供了哪些并发工具类？</title>
    <url>/2024/09/22/2024-09-22-19-Java%E5%B9%B6%E5%8F%91%E5%8C%85%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="19-Java并发包提供了哪些并发工具类？"><a href="#19-Java并发包提供了哪些并发工具类？" class="headerlink" title="19 Java并发包提供了哪些并发工具类？"></a>19 Java并发包提供了哪些并发工具类？</h1><p>通过前面的学习，我们一起回顾了线程、锁等各种并发编程的基本元素，也逐步涉及了 Java 并发包中的部分内容，相信经过前面的热身，我们能够更快地理解 Java 并发包。</p>
<p>今天我要问你的问题是，<strong>Java 并发包提供了哪些并发工具类？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>我们通常所说的并发包也就是 java.util.concurrent 及其子包，集中了 Java 并发的各种基础工具类，具体主要包括几个方面：</p>
<ul>
<li>提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。</li>
<li>各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的 ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组 CopyOnWriteArrayList 等。</li>
<li>各种并发队列实现，如各种 BlockingQueue 实现，比较典型的 ArrayBlockingQueue、 SynchronousQueue 或针对特定场景的 PriorityBlockingQueue 等。</li>
<li>强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</li>
</ul>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>这个题目主要考察你对并发包了解程度，以及是否有实际使用经验。我们进行多线程编程，无非是达到几个目的：</p>
<ul>
<li>利用多线程提高程序的扩展能力，以达到业务对吞吐量的要求。</li>
<li>协调线程间调度、交互，以完成业务逻辑。</li>
<li>线程间传递数据和状态，这同样是实现业务逻辑的需要。</li>
</ul>
<p>所以，这道题目只能算作简单的开始，往往面试官还会进一步考察如何利用并发包实现某个特定的用例，分析实现的优缺点等。</p>
<p>如果你在这方面的基础比较薄弱，我的建议是：</p>
<ul>
<li>从总体上，把握住几个主要组成部分（前面回答中已经简要介绍）。</li>
<li>理解具体设计、实现和能力。</li>
<li>再深入掌握一些比较典型工具类的适用场景、用法甚至是原理，并熟练写出典型的代码用例。</li>
</ul>
<p>掌握这些通常就够用了，毕竟并发包提供了方方面面的工具，其实很少有机会能在应用中全面使用过，扎实地掌握核心功能就非常不错了。真正特别深入的经验，还是得靠在实际场景中踩坑来获得。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们来看看并发包提供的丰富同步结构。前面几讲已经分析过各种不同的显式锁，今天我将专注于</p>
<ul>
<li><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a>，允许一个或多个线程等待某些操作完成。</li>
<li><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CyclicBarrier.html">CyclicBarrier</a>，一种辅助性的同步结构，允许多个线程等待到达某个屏障。</li>
<li><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Semaphore.html">Semaphore</a>，Java 版本的信号量实现。</li>
</ul>
<p>Java 提供了经典信号量（<a href="https://en.wikipedia.org/wiki/Semaphore_(programming)">Semaphore</a>）的实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。你可以想象一下这个场景，在车站、机场等出租车时，当很多空出租车就位时，为防止过度拥挤，调度员指挥排队等待坐车的队伍一次进来 5 个人上车，等这 5 个人坐车出发，再放进去下一批，这和 Semaphore 的工作原理有些类似。</p>
<p>你可以试试使用 Semaphore 来模拟实现这个调度过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsualSemaphoreSample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Action...GO!&quot;</span>);</span><br><span class="line">      <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SemaphoreWorker</span>(semaphore));</span><br><span class="line">          t.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SemaphoreWorker</span><span class="params">(Semaphore semaphore)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.semaphore = semaphore;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          log(<span class="string">&quot;is waiting for a permit!&quot;</span>);</span><br><span class="line">         semaphore.acquire();</span><br><span class="line">          log(<span class="string">&quot;acquired a permit!&quot;</span>);</span><br><span class="line">          log(<span class="string">&quot;executed!&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          log(<span class="string">&quot;released a permit!&quot;</span>);</span><br><span class="line">          semaphore.release();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">          name = Thread.currentThread().getName();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(name + <span class="string">&quot; &quot;</span> + msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是比较典型的 Semaphore 示例，其逻辑是，线程试图获得工作允许，得到许可则进行任务，然后释放许可，这时等待许可的其他线程，就可获得许可进入工作状态，直到全部处理结束。编译运行，我们就能看到 Semaphore 的允许机制对工作线程的限制。</p>
<p>但是，从具体节奏来看，其实并不符合我们前面场景的需求，因为本例中 Semaphore 的用法实际是保证，一直有 5 个人可以试图乘车，如果有 1 个人出发了，立即就有排队的人获得许可，而这并不完全符合我们前面的要求。</p>
<p>那么，我再修改一下，演示个非典型的 Semaphore 用法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbnormalSemaphoreSample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyWorker</span>(semaphore));</span><br><span class="line">          t.start();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Action...GO!&quot;</span>);</span><br><span class="line">      semaphore.release(<span class="number">5</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Wait for permits off&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span> (semaphore.availablePermits()!=<span class="number">0</span>) &#123;</span><br><span class="line">          Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Action...GO again!&quot;</span>);</span><br><span class="line">      semaphore.release(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyWorker</span><span class="params">(Semaphore semaphore)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.semaphore = semaphore;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();</span><br><span class="line">          System.out.println(<span class="string">&quot;Executed!&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，上面的代码，更侧重的是演示 Semaphore 的功能以及局限性，其实有很多线程编程中的反实践，比如使用了 sleep 来协调任务执行，而且使用轮询调用 availalePermits 来检测信号量获取情况，这都是很低效并且脆弱的，通常只是用在测试或者诊断场景。</p>
<p>总的来说，我们可以看出 Semaphore 就是个<strong>计数器，其基本逻辑基于 acquire&#x2F;release</strong>，并没有太复杂的同步逻辑。</p>
<p>如果 Semaphore 的数值被初始化为 1，那么一个线程就可以通过 acquire 进入互斥状态，本质上和互斥锁是非常相似的。但是区别也非常明显，比如互斥锁是有持有者的，而对于 Semaphore 这种计数器结构，虽然有类似功能，但其实不存在真正意义的持有者，除非我们进行扩展包装。</p>
<p>下面，来看看 CountDownLatch 和 CyclicBarrier，它们的行为有一定的相似度，经常会被考察二者有什么区别，我来简单总结一下。</p>
<ul>
<li>CountDownLatch 是不可以重置的，所以无法重用；而 CyclicBarrier 则没有这种限制，可以重用。</li>
<li>CountDownLatch 的基本操作组合是 countDown&#x2F;await。调用 await 的线程阻塞等待 countDown 足够的次数，不管你是在一个线程还是多个线程里 countDown，只要次数足够即可。所以就像 Brain Goetz 说过的，CountDownLatch 操作的是事件。</li>
<li>CyclicBarrier 的基本操作组合，则就是 await，当所有的伙伴（parties）都调用了 await，才会继续进行任务，并自动进行重置。<strong>注意</strong>，正常情况下，CyclicBarrier 的重置都是自动发生的，如果我们调用 reset 方法，但还有线程在等待，就会导致等待线程被打扰，抛出 BrokenBarrierException 异常。CyclicBarrier 侧重点是线程，而不是调用事件，它的典型应用场景是用来等待并发线程结束。</li>
</ul>
<p>如果用 CountDownLatch 去实现上面的排队场景，该怎么做呢？假设有 10 个人排队，我们将其分成 5 个人一批，通过 CountDownLatch 来协调批次，你可以试试下面的示例代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatchSample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FirstBatchWorker</span>(latch));</span><br><span class="line">                t.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">              <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SecondBatchWorker</span>(latch));</span><br><span class="line">              t.start();</span><br><span class="line">      &#125;</span><br><span class="line">           <span class="comment">// 注意这里也是演示目的的逻辑，并不是推荐的协调方式</span></span><br><span class="line">      <span class="keyword">while</span> ( latch.getCount() != <span class="number">1</span> )&#123;</span><br><span class="line">              Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Wait for first batch finish&quot;</span>);</span><br><span class="line">      latch.countDown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FirstBatchWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FirstBatchWorker</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.latch = latch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;First batch executed!&quot;</span>);</span><br><span class="line">          latch.countDown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondBatchWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SecondBatchWorker</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.latch = latch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          latch.await();</span><br><span class="line">          System.out.println(<span class="string">&quot;Second batch executed!&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch 的调度方式相对简单，后一批次的线程进行 await，等待前一批 countDown 足够多次。这个例子也从侧面体现出了它的局限性，虽然它也能够支持 10 个人排队的情况，但是因为不能重用，如果要支持更多人排队，就不能依赖一个 CountDownLatch 进行了。其编译运行输出如下：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/46c88c7d8e0507465bddb677e4eac5b9-20221031211303-0y18ajn.png" alt="img"></p>
<p>在实际应用中的条件依赖，往往没有这么别扭，CountDownLatch 用于线程间等待操作结束是非常简单普遍的用法。通过 countDown&#x2F;await 组合进行通信是很高效的，通常不建议使用例子里那个循环等待方式。</p>
<p>如果用 CyclicBarrier 来表达这个场景呢？我们知道 CyclicBarrier 其实反映的是线程并行运行时的协调，在下面的示例里，从逻辑上，5 个工作线程其实更像是代表了 5 个可以就绪的空车，而不再是 5 个乘客，对比前面 CountDownLatch 的例子更有助于我们区别它们的抽象模型，请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierSample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;Action...GO again!&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">          <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">CyclicWorker</span>(barrier));</span><br><span class="line">          t.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">CyclicWorker</span><span class="params">(CyclicBarrier barrier)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.barrier = barrier;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span> ; i++)&#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;Executed!&quot;</span>);</span><br><span class="line">                  barrier.await();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让输出更能表达运行时序，我使用了 CyclicBarrier 特有的 barrierAction，当屏障被触发时，Java 会自动调度该动作。因为 CyclicBarrier 会<strong>自动</strong>进行重置，所以这个逻辑其实可以非常自然的支持更多排队人数。其编译输出如下：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/eff56d3219ce5493ecacc70a168b2b9f-20221031211303-kpidh6x.png" alt="img"></p>
<p>Java 并发类库还提供了<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Phaser.html">Phaser</a>，功能与 CountDownLatch 很接近，但是它允许线程动态地注册到 Phaser 上面，而 CountDownLatch 显然是不能动态设置的。Phaser 的设计初衷是，实现多个线程类似步骤、阶段场景的协调，线程注册等待屏障条件触发，进而协调彼此间行动，具体请参考这个<a href="http://www.baeldung.com/java-phaser">例子</a>。</p>
<p>接下来，我来梳理下并发包里提供的线程安全 Map、List 和 Set。首先，请参考下面的类图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/35390aa8a6e6f9c92fda086a1b95b457-20221031211303-hw8ex54.png" alt="img"></p>
<p>你可以看到，总体上种类和结构还是比较简单的，如果我们的应用侧重于 Map 放入或者获取的速度，而不在乎顺序，大多推荐使用 ConcurrentHashMap，反之则使用 ConcurrentSkipListMap；如果我们需要对大量数据进行非常频繁地修改，ConcurrentSkipListMap 也可能表现出优势。</p>
<p>我在前面的专栏，谈到了普通无顺序场景选择 HashMap，有顺序场景则可以选择类似 TreeMap 等，但是为什么并发容器里面没有 ConcurrentTreeMap 呢？</p>
<p>这是因为 TreeMap 要实现高效的线程安全是非常困难的，它的实现基于复杂的红黑树。为保证访问效率，当我们插入或删除节点时，会移动节点进行平衡操作，这导致在并发场景中难以进行合理粒度的同步。而 SkipList 结构则要相对简单很多，通过层次结构提高访问速度，虽然不够紧凑，空间使用有一定提高（O(nlogn)），但是在增删元素时线程安全的开销要好很多。为了方便你理解 SkipList 的内部结构，我画了一个示意图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/63b94b5b1d002bb191c75d2c48af767b-20221031211303-9mz4ih6.png" alt="img"></p>
<p>关于两个 CopyOnWrite 容器，其实 CopyOnWriteArraySet 是通过包装了 CopyOnWriteArrayList 来实现的，所以在学习时，我们可以专注于理解一种。</p>
<p>首先，CopyOnWrite 到底是什么意思呢？它的原理是，任何修改操作，如 add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全。请看下面的代码片段，我进行注释的地方，可以清晰地理解其逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      Object[] elements = getArray();</span><br><span class="line">      <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">           <span class="comment">// 拷贝</span></span><br><span class="line">      Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">      newElements[len] = e;</span><br><span class="line">           <span class="comment">// 替换</span></span><br><span class="line">      setArray(newElements);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">  array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这种数据结构，相对比较适合读多写少的操作，不然修改的开销还是非常明显的。</p>
<p>今天我对 Java 并发包进行了总结，并且结合实例分析了各种同步结构和部分线程安全容器，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>18 什么情况下Java程序会产生死锁？如何定位、修复？</title>
    <url>/2024/09/22/2024-09-22-18-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8BJava%E7%A8%8B%E5%BA%8F%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E3%80%81%E4%BF%AE%E5%A4%8D%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="18-什么情况下Java程序会产生死锁？如何定位、修复？"><a href="#18-什么情况下Java程序会产生死锁？如何定位、修复？" class="headerlink" title="18 什么情况下Java程序会产生死锁？如何定位、修复？"></a>18 什么情况下Java程序会产生死锁？如何定位、修复？</h1><p>今天，我会介绍一些日常开发中类似线程死锁等问题的排查经验，并选择一两个我自己修复过或者诊断过的核心类库死锁问题作为例子，希望不仅能在面试时，包括在日常工作中也能对你有所帮助。</p>
<p>今天我要问你的问题是，<strong>什么情况下 Java 程序会产生死锁？如何定位、修复？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</p>
<p>你可以利用下面的示例图理解基本的死锁问题：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/ea88719ec112dead21334034c9ef8a6c-20221031210709-xg3qh6v.png" alt="img"></p>
<p>定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。</p>
<p>如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题偏向于实用场景，大部分死锁本身并不难定位，掌握基本思路和工具使用，理解线程相关的基本概念，比如各种线程状态和同步、锁、Latch 等并发工具，就已经足够解决大多数问题了。</p>
<p>针对死锁，面试官可以深入考察：</p>
<ul>
<li>抛开字面上的概念，让面试者写一个可能死锁的程序，顺便也考察下基本的线程编程。</li>
<li>诊断死锁有哪些工具，如果是分布式环境，可能更关心能否用 API 实现吗？</li>
<li>后期诊断死锁还是挺痛苦的，经常加班，如何在编程中尽量避免一些典型场景的死锁，有其他工具辅助吗？</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>在分析开始之前，先以一个基本的死锁程序为例，我在这里只用了两个嵌套的 synchronized 去获取锁，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockSample</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String first;</span><br><span class="line">  <span class="keyword">private</span> String second;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DeadLockSample</span><span class="params">(String name, String first, String second)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(name);</span><br><span class="line">      <span class="built_in">this</span>.first = first;</span><br><span class="line">      <span class="built_in">this</span>.second = second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (first) &#123;</span><br><span class="line">          System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; obtained: &quot;</span> + first);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">              <span class="keyword">synchronized</span> (second) &#123;</span><br><span class="line">                  System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; obtained: &quot;</span> + second);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="comment">// Do nothing</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">      <span class="type">DeadLockSample</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockSample</span>(<span class="string">&quot;Thread1&quot;</span>, lockA, lockB);</span><br><span class="line">      <span class="type">DeadLockSample</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockSample</span>(<span class="string">&quot;Thread2&quot;</span>, lockB, lockA);</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t1.join();</span><br><span class="line">      t2.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序编译执行后，几乎每次都可以重现死锁，请看下面截取的输出。另外，这里有个比较有意思的地方，为什么我先调用 Thread1 的 start，但是 Thread2 却先打印出来了呢？这就是因为线程调度依赖于（操作系统）调度器，虽然你可以通过优先级之类进行影响，但是具体情况是不确定的。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/869f3a3d7b759fbfb794f8c81047f30e-20221031210709-e1jhunr.png" alt="img"></p>
<p>下面来模拟问题定位，我就选取最常见的 jstack，其他一些类似 JConsole 等图形化的工具，请自行查找。</p>
<p>首先，可以使用 jps 或者系统的 ps 命令、任务管理器等工具，确定进程 ID。</p>
<p>其次，调用 jstack 获取线程栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;JAVA_HOME&#125;\bin\jstack your_pid</span><br></pre></td></tr></table></figure>

<p>然后，分析得到的输出，具体片段如下：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/1fcc1a521b801a5f7428d5229525a38b-20221031210709-5y82n89.png" alt="img"></p>
<p>最后，结合代码分析线程栈信息。上面这个输出非常明显，找到处于 BLOCKED 状态的线程，按照试图获取（waiting）的锁 ID（请看我标记为相同颜色的数字）查找，很快就定位问题。 jstack 本身也会把类似的简单死锁抽取出来，直接打印出来。</p>
<p>在实际应用中，类死锁情况未必有如此清晰的输出，但是总体上可以理解为：</p>
<p><strong>区分线程状态 -&gt; 查看等待目标 -&gt; 对比 Monitor 等持有状态</strong></p>
<p>所以，理解线程基本状态和并发相关元素是定位问题的关键，然后配合程序调用栈结构，基本就可以定位到具体的问题代码。</p>
<p>如果我们是开发自己的管理工具，需要用更加程序化的方式扫描服务进程、定位死锁，可以考虑使用 Java 提供的标准管理 API，<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/management/ThreadMXBean.html#findDeadlockedThreads--">ThreadMXBean</a>，其直接就提供了 findDeadlockedThreads() 方法用于定位。为方便说明，我修改了 DeadLockSample，请看下面的代码片段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">ThreadMXBean</span> <span class="variable">mbean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">dlCheck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="type">long</span>[] threadIds = mbean.findDeadlockedThreads();</span><br><span class="line">          <span class="keyword">if</span> (threadIds != <span class="literal">null</span>) &#123;</span><br><span class="line">                     ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);</span><br><span class="line">                     System.out.println(<span class="string">&quot;Detected deadlock threads:&quot;</span>);</span><br><span class="line">              <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                  System.out.println(threadInfo.getThreadName());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="type">ScheduledExecutorService</span> <span class="variable">scheduler</span> <span class="operator">=</span>Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 稍等5秒，然后每10秒进行一次死锁扫描</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(dlCheck, <span class="number">5L</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 死锁样例代码…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新编译执行，你就能看到死锁被定位到的输出。在实际应用中，就可以据此收集进一步的信息，然后进行预警等后续处理。但是要注意的是，对线程进行快照本身是一个相对重量级的操作，还是要慎重选择频度和时机。</p>
<p><strong>如何在编程中尽量预防死锁呢？</strong></p>
<p>首先，我们来总结一下前面例子中死锁的产生包含哪些基本元素。基本上死锁的发生是因为：</p>
<ul>
<li>互斥条件，类似 Java 中 Monitor 都是独占的，要么是我用，要么是你用。</li>
<li>互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占。</li>
<li>循环依赖关系，两个或者多个个体之间出现了锁的链条环。</li>
</ul>
<p>所以，我们可以据此分析可能的避免死锁的思路和方法。</p>
<p><strong>第一种方法</strong></p>
<p>如果可能的话，尽量避免使用多个锁，并且只有需要时才持有锁。否则，即使是非常精通并发编程的工程师，也难免会掉进坑里，嵌套的 synchronized 或者 lock 非常容易出问题。</p>
<p>我举个<a href="https://bugs.openjdk.java.net/browse/JDK-8198928">例子</a>， Java NIO 的实现代码向来以锁多著称，一个原因是，其本身模型就非常复杂，某种程度上是不得不如此；另外是在设计时，考虑到既要支持阻塞模式，又要支持非阻塞模式。直接结果就是，一些基本操作如 connect，需要操作三个锁以上，在最近的一个 JDK 改进中，就发生了死锁现象。</p>
<p>我将其简化为下面的伪代码，问题是暴露在 HTTP&#x2F;2 客户端中，这是个非常现代的反应式风格的 API，非常推荐学习使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Thread HttpClient-6-SelectorManager:</span></span><br><span class="line">readLock.lock();</span><br><span class="line">writeLock.lock();</span><br><span class="line"><span class="comment">// 持有readLock/writeLock，调用close（）需要获得closeLock</span></span><br><span class="line">close();</span><br><span class="line"><span class="comment">// Thread HttpClient-6-Worker-2 持有closeLock</span></span><br><span class="line">implCloseSelectableChannel (); <span class="comment">//想获得readLock</span></span><br></pre></td></tr></table></figure>

<p>在 close 发生时， HttpClient-6-SelectorManager 线程持有 readLock&#x2F;writeLock，试图获得 closeLock；与此同时，另一个 HttpClient-6-Worker-2 线程，持有 closeLock，试图获得 readLock，这就不可避免地进入了死锁。</p>
<p>这里比较难懂的地方在于，closeLock 的持有状态（就是我标记为绿色的部分）<strong>并没有在线程栈中显示出来</strong>，请参考我在下图中标记的部分。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/b7961a84838b5429a8f59826b91ed724-20221031210709-qc1hdu2.png" alt="img"></p>
<p>更加具体来说，请查看<a href="http://hg.openjdk.java.net/jdk/jdk/file/ce06058197a4/src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java">SocketChannelImpl</a>的 663 行，对比 implCloseSelectableChannel() 方法实现和<a href="http://hg.openjdk.java.net/jdk/jdk/file/ce06058197a4/src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java">AbstractInterruptibleChannel.close()</a>在 109 行的代码，这里就不展示代码了。</p>
<p>所以，从程序设计的角度反思，如果我们赋予一段程序太多的职责，出现“既要…又要…”的情况时，可能就需要我们审视下设计思路或目的是否合理了。对于类库，因为其基础、共享的定位，比应用开发往往更加令人苦恼，需要仔细斟酌之间的平衡。</p>
<p><strong>第二种方法</strong></p>
<p>如果必须使用多个锁，尽量设计好锁的获取顺序，这个说起来简单，做起来可不容易，你可以参看著名的<a href="https://en.wikipedia.org/wiki/Banker's_algorithm">银行家算法</a>。</p>
<p>一般的情况，我建议可以采取些简单的辅助手段，比如：</p>
<ul>
<li>将对象（方法）和锁之间的关系，用图形化的方式表示分别抽取出来，以今天最初讲的死锁为例，因为是调用了同一个线程所以更加简单。</li>
</ul>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/1e23562b6ff34206b11c5ec07608fb59-20221031210709-rned4th.png" alt="img"></p>
<ul>
<li>然后根据对象之间组合、调用的关系对比和组合，考虑可能调用时序。</li>
</ul>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/ee413b86e8775c63e7947955646db975-20221031210709-53l8a82.png" alt="img"></p>
<ul>
<li>按照可能时序合并，发现可能死锁的场景。</li>
</ul>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/9bbad67e205e54e8f7ec8ad37872a9e7-20221031210709-ywya8bb.png" alt="img"></p>
<p><strong>第三种方法</strong></p>
<p>使用带超时的方法，为程序带来更多可控性。</p>
<p>类似 Object.wait(…) 或者 CountDownLatch.await(…)，都支持所谓的 timed_wait，我们完全可以就不假定该锁一定会获得，指定超时时间，并为无法得到锁时准备退出逻辑。</p>
<p>并发 Lock 实现，如 ReentrantLock 还支持非阻塞式的获取锁操作 tryLock()，这是一个插队行为（barging），并不在乎等待的公平性，如果执行时对象恰好没有被独占，则直接获取锁。有时，我们希望条件允许就尝试插队，不然就按照现有公平性规则等待，一般采用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock() || lock.tryLock(timeout, unit)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四种方法</strong></p>
<p>业界也有一些其他方面的尝试，比如通过静态代码分析（如 FindBugs）去查找固定的模式，进而定位可能的死锁或者竞争情况。实践证明这种方法也有一定作用，请参考<a href="https://plugins.jetbrains.com/plugin/3847-findbugs-idea">相关文档</a>。</p>
<p>除了典型应用中的死锁场景，其实还有一些更令人头疼的死锁，比如类加载过程发生的死锁，尤其是在框架大量使用自定义类加载时，因为往往不是在应用本身的代码库中，jstack 等工具也不见得能够显示全部锁信息，所以处理起来比较棘手。对此，Java 有<a href="https://plugins.jetbrains.com/plugin/3847-findbugs-idea">官方文档</a>进行了详细解释，并针对特定情况提供了相应 JVM 参数和基本原则。</p>
<p>今天，我从样例程序出发，介绍了死锁产生原因，并帮你熟悉了排查死锁基本工具的使用和典型思路，最后结合实例介绍了实际场景中的死锁分析方法与预防措施，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>17 一个线程两次调用start()方法会出现什么情况？</title>
    <url>/2024/09/22/2024-09-22-17-%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start()%E6%96%B9%E6%B3%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="17-一个线程两次调用start-方法会出现什么情况？"><a href="#17-一个线程两次调用start-方法会出现什么情况？" class="headerlink" title="17 一个线程两次调用start()方法会出现什么情况？"></a>17 一个线程两次调用start()方法会出现什么情况？</h1><p>今天我们来深入聊聊线程，相信大家对于线程这个概念都不陌生，它是 Java 并发的基础元素，理解、操纵、诊断线程是 Java 工程师的必修课，但是你真的掌握线程了吗？</p>
<p>今天我要问你的问题是，<strong>一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException，这是一种运行时异常，多次调用 start 被认为是编程错误。</p>
<p>关于线程生命周期的不同状态，在 Java 5 以后，线程状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：</p>
<ul>
<li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。</li>
<li>就绪（RUNNABLE），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。</li>
<li>在其他一些分析中，会额外区分一种状态 RUNNING，但是从 Java API 的角度，并不能表示出来。</li>
<li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li>
<li>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。</li>
<li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本，如下面示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<ul>
<li>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。</li>
</ul>
<p>在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题可以算是个常见的面试热身题目，前面的给出的典型回答，算是对基本状态和简单流转的一个介绍，如果觉得还不够直观，我在下面分析会对比一个状态图进行介绍。总的来说，理解线程对于我们日常开发或者诊断分析，都是不可或缺的基础。</p>
<p>面试官可能会以此为契机，从各种不同角度考察你对线程的掌握：</p>
<ul>
<li>相对理论一些的面试官可以会问你线程到底是什么以及 Java 底层实现方式。</li>
<li>线程状态的切换，以及和锁等并发工具类的互动。</li>
<li>线程编程时容易踩的坑与建议等。</li>
</ul>
<p>可以看出，仅仅是一个线程，就有非常多的内容需要掌握。我们选择重点内容，开始进入详细分析。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们来整体看一下线程是什么？</p>
<p>从操作系统的角度，可以简单认为，线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。</p>
<p>在具体实现中，线程还分为内核线程、用户线程，Java 的线程实现其实是与虚拟机相关的。对于我们最熟悉的 Sun&#x2F;Oracle JDK，其线程也经历了一个演进过程，基本上在 Java 1.2 之后，JDK 已经抛弃了所谓的<a href="https://en.wikipedia.org/wiki/Green_threads">Green Thread</a>，也就是用户调度的线程，现在的模型是一对一映射到操作系统内核线程。</p>
<p>如果我们来看 Thread 的源码，你会发现其基本操作逻辑大都是以 JNI 形式调用的本地代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>这种实现有利有弊，总体上来说，Java 语言得益于精细粒度的线程和相关的并发操作，其构建高扩展性的大型应用的能力已经毋庸置疑。但是，其复杂性也提高了并发编程的门槛，近几年的 Go 语言等提供了协程（<a href="https://en.wikipedia.org/wiki/Coroutine">coroutine</a>），大大提高了构建并发应用的效率。于此同时，Java 也在<a href="http://openjdk.java.net/projects/loom/">Loom</a>项目中，孕育新的类似轻量级用户线程（Fiber）等机制，也许在不久的将来就可以在新版 JDK 中使用到它。</p>
<p>下面，我来分析下线程的基本操作。如何创建线程想必你已经非常熟悉了，请看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;System.out.println(<span class="string">&quot;Hello World!&quot;</span>);&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">myThread.start();</span><br><span class="line">myThread.join();</span><br></pre></td></tr></table></figure>

<p>我们可以直接扩展 Thread 类，然后实例化。但在本例中，我选取了另外一种方式，就是实现一个 Runnable，将代码逻放在 Runnable 中，然后构建 Thread 并启动（start），等待结束（join）。</p>
<p>Runnable 的好处是，不会受 Java 不支持类多继承的限制，重用代码实现，当我们需要重复执行相应逻辑时优点明显。而且，也能更好的与现代 Java 并发库中的 Executor 之类框架结合使用，比如将上面 start 和 join 的逻辑完全写成下面的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>)</span><br><span class="line">.submit(task)</span><br><span class="line">.get();</span><br></pre></td></tr></table></figure>

<p>这样我们就不用操心线程的创建和管理，也能利用 Future 等机制更好地处理执行结果。线程生命周期通常和业务之间没有本质联系，混淆实现需求和业务需求，就会降低开发的效率。</p>
<p>从线程生命周期的状态开始展开，那么在 Java 编程中，有哪些因素可能影响线程的状态呢？主要有：</p>
<ul>
<li>线程自身的方法，除了 start，还有多个 join 方法，等待线程结束；yield 是告诉调度器，主动让出 CPU；另外，就是一些已经被标记为过时的 resume、stop、suspend 之类，据我所知，在 JDK 最新版本中，destory&#x2F;stop 方法将被直接移除。</li>
<li>基类 Object 提供了一些基础的 wait&#x2F;notify&#x2F;notifyAll 方法。如果我们持有某个对象的 Monitor 锁，调用 wait 会让当前线程处于等待状态，直到其他线程 notify 或者 notifyAll。所以，本质上是提供了 Monitor 的获取和释放的能力，是基本的线程间通信方式。</li>
<li>并发类库中的工具，比如 CountDownLatch.await() 会让当前线程进入等待状态，直到 latch 被基数为 0，这可以看作是线程间通信的 Signal。</li>
</ul>
<p>我这里画了一个状态和方法之间的对应图：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/3169b7ca899afeb0359f132fb77c29dc-20221031205928-q1vpev2.png" alt="img"></p>
<p>Thread 和 Object 的方法，听起来简单，但是实际应用中被证明非常晦涩、易错，这也是为什么 Java 后来又引入了并发包。总的来说，有了并发包，大多数情况下，我们已经不再需要去调用 wait&#x2F;notify 之类的方法了。</p>
<p>前面谈了不少理论，下面谈谈线程 API 使用，我会侧重于平时工作学习中，容易被忽略的一些方面。</p>
<p>先来看看守护线程（Daemon Thread），有的时候应用中需要一个长期驻留的服务程序，但是不希望其影响应用退出，就可以将其设置为守护线程，如果 JVM 发现只有守护线程存在时，将结束进程，具体可以参考下面代码段。<strong>注意，必须在线程启动之前设置。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure>

<p>再来看看<a href="https://en.wikipedia.org/wiki/Spurious_wakeup">Spurious wakeup</a>。尤其是在多核 CPU 的系统中，线程等待存在一种可能，就是在没有任何线程广播或者发出信号的情况下，线程就被唤醒，如果处理不当就可能出现诡异的并发问题，所以我们在等待条件过程中，建议采用下面模式来书写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">while</span> ( isCondition()) &#123;</span><br><span class="line">waitForAConfition(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐，可能引入bug</span></span><br><span class="line"><span class="keyword">if</span> ( isCondition()) &#123;</span><br><span class="line">waitForAConfition(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread.onSpinWait()，这是 Java 9 中引入的特性。我在【专栏第 16 讲】给你留的思考题中，提到“自旋锁”（spin-wait, busy-waiting），也可以认为其不算是一种锁，而是一种针对短期等待的性能优化技术。“onSpinWait()”没有任何行为上的保证，而是对 JVM 的一个暗示，JVM 可能会利用 CPU 的 pause 指令进一步提高性能，性能特别敏感的应用可以关注。</p>
<p>再有就是慎用<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ThreadLocal.html">ThreadLocal</a>，这是 Java 提供的一种保存线程私有信息的机制，因为其在整个线程生命周期内有效，所以可以方便地在一个线程关联的不同业务模块之间传递信息，比如事务 ID、Cookie 等上下文相关信息。</p>
<p>它的实现结构，可以参考<a href="http://hg.openjdk.java.net/jdk/jdk/file/ee8524126794/src/java.base/share/classes/java/lang/ThreadLocal.java">源码</a>，数据存储于线程相关的 ThreadLocalMap，其内部条目是弱引用，如下面片段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">      <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">      Object value;</span><br><span class="line">      Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">          <span class="built_in">super</span>(k);</span><br><span class="line">      value = v;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Key 为 null 时，该条目就变成“废弃条目”，相关“value”的回收，往往依赖于几个关键点，即 set、remove、rehash。</p>
<p>下面是 set 的示例，我进行了精简和注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];; …) &#123;</span><br><span class="line">      <span class="comment">//…</span></span><br><span class="line">      <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 替换废弃条目</span></span><br><span class="line">          replaceStaleEntry(key, value, i);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">  tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">  <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line"><span class="comment">//  扫描并清理发现的废弃条目，并检查容量是否超限</span></span><br><span class="line">  <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">      rehash();<span class="comment">// 清理废弃条目，如果仍然超限，则扩容（加倍）</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>具体的清理逻辑是实现在 cleanSomeSlots 和 expungeStaleEntry 之中，如果你有兴趣可以自行阅读。</p>
<p>结合【专栏第 4 讲】介绍的引用类型，我们会发现一个特别的地方，通常弱引用都会和引用队列配合清理机制使用，但是 ThreadLocal 是个例外，它并没有这么做。</p>
<p>这意味着，废弃项目的回收依赖于显式地触发，否则就要等待线程结束，进而回收相应 ThreadLocalMap！这就是很多 OOM 的来源，所以通常都会建议，应用一定要自己负责 remove，并且不要和线程池配合，因为 worker 线程往往是不会退出的。</p>
<p>今天，我介绍了线程基础，分析了生命周期中的状态和各种方法之间的对应关系，这也有助于我们更好地理解 synchronized 和锁的影响，并介绍了一些需要注意的操作，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
        <tag>start方法</tag>
      </tags>
  </entry>
  <entry>
    <title>16 synchronized底层如何实现？什么是锁的升级、降级？</title>
    <url>/2024/09/22/2024-09-22-16-synchronized%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E3%80%81%E9%99%8D%E7%BA%A7%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="16-synchronized底层如何实现？什么是锁的升级、降级？"><a href="#16-synchronized底层如何实现？什么是锁的升级、降级？" class="headerlink" title="16 synchronized底层如何实现？什么是锁的升级、降级？"></a>16 synchronized底层如何实现？什么是锁的升级、降级？</h1><p>我在【上一讲】对比和分析了 synchronized 和 ReentrantLock，算是专栏进入并发编程阶段的热身，相信你已经对线程安全，以及如何使用基本的同步机制有了基础，今天我们将深入了解 synchronize 底层机制，分析其他锁实现和应用场景。</p>
<p>今天我要问你的问题是 ，<strong>synchronized 底层如何实现？什么是锁的升级、降级？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>在回答这个问题前，先简单复习一下上一讲的知识点。synchronized 代码块是由一对儿 monitorenter&#x2F;monitorexit 指令实现的，Monitor 对象是同步的基本实现<a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-8.html#d5e13622">单元</a>。</p>
<p>在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。</p>
<p>现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
<p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p>
<p>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（<a href="https://en.wikipedia.org/wiki/Compare-and-swap">compare and swap</a>），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p>
<p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>
<p>我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当 JVM 进入安全点（<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">SafePoint</a>）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题主要是考察你对 Java 内置锁实现的掌握，也是并发的经典题目。我在前面给出的典型回答，涵盖了一些基本概念。如果基础不牢，有些概念理解起来就比较晦涩，我建议还是尽量理解和掌握，即使有不懂的也不用担心，在后续学习中还会逐步加深认识。</p>
<p>我个人认为，能够基础性地理解这些概念和机制，其实对于大多数并发编程已经足够了，毕竟大部分工程师未必会进行更底层、更基础的研发，很多时候解决的是知道与否，真正的提高还要靠实践踩坑。</p>
<p>后面我会进一步分析：</p>
<ul>
<li>从源码层面，稍微展开一些 synchronized 的底层实现，并补充一些上面答案中欠缺的细节，有同学反馈这部分容易被问到。如果你对 Java 底层源码有兴趣，但还没有找到入手点，这里可以成为一个切入点。</li>
<li>理解并发包中 java.util.concurrent.lock 提供的其他锁实现，毕竟 Java 可不是只有 ReentrantLock 一种显式的锁类型，我会结合代码分析其使用。</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>我在【上一讲】提到过 synchronized 是 JVM 内部的 Intrinsic Lock，所以偏斜锁、轻量级锁、重量级锁的代码实现，并不在核心类库部分，而是在 JVM 的代码中。</p>
<p>Java 代码运行可能是解释模式也可能是编译模式（如果不记得，请复习【专栏第 1 讲】），所以对应的同步逻辑实现，也会分散在不同模块下，比如，解释器版本就是：<a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/interpreter/interpreterRuntime.cpp">src&#x2F;hotspot&#x2F;share&#x2F;interpreter&#x2F;interpreterRuntime.cpp</a></p>
<p>为了简化便于理解，我这里会专注于通用的基类实现：<a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/">src&#x2F;hotspot&#x2F;share&#x2F;runtime&#x2F;</a></p>
<p>另外请注意，链接指向的是最新 JDK 代码库，所以可能某些实现与历史版本有所不同。</p>
<p>首先，synchronized 的行为是 JVM runtime 的一部分，所以我们需要先找到 Runtime 相关的功能实现。通过在代码中查询类似“monitor_enter”或“Monitor Enter”，很直观的就可以定位到：</p>
<ul>
<li><a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/sharedRuntime.cpp">sharedRuntime.cpp</a>&#x2F;hpp，它是解释器和编译器运行时的基类。</li>
<li><a href="https://hg.openjdk.java.net/jdk/jdk/file/896e80158d35/src/hotspot/share/runtime/synchronizer.cpp">synchronizer.cpp</a>&#x2F;hpp，JVM 同步相关的各种基础逻辑。</li>
</ul>
<p>在 sharedRuntime.cpp 中，下面代码体现了 synchronized 的主要逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Handle <span class="title function_">h_obj</span><span class="params">(THREAD, obj)</span>;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, lock, <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, lock, CHECK);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其实现可以简单进行分解：</p>
<ul>
<li>UseBiasedLocking 是一个检查，因为，在 JVM 启动时，我们可以指定是否开启偏斜锁。</li>
</ul>
<p>偏斜锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，只有当存在较多不会真正竞争的 synchronized 块儿时，才能体现出明显改善。实践中对于偏斜锁的一直是有争议的，有人甚至认为，当你需要大量使用并发类库时，往往意味着你不需要偏斜锁。从具体选择来看，我还是建议需要在实践中进行测试，根据结果再决定是否使用。</p>
<p>还有一方面是，偏斜锁会延缓 JIT 预热的进程，所以很多性能测试中会显式地关闭偏斜锁，命令如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure>

<ul>
<li>fast_enter 是我们熟悉的完整锁获取路径，slow_enter 则是绕过偏斜锁，直接进入轻量级锁获取逻辑。</li>
</ul>
<p>那么 fast_enter 是如何实现的呢？同样是通过在代码库搜索，我们可以定位到 synchronizer.cpp。 类似 fast_enter 这种实现，解释器或者动态编译器，都是拷贝这段基础逻辑，所以如果我们修改这部分逻辑，要保证一致性。这部分代码是非常敏感的，微小的问题都可能导致死锁或者正确性问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock,</span><br><span class="line">                                  bool attempt_rebias, TRAPS) &#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::<span class="type">Condition</span> <span class="variable">cond</span> <span class="operator">=</span> BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">assert</span>(!attempt_rebias, <span class="string">&quot;can not rebias toward VM thread&quot;</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">assert</span>(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  slow_enter(obj, lock, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我来分析下这段逻辑实现：</p>
<ul>
<li><a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/biasedLocking.cpp">biasedLocking</a>定义了偏斜锁相关操作，revoke_and_rebias 是获取偏斜锁的入口方法，revoke_at_safepoint 则定义了当检测到安全点时的处理逻辑。</li>
<li>如果获取偏斜锁失败，则进入 slow_enter。</li>
<li>这个方法里面同样检查是否开启了偏斜锁，但是从代码路径来看，其实如果关闭了偏斜锁，是不会进入这个方法的，所以算是个额外的保障性检查吧。</li>
</ul>
<p>另外，如果你仔细查看<a href="https://hg.openjdk.java.net/jdk/jdk/file/896e80158d35/src/hotspot/share/runtime/synchronizer.cpp">synchronizer.cpp</a>里，会发现不仅仅是 synchronized 的逻辑，包括从本地代码，也就是 JNI，触发的 Monitor 动作，全都可以在里面找到（jni_enter&#x2F;jni_exit）。</p>
<p>关于<a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/biasedLocking.cpp">biasedLocking</a>的更多细节我就不展开了，明白它是通过 CAS 设置 Mark Word 就完全够用了，对象头中 Mark Word 的结构，可以参考下图：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/b1221c308d2aaf13d0d677033ee406fc-20221031204202-2dzxqac.png" alt="img"></p>
<p>顺着锁升降级的过程分析下去，偏斜锁到轻量级锁的过程是如何实现的呢？</p>
<p>我们来看看 slow_enter 到底做了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  <span class="type">markOop</span> <span class="variable">mark</span> <span class="operator">=</span> obj-&gt;mark();</span><br><span class="line"> <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">       <span class="comment">// 将目前的Mark Word复制到Displaced Header上</span></span><br><span class="line">  lock-&gt;set_displaced_header(mark);</span><br><span class="line">  <span class="comment">// 利用CAS设置对象的Mark Word</span></span><br><span class="line">    <span class="keyword">if</span> (mark == obj()-&gt;cas_set_mark((markOop) lock, mark)) &#123;</span><br><span class="line">      TEVENT(slow_enter: release stacklock);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查存在竞争</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp;</span><br><span class="line">             THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">  <span class="comment">// 清除</span></span><br><span class="line">    lock-&gt;set_displaced_header(NULL);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 重置Displaced Header</span></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD,</span><br><span class="line">                            obj(),</span><br><span class="line">                              inflate_cause_monitor_enter)-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请结合我在代码中添加的注释，来理解如何从试图获取轻量级锁，逐步进入锁膨胀的过程。你可以发现这个处理逻辑，和我在这一讲最初介绍的过程是十分吻合的。</p>
<ul>
<li>设置 Displaced Header，然后利用 cas_set_mark 设置对象 Mark Word，如果成功就成功获取轻量级锁。</li>
<li>否则 Displaced Header，然后进入锁膨胀阶段，具体实现在 inflate 方法中。</li>
</ul>
<p>今天就不介绍膨胀的细节了，我这里提供了源代码分析的思路和样例，考虑到应用实践，再进一步增加源代码解读意义不大，有兴趣的同学可以参考我提供的<a href="http://hg.openjdk.java.net/jdk/jdk/file/896e80158d35/src/hotspot/share/runtime/synchronizer.cpp">synchronizer.cpp</a>链接，例如：</p>
<ul>
<li><strong>deflate_idle_monitors</strong> 是分析<strong>锁降级</strong>逻辑的入口，这部分行为还在进行持续改进，因为其逻辑是在安全点内运行，处理不当可能拖长 JVM 停顿（STW，stop-the-world）的时间。</li>
<li>fast_exit 或者 slow_exit 是对应的锁释放逻辑。</li>
</ul>
<p>前面分析了 synchronized 的底层实现，理解起来有一定难度，下面我们来看一些相对轻松的内容。 我在上一讲对比了 synchronized 和 ReentrantLock，Java 核心类库中还有其他一些特别的锁类型，具体请参考下面的图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/f5753a4695fd771f8178120858086811-20221031204202-sevhy62.png" alt="img"></p>
<p>你可能注意到了，这些锁竟然不都是实现了 Lock 接口，ReadWriteLock 是一个单独的接口，它通常是代表了一对儿锁，分别对应只读和写操作，标准类库中提供了再入版本的读写锁实现（ReentrantReadWriteLock），对应的语义和 ReentrantLock 比较相似。</p>
<p>StampedLock 竟然也是个单独的类型，从类图结构可以看出它是不支持再入性的语义的，也就是它不是以持有锁的线程为单位。</p>
<p>为什么我们需要读写锁（ReadWriteLock）等其他锁呢？</p>
<p>这是因为，虽然 ReentrantLock 和 synchronized 简单实用，但是行为上有一定局限性，通俗点说就是“太霸道”，要么不占，要么独占。实际应用场景中，有的时候不需要大量竞争的写操作，而是以并发读取为主，如何进一步优化并发操作的粒度呢？</p>
<p>Java 并发包提供的读写锁等扩展了锁的能力，它所基于的原理是多个读操作是不需要互斥的，因为读操作并不会更改数据，所以不存在互相干扰。而写操作则会导致并发一致性的问题，所以写线程之间、读写线程之间，需要精心设计的互斥逻辑。</p>
<p>下面是一个基于读写锁实现的数据结构，当数据量较大，并发读多、并发写少的时候，能够比纯同步版本凸显出优势。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RWSample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; m = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">      r.lock();</span><br><span class="line">      System.out.println(<span class="string">&quot;读锁锁定！&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> m.get(key);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          r.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(String key, String entry)</span> &#123;</span><br><span class="line">      w.lock();</span><br><span class="line">  System.out.println(<span class="string">&quot;写锁锁定！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m.put(key, entry);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在运行过程中，如果读锁试图锁定时，写锁是被某个线程持有，读锁将无法获得，而只好等待对方操作结束，这样就可以自动保证不会读取到有争议的数据。</p>
<p>读写锁看起来比 synchronized 的粒度似乎细一些，但在实际应用中，其表现也并不尽如人意，主要还是因为相对比较大的开销。</p>
<p>所以，JDK 在后期引入了 StampedLock，在提供类似读写锁的同时，还支持优化读模式。优化读基于假设，大多数情况下读操作并不会和写操作冲突，其逻辑是先试着读，然后通过 validate 方法确认是否进入了写模式，如果没有进入，就成功避免了开销；如果进入，则尝试获取读锁。请参考我下面的样例代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedSample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">mutate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          write();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          sl.unlockWrite(stamp);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Data <span class="title function_">access</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead();</span><br><span class="line">      <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> read();</span><br><span class="line">      <span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">          stamp = sl.readLock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              data = read();</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              sl.unlockRead(stamp);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里的 writeLock 和 unLockWrite 一定要保证成对调用。</p>
<p>你可能很好奇这些显式锁的实现机制，Java 并发包内的各种同步工具，不仅仅是各种 Lock，其他的如<a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/Semaphore.html">Semaphore</a>、<a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a>，甚至是早期的<a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/FutureTask.html">FutureTask</a>等，都是基于一种<a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html">AQS</a>框架。</p>
<p>今天，我全面分析了 synchronized 相关实现和内部运行机制，简单介绍了并发包中提供的其他显式锁，并结合样例代码介绍了其使用方法，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>15 synchronized和ReentrantLock有什么区别呢？</title>
    <url>/2024/09/22/2024-09-22-15-synchronized%E5%92%8CReentrantLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="15-synchronized和ReentrantLock有什么区别呢？"><a href="#15-synchronized和ReentrantLock有什么区别呢？" class="headerlink" title="15 synchronized和ReentrantLock有什么区别呢？"></a>15 synchronized和ReentrantLock有什么区别呢？</h1><p>从今天开始，我们将进入 Java 并发学习阶段。软件并发已经成为现代软件开发的基础能力，而 Java 精心设计的高效并发机制，正是构建大规模应用的基础之一，所以考察并发基本功也成为各个公司面试 Java 工程师的必选项。</p>
<p>今天我要问你的问题是，** synchronized 和 ReentrantLock 有什么区别？有人说 synchronized 最慢，这话靠谱吗？**</p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>synchronized 是 Java 内建的同步机制，所以也有人称其为 Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</p>
<p>在 Java 5 以前，synchronized 是仅有的同步手段，在代码中， synchronized 可以用来修饰方法，也可以使用在特定的代码块儿上，本质上 synchronized 方法等同于把方法全部语句用 synchronized 块包起来。</p>
<p>ReentrantLock，通常翻译为再入锁，是 Java 5 提供的锁实现，它的语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。与此同时，ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的细节控制，比如可以控制 fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用 unlock() 方法释放，不然就会一直持有该锁。</p>
<p>synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于 ReentrantLock。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的题目是考察并发编程的常见基础题，我给出的典型回答算是一个相对全面的总结。</p>
<p>对于并发编程，不同公司或者面试官面试风格也不一样，有个别大厂喜欢一直追问你相关机制的扩展或者底层，有的喜欢从实用角度出发，所以你在准备并发编程方面需要一定的耐心。</p>
<p>我认为，锁作为并发的基础工具之一，你至少需要掌握：</p>
<ul>
<li>理解什么是线程安全。</li>
<li>synchronized、ReentrantLock 等机制的基本使用与案例。</li>
</ul>
<p>更进一步，你还需要：</p>
<ul>
<li>掌握 synchronized、ReentrantLock 底层实现；理解锁膨胀、降级；理解偏斜锁、自旋锁、轻量级锁、重量级锁等概念。</li>
<li>掌握并发包中 java.util.concurrent.lock 各种不同实现和案例分析。</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>专栏前面几期穿插了一些并发的概念，有同学反馈理解起来有点困难，尤其对一些并发相关概念比较陌生，所以在这一讲，我也对会一些基础的概念进行补充。</p>
<p>首先，我们需要理解什么是线程安全。</p>
<p>我建议阅读 Brain Goetz 等专家撰写的《Java 并发编程实战》（Java Concurrency in Practice），虽然可能稍显学究，但不可否认这是一本非常系统和全面的 Java 并发编程书籍。按照其中的定义，线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下共享的、可修改的状态的正确性，这里的状态反映在程序中其实可以看作是数据。</p>
<p>换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，进而可以推理出保证线程安全的两个办法：</p>
<ul>
<li>封装：通过封装，我们可以将对象内部状态隐藏、保护起来。</li>
<li>不可变：还记得我们在【专栏第 3 讲】强调的 final 和 immutable 吗，就是这个道理，Java 语言目前还没有真正意义上的原生不可变，但是未来也许会引入。</li>
</ul>
<p>线程安全需要保证几个基本特性：</p>
<ul>
<li><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li>
<li><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li>
<li><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</li>
</ul>
<p>可能有点晦涩，那么我们看看下面的代码段，分析一下原子性需求体现在哪里。这个例子通过取两次数值然后进行对比，来模拟两次对共享状态的操作。</p>
<p>你可以编译并执行，可以看到，仅仅是两个线程的低度并发，就非常容易碰到 former 和 latter 不相等的情况。这是因为，在两次取值的过程中，其他线程可能已经修改了 sharedState。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeSample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> sharedState;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonSafeAction</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (sharedState &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">former</span> <span class="operator">=</span> sharedState++;</span><br><span class="line">          <span class="type">int</span> <span class="variable">latter</span> <span class="operator">=</span> sharedState;</span><br><span class="line">          <span class="keyword">if</span> (former != latter - <span class="number">1</span>) &#123;</span><br><span class="line">              System.out.printf(<span class="string">&quot;Observed data race, former is &quot;</span> +</span><br><span class="line">                      former + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;latter is &quot;</span> + latter);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">ThreadSafeSample</span> <span class="variable">sample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafeSample</span>();</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">              sample.nonSafeAction();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">              sample.nonSafeAction();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      threadA.start();</span><br><span class="line">      threadB.start();</span><br><span class="line">      threadA.join();</span><br><span class="line">      threadB.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是在我的电脑上的运行结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">C:\&gt;c:\jdk<span class="number">-9</span>\bin\java ThreadSafeSample</span><br><span class="line">Observed data race, former is <span class="number">13097</span>, latter is <span class="number">13099</span></span><br></pre></td></tr></table></figure>

<p>将两次赋值过程用 synchronized 保护起来，使用 this 作为互斥单元，就可以避免别的线程并发的去修改 sharedState。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">synchronized (this) &#123;</span><br><span class="line">  <span class="type">int</span> former = sharedState ++;</span><br><span class="line">  <span class="type">int</span> latter = sharedState;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用 javap 反编译，可以看到类似片段，利用 monitorenter&#x2F;monitorexit 对实现了同步的语义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>: astore_1</span><br><span class="line"><span class="number">12</span>: monitorenter</span><br><span class="line"><span class="number">13</span>: aload_0</span><br><span class="line"><span class="number">14</span>: dup</span><br><span class="line"><span class="number">15</span>: getfield    #<span class="number">2</span>                <span class="comment">// Field sharedState:I</span></span><br><span class="line"><span class="number">18</span>: dup_x1</span><br><span class="line">…</span><br><span class="line"><span class="number">56</span>: monitorexit</span><br></pre></td></tr></table></figure>

<p>我会在下一讲，对 synchronized 和其他锁实现的更多底层细节进行深入分析。</p>
<p>代码中使用 synchronized 非常便利，如果用来修饰静态方法，其等同于利用下面代码将方法体囊括进来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (ClassName.class) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看 ReentrantLock。你可能好奇什么是再入？它是表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，这是对锁获取粒度的一个概念，也就是锁的持有是以线程为单位而不是基于调用次数。Java 锁实现强调再入性是为了和 pthread 的行为进行区分。</p>
<p>再入锁可以设置公平性（fairness），我们可在创建再入锁时选择是否是公平的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>这里所谓的公平性是指在竞争场景中，当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程“饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法。</p>
<p>如果使用 synchronized，我们根本<strong>无法进行</strong>公平性的选择，其永远是不公平的，这也是主流操作系统线程调度的选择。通用场景中，公平性未必有想象中的那么重要，Java 默认的调度策略很少会导致 “饥饿”发生。与此同时，若要保证公平性则会引入额外开销，自然会导致一定的吞吐量下降。所以，我建议<strong>只有</strong>当你的程序确实有公平性需要的时候，才有必要指定它。</p>
<p>我们再从日常编码的角度学习下再入锁。为保证锁释放，每一个 lock() 动作，我建议都立即对应一个 try-catch-finally，典型的代码结构如下，这是个良好的习惯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);<span class="comment">// 这里是演示创建公平锁，一般情况不需要。</span></span><br><span class="line">fairLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   fairLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 相比 synchronized，因为可以像普通对象一样使用，所以可以利用其提供的各种便利方法，进行精细的同步操作，甚至是实现 synchronized 难以表达的用例，如：</p>
<ul>
<li>带超时的获取锁尝试。</li>
<li>可以判断是否有线程，或者某个特定线程，在排队等待获取锁。</li>
<li>可以响应中断请求。</li>
<li>…</li>
</ul>
<p>这里我特别想强调<strong>条件变量</strong>（java.util.concurrent.Condition），如果说 ReentrantLock 是 synchronized 的替代选择，Condition 则是将 wait、notify、notifyAll 等操作转化为相应的对象，将复杂而晦涩的同步操作转变为直观可控的对象行为。</p>
<p>条件变量最为典型的应用场景就是标准类库中的 ArrayBlockingQueue 等。</p>
<p>我们参考下面的源码，首先，通过再入锁获取条件变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">  <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">  lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">  notEmpty = lock.newCondition();</span><br><span class="line">  notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个条件变量是从<strong>同一再入锁</strong>创建出来，然后使用在特定操作中，如下面的 take 方法，判断和等待条件满足：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">          notEmpty.await();</span><br><span class="line">      <span class="keyword">return</span> dequeue();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当队列为空时，试图 take 的线程的正确行为应该是等待入队发生，而不是直接返回，这是 BlockingQueue 的语义，使用条件 notEmpty 就可以优雅地实现这一逻辑。</p>
<p>那么，怎么保证入队触发后续 take 操作呢？请看 enqueue 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E e)</span> &#123;</span><br><span class="line">  <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">  <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">  <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">  items[putIndex] = e;</span><br><span class="line">  <span class="keyword">if</span> (++putIndex == items.length) putIndex = <span class="number">0</span>;</span><br><span class="line">  count++;</span><br><span class="line">  notEmpty.signal(); <span class="comment">// 通知等待的线程，非空条件已经满足</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 signal&#x2F;await 的组合，完成了条件判断和通知等待线程，非常顺畅就完成了状态流转。注意，signal 和 await 成对调用非常重要，不然假设只有 await 动作，线程会一直等待直到被打断（interrupt）。</p>
<p>从性能角度，synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大。但是在 Java 6 中对其进行了非常多的改进，可以参考性能<a href="https://dzone.com/articles/synchronized-vs-lock">对比</a>，在高竞争情况下，ReentrantLock 仍然有一定优势。我在下一讲进行详细分析，会更有助于理解性能差异产生的内在原因。在大多数情况下，无需纠结于性能，还是考虑代码书写结构的便利性、可维护性等。</p>
<p>今天，作为专栏进入并发阶段的第一讲，我介绍了什么是线程安全，对比和分析了 synchronized 和 ReentrantLock，并针对条件变量等方面结合案例代码进行了介绍。下一讲，我将对锁的进阶内容进行源码和案例分析。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized</tag>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>14 谈谈你知道的设计模式？</title>
    <url>/2024/09/22/2024-09-22-14-%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="14-谈谈你知道的设计模式？"><a href="#14-谈谈你知道的设计模式？" class="headerlink" title="14 谈谈你知道的设计模式？"></a>14 谈谈你知道的设计模式？</h1><p>设计模式是人们为软件开发中相同表征的问题，抽象出的可重复利用的解决方案。在某种程度上，设计模式已经代表了一些特定情况的最佳实践，同时也起到了软件工程师之间沟通的“行话”的作用。理解和掌握典型的设计模式，有利于我们提高沟通、设计的效率和质量。</p>
<p>今天我要问你的问题是，<strong>谈谈你知道的设计模式？请手动实现单例模式，Spring 等框架中使用了哪些模式？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>大致按照模式的应用目标分类，设计模式可以分为创建型模式、结构型模式和行为型模式。</p>
<ul>
<li>创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</li>
<li>结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</li>
<li>行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</li>
</ul>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>我建议可以在回答时适当地举些例子，更加清晰地说明典型模式到底是什么样子，典型使用场景是怎样的。这里举个 Java 基础类库中的例子供你参考。<a href="https://en.wikipedia.org/wiki/Design_Patterns">https://en.wikipedia.org/wiki/Design_Patterns。</a></p>
<p>首先，【专栏第 11 讲】刚介绍过 IO 框架，我们知道 InputStream 是一个抽象类，标准类库中提供了 FileInputStream、ByteArrayInputStream 等各种不同的子类，分别从不同角度对 InputStream 进行了功能扩展，这是典型的装饰器模式应用案例。</p>
<p>识别装饰器模式，可以通过<strong>识别类设计特征</strong>来进行判断，也就是其类构造函数以<strong>相同的</strong>抽象类或者接口为输入参数。</p>
<p>因为装饰器模式本质上是包装同类型实例，我们对目标对象的调用，往往会通过包装类覆盖过的方法，迂回调用被包装的实例，这就可以很自然地实现增加额外逻辑的目的，也就是所谓的“装饰”。</p>
<p>例如，BufferedInputStream 经过包装，为输入流过程增加缓存，类似这种装饰器还可以多次嵌套，不断地增加不同层次的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span></span><br></pre></td></tr></table></figure>

<p>我在下面的类图里，简单总结了 InputStream 的装饰模式实践。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/77ad2dc2513da8155a3781e8291fac33-20221031180919-gsxeb4u.png" alt="img"></p>
<p>接下来再看第二个例子。创建型模式尤其是工厂模式，在我们的代码中随处可见，我举个相对不同的 API 设计实践。比如，JDK 最新版本中 HTTP&#x2F;2 Client API，下面这个创建 HttpRequest 的过程，就是典型的构建器模式（Builder），通常会被实现成<a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent 风格</a>的 API，也有人叫它方法链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder(<span class="keyword">new</span> <span class="title class_">URI</span>(uri))</span><br><span class="line">                     .header(headerAlice, valueAlice)</span><br><span class="line">                     .headers(headerBob, value1Bob,</span><br><span class="line">                      headerCarl, valueCarl,</span><br><span class="line">                      headerBob, value2Bob)</span><br><span class="line">                     .GET()</span><br><span class="line">                     .build();</span><br></pre></td></tr></table></figure>

<p>使用构建器模式，可以比较优雅地解决构建复杂对象的麻烦，这里的“复杂”是指类似需要输入的参数组合较多，如果用构造函数，我们往往需要为每一种可能的输入参数组合实现相应的构造函数，一系列复杂的构造函数会让代码阅读性和可维护性变得很差。</p>
<p>上面的分析也进一步反映了创建型模式的初衷，即，将对象创建过程单独抽象出来，从结构上把对象使用逻辑和创建逻辑相互独立，隐藏对象实例的细节，进而为使用者实现了更加规范、统一的逻辑。</p>
<p>更进一步进行设计模式考察，面试官可能会：</p>
<ul>
<li>希望你写一个典型的设计模式实现。这虽然看似简单，但即使是最简单的单例，也能够综合考察代码基本功。</li>
<li>考察典型的设计模式使用，尤其是结合标准库或者主流开源框架，考察你对业界良好实践的掌握程度。</li>
</ul>
<p>在面试时如果恰好问到你不熟悉的模式，你可以稍微引导一下，比如介绍你在产品中使用了什么自己相对熟悉的模式，试图解决什么问题，它们的优点和缺点等。</p>
<p>下面，我会针对前面两点，结合代码实例进行分析。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>我们来实现一个日常非常熟悉的单例设计模式。看起来似乎很简单，那么下面这个样例符合基本需求吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>是不是总感觉缺了点什么？原来，Java 会自动为没有明确声明构造函数的类，定义一个 public 的无参数的构造函数，所以上面的例子并不能保证额外的对象不被创建出来，别人完全可以直接“new Singleton()”，那我们应该怎么处理呢？</p>
<p>不错，可以为单例定义一个 private 的构造函数（也有建议声明为枚举，这是有争议的，我个人不建议选择相对复杂的枚举，毕竟日常开发不是学术研究）。这样还有什么改进的余地吗？</p>
<p>【专栏第 10 讲】介绍 ConcurrentHashMap 时，提到过标准类库中很多地方使用懒加载（lazy-load），改善初始内存开销，单例同样适用，下面是修正后的改进版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个实现在单线程环境不存在问题，但是如果处于并发场景，就需要考虑线程安全，最熟悉的就莫过于“双检锁”，其要点在于：</p>
<ul>
<li>这里的 volatile 能够提供可见性，以及保证 getInstance 返回的是初始化<strong>完全</strong>的对象。</li>
<li>在同步之前进行 null 检查，以尽量避免进入相对昂贵的同步块。</li>
<li>直接在 class 级别进行同步，保证线程安全的类方法调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 尽量避免重复进入同步块</span></span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// 同步.class，意味着对同步类方法调用</span></span><br><span class="line">              <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                  singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，争论较多的是 volatile 修饰静态变量，当 Singleton 类本身有多个成员变量时，需要保证初始化过程完成后，才能被 get 到。</p>
<p>在现代 Java 中，内存排序模型（JMM）已经非常完善，通过 volatile 的 write 或者 read，能保证所谓的 happen-before，也就是避免常被提到的指令重排。换句话说，构造对象的 store 指令能够被保证一定在 volatile read 之前。</p>
<p>当然，也有一些人推荐利用内部类持有静态对象的方式实现，其理论依据是对象初始化过程中隐含的初始化锁（有兴趣的话你可以参考<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4.2">jls-12.4.2</a> 中对 LC 的说明），这种和前面的双检锁实现都能保证线程安全，不过语法稍显晦涩，未必有特别的优势。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，可以看出，即使是看似最简单的单例模式，在增加各种高标准需求之后，同样需要非常多的实现考量。</p>
<p>上面是比较学究的考察，其实实践中未必需要如此复杂，如果我们看 Java 核心类库自己的单例实现，比如<a href="http://hg.openjdk.java.net/jdk/jdk/file/18fba780c1d1/src/java.base/share/classes/java/lang/Runtime.java">java.lang.Runtime</a>，你会发现：</p>
<p>它并没使用复杂的双检锁之类。</p>
<p>静态实例被声明为 final，这是被通常实践忽略的，一定程度保证了实例不被篡改（【专栏第 6 讲】介绍过，反射之类可以绕过私有访问限制），也有有限的保证执行顺序的语义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Version version;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> currentRuntime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Don&#x27;t let anyone else instantiate this class */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>前面说了不少代码实践，下面一起来简要看看主流开源框架，如 Spring 等如何在 API 设计中使用设计模式。你至少要有个大体的印象，如：</p>
<ul>
<li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactory.java">BeanFactory</a>和<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/ApplicationContext.java">ApplicationContext</a>应用了工厂模式。</li>
<li>在 Bean 的创建中，Spring 也为不同 scope 定义的对象，提供了单例和原型等模式实现。</li>
<li>我在【专栏第 6 讲】介绍的 AOP 领域则是使用了代理模式、装饰器模式、适配器模式等。</li>
<li>各种事件监听器，是观察者模式的典型应用。</li>
<li>类似 JdbcTemplate 等则是应用了模板模式。</li>
</ul>
<p>今天，我与你回顾了设计模式的分类和主要类型，并从 Java 核心类库、开源框架等不同角度分析了其采用的模式，并结合单例的不同实现，分析了如何实现符合线程安全等需求的单例，希望可以对你的工程实践有所帮助。另外，我想最后补充的是，设计模式也不是银弹，要避免滥用或者过度设计。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>13 谈谈接口和抽象类有什么区别？</title>
    <url>/2024/09/22/2024-09-22-13-%E8%B0%88%E8%B0%88%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="13-谈谈接口和抽象类有什么区别？"><a href="#13-谈谈接口和抽象类有什么区别？" class="headerlink" title="13 谈谈接口和抽象类有什么区别？"></a>13 谈谈接口和抽象类有什么区别？</h1><p>Java 是非常典型的面向对象语言，曾经有一段时间，程序员整天把面向对象、设计模式挂在嘴边。虽然如今大家对这方面已经不再那么狂热，但是不可否认，掌握面向对象设计原则和技巧，是保证高质量代码的基础之一。</p>
<p>面向对象提供的基本机制，对于提高开发、沟通等各方面效率至关重要。考察面向对象也是面试中的常见一环，下面我来聊聊<strong>面向对象设计基础</strong>。</p>
<p>今天我要问你的问题是，<strong>谈谈接口和抽象类有什么区别？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>接口和抽象类是 Java 面向对象设计的两个基础机制。</p>
<p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。Java 标准类库中，定义了非常多的接口，比如 java.util.List。</p>
<p>抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。Java 标准库中，比如 collection 框架，很多通用部分就被抽取成为抽象类，例如 java.util.AbstractList。</p>
<p>Java 类实现 interface 使用 implements 关键词，继承 abstract class 则是使用 extends 关键词，我们可以参考 Java 标准库中的 ArrayList。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>这是个非常高频的 Java 面向对象基础问题，看起来非常简单的问题，如果面试官稍微深入一些，你会发现很多有意思的地方，可以从不同角度全面地考察你对基本机制的理解和掌握。比如:</p>
<ul>
<li>对于 Java 的基本元素的语法是否理解准确。能否定义出语法基本正确的接口、抽象类或者相关继承实现，涉及重载（Overload）、重写（Override）更是有各种不同的题目。</li>
<li>在软件设计开发中妥善地使用接口和抽象类。你至少知道典型应用场景，掌握基础类库重要接口的使用；掌握设计方法，能够在 review 代码的时候看出明显的不利于未来维护的设计。</li>
<li>掌握 Java 语言特性演进。现在非常多的框架已经是基于 Java 8，并逐渐支持更新版本，掌握相关语法，理解设计目的是很有必要的。</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>我会从接口、抽象类的一些实践，以及语言变化方面去阐述一些扩展知识点。</p>
<p>Java 相比于其他面向对象语言，如 C++，设计上有一些基本区别，比如 <strong>Java 不支持多继承</strong>。这种限制，在规范了代码实现的同时，也产生了一些局限性，影响着程序设计结构。Java 类可以实现多个接口，因为接口是抽象方法的集合，所以这是声明性的，但不能通过扩展多个抽象类来重用逻辑。</p>
<p>在一些情况下存在特定场景，需要抽象出与具体实现、实例化无关的通用逻辑，或者纯调用关系的逻辑，但是使用传统的抽象类会陷入到单继承的窘境。以往常见的做法是，实现由静态方法组成的工具类（Utils），比如 java.util.Collections。</p>
<p>设想，为接口添加任何抽象方法，相应的所有实现了这个接口的类，也必须实现新增方法，否则会出现编译错误。对于抽象类，如果我们添加非抽象方法，其子类只会享受到能力扩展，而不用担心编译出问题。</p>
<p>接口的职责也不仅仅限于抽象方法的集合，其实有各种不同的实践。有一类没有任何方法的接口，通常叫作 Marker Interface，顾名思义，它的目的就是为了声明某些东西，比如我们熟知的 Cloneable、Serializable 等。这种用法，也存在于业界其他的 Java 产品代码中。</p>
<p>从表面看，这似乎和 Annotation 异曲同工，也确实如此，它的好处是简单直接。对于 Annotation，因为可以指定参数和值，在表达能力上要更强大一些，所以更多人选择使用 Annotation。</p>
<p>Java 8 增加了函数式编程的支持，所以又增加了一类定义，即所谓 functional interface，简单说就是只有一个抽象方法的接口，通常建议使用 @FunctionalInterface Annotation 来标记。Lambda 表达式本身可以看作是一类 functional interface，某种程度上这和面向对象可以算是两码事。我们熟知的 Runnable、Callable 之类，都是 functional interface，这里不再多介绍了，有兴趣你可以参考：<a href="https://www.oreilly.com/learning/java-8-functional-interfaces">https://www.oreilly.com/learning/java-8-functional-interfaces</a></p>
<p>还有一点可能让人感到意外，严格说，<strong>Java 8 以后，接口也是可以有方法实现的！</strong></p>
<p>从 Java 8 开始，interface 增加了对 default method 的支持。Java 9 以后，甚至可以定义 private default method。Default method 提供了一种二进制兼容的扩展已有接口的办法。比如，我们熟知的 java.util.Collection，它是 collection 体系的 root interface，在 Java 8 中添加了一系列 default method，主要是增加 Lambda、Stream 相关的功能。我在专栏前面提到的类似 Collections 之类的工具类，很多方法都适合作为 default method 实现在基础接口里面。</p>
<p>你可以参考下面代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a sequential Stream with this collection as its source </span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">     <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>面向对象设计</strong></p>
<p>谈到面向对象，很多人就会想起设计模式，那些是非常经典的问题和设计方法的总结。我今天来夯实一下基础，先来聊聊面向对象设计的基本方面。</p>
<p>我们一定要清楚面向对象的基本要素：封装、继承、多态。</p>
<p><strong>封装</strong>的目的是隐藏事务内部的实现细节，以便提高安全性和简化编程。封装提供了合理的边界，避免外部调用者接触到内部的细节。我们在日常开发中，因为无意间暴露了细节导致的难缠 bug 太多了，比如在多线程环境暴露内部状态，导致的并发修改问题。从另外一个角度看，封装这种隐藏，也提供了简化的界面，避免太多无意义的细节浪费调用者的精力。</p>
<p><strong>继承</strong>是代码复用的基础机制，类似于我们对于马、白马、黑马的归纳总结。但要注意，继承可以看作是非常紧耦合的一种关系，父类代码修改，子类行为也会变动。在实践中，过度滥用继承，可能会起到反效果。</p>
<p><strong>多态</strong>，你可能立即会想到重写（override）和重载（overload）、向上转型。简单说，重写是父子类中相同名字和参数的方法，不同的实现；重载则是相同名字的方法，但是不同的参数，本质上这些方法签名是不一样的，为了更好说明，请参考下面的样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入参数不同，意味着方法签名不同，重载的体现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doSomething</span><span class="params">(List&lt;String&gt; strs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return类型不一样，编译不能通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">short</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里你可以思考一个小问题，方法名称和参数一致，但是返回值不同，这种情况在 Java 代码中算是有效的重载吗？ 答案是不是的，编译都会出错的。</p>
<p>进行面向对象编程，掌握基本的设计原则是必须的，我今天介绍最通用的部分，也就是所谓的 S.O.L.I.D 原则。</p>
<ul>
<li>单一职责（Single Responsibility），类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</li>
<li>开关原则（Open-Close, Open for extension, close for modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</li>
<li>里氏替换（Liskov Substitution），这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。</li>
<li>接口分离（Interface Segregation），我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。</li>
</ul>
<p>对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。</p>
<ul>
<li>依赖反转（Dependency Inversion），实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。</li>
</ul>
<p><strong>OOP 原则实践中的取舍</strong></p>
<p>值得注意的是，现代语言的发展，很多时候并不是完全遵守前面的原则的，比如，Java 10 中引入了本地方法类型推断和 var 类型。按照，里氏替换原则，我们通常这样定义变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>如果使用 var 类型，可以简化为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>但是，list 实际会被推断为“ArrayList &lt; String &gt;”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>理论上，这种语法上的便利，其实是增强了程序对实现的依赖，但是微小的类型泄漏却带来了书写的便利和代码可读性的提高，所以，实践中我们还是要按照得失利弊进行选择，而不是一味得遵循原则。</p>
<p><strong>OOP 原则在面试题目中的分析</strong></p>
<p>我在以往面试中发现，即使是有多年编程经验的工程师，也还没有真正掌握面向对象设计的基本的原则，如开关原则（Open-Close）。看看下面这段代码，改编自朋友圈盛传的某伟大公司产品代码，你觉得可以利用面向对象设计原则如何改进？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VIPCenter</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">serviceVIP</span><span class="params">(T extend User user&gt;)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (user <span class="keyword">instanceof</span> SlumDogVIP) &#123;</span><br><span class="line">        <span class="comment">// 穷X VIP，活动抢的那种</span></span><br><span class="line">        <span class="comment">// do somthing</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(user <span class="keyword">instanceof</span> RealVIP) &#123;</span><br><span class="line">        <span class="comment">// do somthing</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的一个问题是，业务逻辑集中在一起，当出现新的用户类型时，比如，大数据发现了我们是肥羊，需要去收获一下， 这就需要直接去修改服务方法代码实现，这可能会意外影响不相关的某个用户类型逻辑。</p>
<p>利用开关原则，我们可以尝试改造为下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VIPCenter</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Map&lt;User.TYPE, ServiceProvider&gt; providers;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">serviceVIP</span><span class="params">(T extend User user） &#123;</span></span><br><span class="line"><span class="params">      providers.get(user.getType()</span>).service(user);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">interface</span> <span class="title class_">ServiceProvider</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(T extend User user)</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">SlumDogVIPServiceProvider</span> <span class="keyword">implements</span> <span class="title class_">ServiceProvider</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(T extend User user)</span>&#123;</span><br><span class="line">     <span class="comment">// do somthing</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">RealVIPServiceProvider</span> <span class="keyword">implements</span> <span class="title class_">ServiceProvider</span>&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(T extend User user)</span> &#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>上面的示例，将不同对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码的隔离保证了方便的扩展。</p>
<p>今天我对 Java 面向对象技术进行了梳理，对比了抽象类和接口，分析了 Java 语言在接口层面的演进和相应程序设计实现，最后回顾并实践了面向对象设计的基本原则，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title>12 Java有几种文件拷贝方式？哪一种最高效？</title>
    <url>/2024/09/22/2024-09-22-12-Java%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%93%AA%E4%B8%80%E7%A7%8D%E6%9C%80%E9%AB%98%E6%95%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="12-Java有几种文件拷贝方式？哪一种最高效？"><a href="#12-Java有几种文件拷贝方式？哪一种最高效？" class="headerlink" title="12 Java有几种文件拷贝方式？哪一种最高效？"></a>12 Java有几种文件拷贝方式？哪一种最高效？</h1><p>我在专栏上一讲提到，NIO 不止是多路复用，NIO 2 也不只是异步 IO，今天我们来看看 Java IO 体系中，其他不可忽略的部分。</p>
<p>今天我要问你的问题是，<strong>Java 有几种文件拷贝方式？哪一种最高效？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java 有多种比较典型的文件拷贝实现方式，比如：</p>
<p>利用 java.io 类库，直接为源文件构建一个 FileInputStream 读取，然后再为目标文件构建一个 FileOutputStream，完成写入工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByStream</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span></span><br><span class="line">        IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source);</span><br><span class="line">         <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);)&#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="keyword">while</span> ((length = is.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>或者，利用 java.nio 类库提供的 transferTo 或 transferFrom 方法实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByChannel</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span></span><br><span class="line">        IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source)</span><br><span class="line">            .getChannel();</span><br><span class="line">         <span class="type">FileChannel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel</span><br><span class="line">                 ();)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> sourceChannel.size() ;count&gt;<span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">transferred</span> <span class="operator">=</span> sourceChannel.transferTo(</span><br><span class="line">                    sourceChannel.position(), count, targetChannel);            sourceChannel.position(sourceChannel.position() + transferred);</span><br><span class="line">            count -= transferred;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当然，Java 标准类库本身已经提供了几种 Files.copy 的实现。</p>
<p>对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo&#x2F;From 的方式<strong>可能更快</strong>，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天这个问题，从面试的角度来看，确实是一个面试考察的点，针对我上面的典型回答，面试官还可能会从实践角度，或者 IO 底层实现机制等方面进一步提问。这一讲的内容从面试题出发，主要还是为了让你进一步加深对 Java IO 类库设计和实现的了解。</p>
<p>从实践角度，我前面并没有明确说 NIO transfer 的方案一定最快，真实情况也确实未必如此。我们可以根据理论分析给出可行的推断，保持合理的怀疑，给出验证结论的思路，有时候面试官考察的就是如何将猜测变成可验证的结论，思考方式远比记住结论重要。</p>
<p>从技术角度展开，下面这些方面值得注意：</p>
<ul>
<li>不同的 copy 方式，底层机制有什么区别？</li>
<li>为什么零拷贝（zero-copy）可能有性能优势？</li>
<li>Buffer 分类与使用。</li>
<li>Direct Buffer 对垃圾收集等方面的影响与实践选择。</li>
</ul>
<p>接下来，我们一起来分析一下吧。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ol>
<li>拷贝实现机制分析</li>
</ol>
<p>先来理解一下，前面实现的不同拷贝方法，本质上有什么明显的区别。</p>
<p>首先，你需要理解用户态空间（User Space）和内核态空间（Kernel Space），这是操作系统层面的基本概念，操作系统内核、硬件驱动等运行在内核态空间，具有相对高的特权；而用户态空间，则是给普通应用和服务使用。你可以参考：<a href="https://en.wikipedia.org/wiki/User_space%E3%80%82">https://en.wikipedia.org/wiki/User_space。</a></p>
<p>当我们使用输入输出流进行读写时，实际上是进行了多次上下文切换，比如应用读取数据时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。</p>
<p>写入操作也是类似，仅仅是步骤相反，你可以参考下面这张图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/6d2368424431f1b0d2b935386324b585-20221030220940-ad6vrbo.png" alt="img"></p>
<p>所以，这种方式会带来一定的额外开销，可能会降低 IO 效率。</p>
<p>而基于 NIO transferTo 的实现方式，在 Linux 和 Unix 上，则会使用到零拷贝技术，数据传输并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。注意，transferTo 不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行 Socket 发送，同样可以享受这种机制带来的性能和扩展性提高。</p>
<p>transferTo 的传输过程是：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/b0c8226992bb97adda5ad84fe25372ea-20221030220940-29fhrfv.png" alt="img"></p>
<ol>
<li>Java IO&#x2F;NIO 源码结构</li>
</ol>
<p>前面我在典型回答中提了第三种方式，即 Java 标准库也提供了文件拷贝方法（java.nio.file.Files.copy）。如果你这样回答，就一定要小心了，因为很少有问题的答案是仅仅调用某个方法。从面试的角度，面试官往往会追问：既然你提到了标准库，那么它是怎么实现的呢？有的公司面试官以喜欢追问而出名，直到追问到你说不知道。</p>
<p>其实，这个问题的答案还真不是那么直观，因为实际上有几个不同的 copy 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title function_">copy</span><span class="params">(Path source, Path target, CopyOption... options)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">copy</span><span class="params">(InputStream in, Path target, CopyOption... options)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">copy</span><span class="params">(Path source, OutputStream out)</span> </span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>可以看到，copy 不仅仅是支持文件之间操作，没有人限定输入输出流一定是针对文件的，这是两个很实用的工具方法。</p>
<p>后面两种 copy 实现，能够在方法实现里直接看到使用的是 InputStream.transferTo()，你可以直接看源码，其内部实现其实是 stream 在用户态的读写；而对于第一种方法的分析过程要相对麻烦一些，可以参考下面片段。简单起见，我只分析同类型文件系统拷贝过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title function_">copy</span><span class="params">(Path source, Path target, CopyOption... options)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="type">FileSystemProvider</span> <span class="variable">provider</span> <span class="operator">=</span> provider(source);</span><br><span class="line">    <span class="keyword">if</span> (provider(target) == provider) &#123;</span><br><span class="line">        <span class="comment">// same provider</span></span><br><span class="line">        provider.copy(source, target, options);<span class="comment">//这是本文分析的路径</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// different providers</span></span><br><span class="line">        CopyMoveHelper.copyToForeignTarget(source, target, options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我把源码分析过程简单记录如下，JDK 的源代码中，内部实现和公共 API 定义也不是可以能够简单关联上的，NIO 部分代码甚至是定义为模板而不是 Java 源文件，在 build 过程自动生成源码，下面顺便介绍一下部分 JDK 代码机制和如何绕过隐藏障碍。</p>
<ul>
<li>首先，直接跟踪，发现 FileSystemProvider 只是个抽象类，阅读它的<a href="http://hg.openjdk.java.net/jdk/jdk/file/f84ae8aa5d88/src/java.base/share/classes/java/nio/file/spi/FileSystemProvider.java">源码</a>能够理解到，原来文件系统实际逻辑存在于 JDK 内部实现里，公共 API 其实是通过 ServiceLoader 机制加载一系列文件系统实现，然后提供服务。</li>
<li>我们可以在 JDK 源码里搜索 FileSystemProvider 和 nio，可以定位到<a href="http://hg.openjdk.java.net/jdk/jdk/file/f84ae8aa5d88/src/java.base/share/classes/sun/nio/fs">sun&#x2F;nio&#x2F;fs</a>，我们知道 NIO 底层是和操作系统紧密相关的，所以每个平台都有自己的部分特有文件系统逻辑。</li>
</ul>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/5e0bf3130dffa8e56f398f0856eb76f7-20221030220940-6m2wonj.png" alt="img"></p>
<ul>
<li>省略掉一些细节，最后我们一步步定位到 UnixFileSystemProvider → UnixCopyFile.Transfer，发现这是个本地方法。</li>
<li>最后，明确定位到<a href="http://hg.openjdk.java.net/jdk/jdk/file/f84ae8aa5d88/src/java.base/unix/native/libnio/fs/UnixCopyFile.c">UnixCopyFile.c</a>，其内部实现清楚说明竟然只是简单的用户态空间拷贝！</li>
</ul>
<p>所以，我们明确这个最常见的 copy 方法其实不是利用 transferTo，而是本地技术实现的用户态拷贝。</p>
<p>前面谈了不少机制和源码，我简单从实践角度总结一下，如何提高类似拷贝等 IO 操作的性能，有一些宽泛的原则：</p>
<ul>
<li>在程序中，使用缓存等机制，合理减少 IO 次数（在网络通信中，如 TCP 传输，window 大小也可以看作是类似思路）。</li>
<li>使用 transferTo 等机制，减少上下文切换和额外 IO 操作。</li>
<li>尽量减少不必要的转换过程，比如编解码；对象序列化和反序列化，比如操作文本文件或者网络通信，如果不是过程中需要使用文本信息，可以考虑不要将二进制信息转换成字符串，直接传输二进制信息。</li>
</ul>
<ol>
<li>掌握 NIO Buffer</li>
</ol>
<p>我在上一讲提到 Buffer 是 NIO 操作数据的基本工具，Java 为每种原始数据类型都提供了相应的 Buffer 实现（布尔除外），所以掌握和使用 Buffer 是十分必要的，尤其是涉及 Direct Buffer 等使用，因为其在垃圾收集等方面的特殊性，更要重点掌握。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/5220029e92bc21e99920937a8210276e-20221030220940-y6lzdy8.png" alt="img"></p>
<p>Buffer 有几个基本属性：</p>
<ul>
<li>capacity，它反映这个 Buffer 到底有多大，也就是数组的长度。</li>
<li>position，要操作的数据起始位置。</li>
<li>limit，相当于操作的限额。在读取或者写入时，limit 的意义很明显是不一样的。比如，读取操作时，很可能将 limit 设置到所容纳数据的上限；而在写入时，则会设置容量或容量以下的可写限度。</li>
<li>mark，记录上一次 postion 的位置，默认是 0，算是一个便利性的考虑，往往不是必须的。</li>
</ul>
<p>前面三个是我们日常使用最频繁的，我简单梳理下 Buffer 的基本操作：</p>
<ul>
<li>我们创建了一个 ByteBuffer，准备放入数据，capacity 当然就是缓冲区大小，而 position 就是 0，limit 默认就是 capacity 的大小。</li>
<li>当我们写入几个字节的数据时，position 就会跟着水涨船高，但是它不可能超过 limit 的大小。</li>
<li>如果我们想把前面写入的数据读出来，需要调用 flip 方法，将 position 设置为 0，limit 设置为以前的 position 那里。</li>
<li>如果还想从头再读一遍，可以调用 rewind，让 limit 不变，position 再次设置为 0。</li>
</ul>
<p>更进一步的详细使用，我建议参考相关<a href="http://tutorials.jenkov.com/java-nio/buffers.html">教程</a>。</p>
<ol>
<li>Direct Buffer 和垃圾收集</li>
</ol>
<p>我这里重点介绍两种特别的 Buffer。</p>
<ul>
<li>Direct Buffer：如果我们看 Buffer 的方法定义，你会发现它定义了 isDirect() 方法，返回当前 Buffer 是否是 Direct 类型。这是因为 Java 提供了堆内和堆外（Direct）Buffer，我们可以以它的 allocate 或者 allocateDirect 方法直接创建。</li>
<li>MappedByteBuffer：它将文件按照指定大小直接映射为内存区域，当程序访问这个内存区域时将直接操作这块儿文件数据，省去了将数据从内核空间向用户空间传输的损耗。我们可以使用<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/channels/FileChannel.html#map-java.nio.channels.FileChannel.MapMode-long-long-">FileChannel.map</a>创建 MappedByteBuffer，它本质上也是种 Direct Buffer。</li>
</ul>
<p>在实际使用中，Java 会尽量对 Direct Buffer 仅做本地 IO 操作，对于很多大数据量的 IO 密集操作，可能会带来非常大的性能优势，因为：</p>
<ul>
<li>Direct Buffer 生命周期内内存地址都不会再发生更改，进而内核可以安全地对其进行访问，很多 IO 操作会很高效。</li>
<li>减少了堆内对象存储的可能额外维护工作，所以访问效率可能有所提高。</li>
</ul>
<p>但是请注意，Direct Buffer 创建和销毁过程中，都会比一般的堆内 Buffer 增加部分开销，所以通常都建议用于长期使用、数据较大的场景。</p>
<p>使用 Direct Buffer，我们需要清楚它对内存和 JVM 参数的影响。首先，因为它不在堆上，所以 Xmx 之类参数，其实并不能影响 Direct Buffer 等堆外成员所使用的内存额度，我们可以使用下面参数设置大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MaxDirectMemorySize=512M</span><br></pre></td></tr></table></figure>

<p>从参数设置和内存问题排查角度来看，这意味着我们在计算 Java 可以使用的内存大小的时候，不能只考虑堆的需要，还有 Direct Buffer 等一系列堆外因素。如果出现内存不足，堆外内存占用也是一种可能性。</p>
<p>另外，大多数垃圾收集过程中，都不会主动收集 Direct Buffer，它的垃圾收集过程，就是基于我在专栏前面所介绍的 Cleaner（一个内部实现）和幻象引用（PhantomReference）机制，其本身不是 public 类型，内部实现了一个 Deallocator 负责销毁的逻辑。对它的销毁往往要拖到 full GC 的时候，所以使用不当很容易导致 OutOfMemoryError。</p>
<p>对于 Direct Buffer 的回收，我有几个建议：</p>
<ul>
<li>在应用程序中，显式地调用 System.gc() 来强制触发。</li>
<li>另外一种思路是，在大量使用 Direct Buffer 的部分框架中，框架会自己在程序中调用释放方法，Netty 就是这么做的，有兴趣可以参考其实现（PlatformDependent0）。</li>
<li>重复使用 Direct Buffer。</li>
</ul>
<ol>
<li>跟踪和诊断 Direct Buffer 内存占用？</li>
</ol>
<p>因为通常的垃圾收集日志等记录，并不包含 Direct Buffer 等信息，所以 Direct Buffer 内存诊断也是个比较头疼的事情。幸好，在 JDK 8 之后的版本，我们可以方便地使用 Native Memory Tracking（NMT）特性来进行诊断，你可以在程序启动时加上下面参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:NativeMemoryTracking=&#123;summary|detail&#125;</span><br></pre></td></tr></table></figure>

<p>注意，激活 NMT 通常都会导致 JVM 出现 5%~10% 的性能下降，请谨慎考虑。</p>
<p>运行时，可以采用下面命令进行交互式对比：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印NMT信息</span></span><br><span class="line">jcmd &lt;pid&gt; VM.native_memory detail </span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行baseline，以对比分配内存变化</span></span><br><span class="line">jcmd &lt;pid&gt; VM.native_memory baseline</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行baseline，以对比分配内存变化</span></span><br><span class="line">jcmd &lt;pid&gt; VM.native_memory detail.diff</span><br></pre></td></tr></table></figure>

<p>我们可以在 Internal 部分发现 Direct Buffer 内存使用的信息，这是因为其底层实际是利用 unsafe_allocatememory。严格说，这不是 JVM 内部使用的内存，所以在 JDK 11 以后，其实它是归类在 other 部分里。</p>
<p>JDK 9 的输出片段如下，“+”表示的就是 diff 命令发现的分配变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Internal (reserved=679KB +4KB, committed=679KB +4KB)</span><br><span class="line">              (malloc=615KB +4KB #<span class="number">1571</span> +<span class="number">4</span>)</span><br><span class="line">              (mmap: reserved=64KB, committed=64KB)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：JVM 的堆外内存远不止 Direct Buffer，NMT 输出的信息当然也远不止这些，我在专栏后面有综合分析更加具体的内存结构的主题。</p>
<p>今天我分析了 Java IO&#x2F;NIO 底层文件操作数据的机制，以及如何实现零拷贝的高性能操作，梳理了 Buffer 的使用和类型，并针对 Direct Buffer 的生命周期管理和诊断进行了较详细的分析。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>文件操作</tag>
        <tag>文件拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>11 Java提供了哪些IO方式？ NIO如何实现多路复用？</title>
    <url>/2024/09/22/2024-09-22-11-Java%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9BIO%E6%96%B9%E5%BC%8F%EF%BC%9F-NIO%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="11-Java提供了哪些IO方式？-NIO如何实现多路复用？"><a href="#11-Java提供了哪些IO方式？-NIO如何实现多路复用？" class="headerlink" title="11 Java提供了哪些IO方式？ NIO如何实现多路复用？"></a>11 Java提供了哪些IO方式？ NIO如何实现多路复用？</h1><p>IO 一直是软件开发中的核心部分之一，伴随着海量数据增长和分布式系统的发展，IO 扩展能力愈发重要。幸运的是，Java 平台 IO 机制经过不断完善，虽然在某些方面仍有不足，但已经在实践中证明了其构建高扩展性应用的能力。</p>
<p>今天我要问你的问题是，<strong>Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p>
<p>第一，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p>
<p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p>
<p>很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p>
<p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p>
<p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>我上面列出的回答是基于一种常见分类方式，即所谓的 BIO、NIO、NIO 2（AIO）。</p>
<p>在实际面试中，从传统 IO 到 NIO、NIO 2，其中有很多地方可以扩展开来，考察点涉及方方面面，比如：</p>
<ul>
<li>基础 API 功能与设计， InputStream&#x2F;OutputStream 和 Reader&#x2F;Writer 的关系和区别。</li>
<li>NIO、NIO 2 的基本组成。</li>
<li>给定场景，分别用不同模型实现，分析 BIO、NIO 等模式的设计和实现原理。</li>
<li>NIO 提供的高性能数据操作方式是基于什么原理，如何使用？</li>
<li>或者，从开发者的角度来看，你觉得 NIO 自身实现存在哪些问题？有什么改进的想法吗？</li>
</ul>
<p>IO 的内容比较多，专栏一讲很难能够说清楚。IO 不仅仅是多路复用，NIO 2 也不仅仅是异步 IO，尤其是数据操作部分，会在专栏下一讲详细分析。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，需要澄清一些基本概念：</p>
<ul>
<li>区分同步或异步（synchronous&#x2F;asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</li>
<li>区分阻塞与非阻塞（blocking&#x2F;non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</li>
</ul>
<p>不能一概而论认为同步或阻塞就是低效，具体还要看应用和系统特征。</p>
<p>对于 java.io，我们都非常熟悉，我这里就从总体上进行一下总结，如果需要学习更加具体的操作，你可以通过<a href="https://docs.oracle.com/javase/tutorial/essential/io/streams.html">教程</a>等途径完成。总体上，我认为你至少需要理解一下内容。</p>
<ul>
<li>IO 不仅仅是对文件的操作，网络编程中，比如 Socket 通信，都是典型的 IO 操作目标。</li>
<li>输入流、输出流（InputStream&#x2F;OutputStream）是用于读取或写入字节的，例如操作图片文件。</li>
<li>而 Reader&#x2F;Writer 则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader&#x2F;Writer 相当于构建了应用逻辑和原始数据之间的桥梁。</li>
<li>BufferedOutputStream 等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO 处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。</li>
<li>参考下面这张类图，很多 IO 工具类都实现了 Closeable 接口，因为需要进行资源的释放。比如，打开 FileInputStream，它就会获取相应的文件描述符（FileDescriptor），需要利用 try-with-resources、 try-finally 等机制保证 FileInputStream 被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放。利用专栏前面的内容提到的 Cleaner 或 finalize 机制作为资源释放的最后把关，也是必要的。</li>
</ul>
<p>下面是我整理的一个简化版的类图，阐述了日常开发应用较多的类型和结构关系。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/4338e26731db0df390896ab305506d8b-20221030220406-ey151sm.png" alt="img"></p>
<ol>
<li><strong>Java NIO 概览</strong></li>
</ol>
<p>首先，熟悉一下 NIO 的主要组成部分：</p>
<ul>
<li>Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的 Buffer 实现。</li>
<li>Channel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。</li>
</ul>
<p>File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然。</p>
<ul>
<li>Selector，是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。Selector 同样是基于底层操作系统机制，不同模式、不同版本都存在区别，例如，在最新的代码库里，相关实现如下：</li>
</ul>
<blockquote>
<p>Linux 上依赖于<a href="http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/linux/classes/sun/nio/ch/EPollSelectorImpl.java">epoll</a>，Windows 上 NIO2（AIO）模式则是依赖于<a href="http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/windows/classes/sun/nio/ch/Iocp.java">iocp</a>。</p>
<ul>
<li>Charset，提供 Unicode 字符串定义，NIO 也提供了相应的编解码器等，例如，通过下面的方式进行字符串到 ByteBuffer 的转换：</li>
</ul>
</blockquote>
<p>Charset.defaultCharset().encode(“Hello world!”));</p>
<ol>
<li><strong>NIO 能解决什么问题？</strong></li>
</ol>
<p>下面我通过一个典型场景，来分析为什么需要 NIO，为什么需要多路复用。设想，我们需要实现一个服务器应用，只简单要求能够同时服务多个客户端请求即可。</p>
<p>使用 java.io 和 java.net 中的同步、阻塞式 API，可以简单实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  serverSocket.getLocalPort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="type">RequestHandler</span> <span class="variable">requestHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHandler</span>(socket);</span><br><span class="line">                requestHandler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DemoServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoServer</span>();</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), server.getPort())) &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span>                   <span class="title class_">InputStreamReader</span>(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 简化实现，不做读取，直接发送字符串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RequestHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    RequestHandler(Socket socket) &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其实现要点是：</p>
<ul>
<li>服务器端启动 ServerSocket，端口 0 表示自动绑定一个空闲端口。</li>
<li>调用 accept 方法，阻塞等待客户端连接。</li>
<li>利用 Socket 模拟了一个简单的客户端，只进行连接、读取、打印。</li>
<li>当连接建立后，启动一个单独线程负责回复客户端请求。</li>
</ul>
<p>这样，一个简单的 Socket 服务器就被实现出来了。</p>
<p>思考一下，这个解决方案在扩展性方面，可能存在什么潜在问题呢？</p>
<p>大家知道 Java 语言目前的线程实现是比较重量级的，启动或者销毁一个线程是有明显开销的，每个线程都有单独的线程栈等结构，需要占用非常明显的内存，所以，每一个 Client 启动一个线程似乎都有些浪费。</p>
<p>那么，稍微修正一下这个问题，我们引入线程池机制来避免浪费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">0</span>);</span><br><span class="line">executor = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    <span class="type">RequestHandler</span> <span class="variable">requestHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHandler</span>(socket);</span><br><span class="line">    executor.execute(requestHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做似乎好了很多，通过一个固定大小的线程池，来负责管理工作线程，避免频繁创建、销毁线程的开销，这是我们构建并发服务的典型方式。这种工作方式，可以参考下图来理解。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/da7e1ecfd3c3ee0263b8892342dbc629-20221030220406-th9dgbm.png" alt="img"></p>
<p>如果连接数并不是非常多，只有最多几百个连接的普通应用，这种模式往往可以工作的很好。但是，如果连接数量急剧上升，这种实现方式就无法很好地工作了，因为线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势。</p>
<p>NIO 引入的多路复用机制，提供了另外一种思路，请参考我下面提供的新的版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">             <span class="type">ServerSocketChannel</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ServerSocketChannel.open();) &#123;<span class="comment">// 创建Selector和Channel</span></span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(InetAddress.getLocalHost(), <span class="number">8888</span>));</span><br><span class="line">            serverSocket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 注册到Selector，并说明关注点</span></span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                selector.select();<span class="comment">// 阻塞等待就绪的Channel，这是关键点之一</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                   <span class="comment">// 生产系统中一般会额外进行就绪状态检查</span></span><br><span class="line">                    sayHelloWorld((ServerSocketChannel) key.channel());</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sayHelloWorld</span><span class="params">(ServerSocketChannel server)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();) &#123;          client.write(Charset.defaultCharset().encode(<span class="string">&quot;Hello world!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 省略了与前面类似的main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个非常精简的样例掀开了 NIO 多路复用的面纱，我们可以分析下主要步骤和元素：</p>
<ul>
<li>首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色。</li>
<li>然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。</li>
</ul>
<p><strong>注意</strong>，为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出 IllegalBlockingModeException 异常。</p>
<ul>
<li>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。</li>
<li>在 sayHelloWorld 方法中，通过 SocketChannel 和 Buffer 进行数据操作，在本例中是发送了一段字符串。</li>
</ul>
<p>可以看到，在前面两个样例中，IO 都是同步阻塞模式，所以需要多线程以实现多任务处理。而 NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。下面这张图对这种实现思路进行了形象地说明。</p>
<p>在 Java 7 引入的 NIO 2 中，又增添了一种额外的异步 IO 模式，利用事件和回调，处理 Accept、Read 等操作。 AIO 实现看起来是类似这样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">serverSock</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open().bind(sockAddr);</span><br><span class="line">serverSock.accept(serverSock, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;&gt;() &#123; <span class="comment">//为异步操作指定CompletionHandler回调函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel sockChannel, AsynchronousServerSocketChannel serverSock)</span> &#123;</span><br><span class="line">        serverSock.accept(serverSock, <span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 另外一个 write（sock，CompletionHandler&#123;&#125;）</span></span><br><span class="line">        sayHelloWorld(sockChannel, Charset.defaultCharset().encode</span><br><span class="line">                (<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 省略其他路径处理方法...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>鉴于其编程要素（如 Future、CompletionHandler 等），我们还没有进行准备工作，为避免理解困难，我会在专栏后面相关概念补充后的再进行介绍，尤其是 Reactor、Proactor 模式等方面将在 Netty 主题一起分析，这里我先进行概念性的对比：</p>
<ul>
<li>基本抽象很相似，AsynchronousServerSocketChannel 对应于上面例子中的 ServerSocketChannel；AsynchronousSocketChannel 则对应 SocketChannel。</li>
<li>业务逻辑的关键在于，通过指定 CompletionHandler 回调接口，在 accept&#x2F;read&#x2F;write 等关键节点，通过事件机制调用，这是非常不同的一种编程思路。</li>
</ul>
<p>今天我初步对 Java 提供的 IO 机制进行了介绍，概要地分析了传统同步 IO 和 NIO 的主要组成，并根据典型场景，通过不同的 IO 模式进行了实现与拆解。专栏下一讲，我还将继续分析 Java IO 的主题。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
        <tag>NIO</tag>
        <tag>多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>10 如何保证集合是线程安全的 ConcurrentHashMap如何实现高效地线程安全？</title>
    <url>/2024/09/22/2024-09-22-10-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-ConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="10-如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全？"><a href="#10-如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全？" class="headerlink" title="10 如何保证集合是线程安全的 ConcurrentHashMap如何实现高效地线程安全？"></a>10 如何保证集合是线程安全的 ConcurrentHashMap如何实现高效地线程安全？</h1><p>我在之前两讲介绍了 Java 集合框架的典型容器类，它们绝大部分都不是线程安全的，仅有的线程安全实现，比如 Vector、Stack，在性能方面也远不尽如人意。幸好 Java 语言提供了并发包（java.util.concurrent），为高度并发需求提供了更加全面的工具支持。</p>
<p>今天我要问你的问题是，<strong>如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java 提供了不同层面的线程安全支持。在传统集合框架内部，除了 Hashtable 等同步容器，还提供了所谓的同步包装器（Synchronized Wrapper），我们可以调用 Collections 工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap），但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。</p>
<p>另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：</p>
<ul>
<li>各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList。</li>
<li>各种线程安全队列（Queue&#x2F;Deque），如 ArrayBlockingQueue、SynchronousQueue。</li>
<li>各种有序容器的线程安全版本等。</li>
</ul>
<p>具体保证线程安全的方式，包括有从简单的 synchronize 方式，到基于更加精细化的，比如基于分离锁实现的 ConcurrentHashMap 等并发实现等。具体选择要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远优于早期的简单同步实现。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>谈到线程安全和并发，可以说是 Java 面试中必考的考点，我上面给出的回答是一个相对宽泛的总结，而且 ConcurrentHashMap 等并发容器实现也在不断演进，不能一概而论。</p>
<p>如果要深入思考并回答这个问题及其扩展方面，至少需要：</p>
<ul>
<li>理解基本的线程安全工具。</li>
<li>理解传统集合框架并发编程中 Map 存在的问题，清楚简单同步方式的不足。</li>
<li>梳理并发包内，尤其是 ConcurrentHashMap 采取了哪些方法来提高并发表现。</li>
<li>最好能够掌握 ConcurrentHashMap 自身的演进，目前的很多分析资料还是基于其早期版本。</li>
</ul>
<p>今天我主要是延续专栏之前两讲的内容，重点解读经常被同时考察的 HashMap 和 ConcurrentHashMap。今天这一讲并不是对并发方面的全面梳理，毕竟这也不是专栏一讲可以介绍完整的，算是个开胃菜吧，类似 CAS 等更加底层的机制，后面会在 Java 进阶模块中的并发主题有更加系统的介绍。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ol>
<li>为什么需要 ConcurrentHashMap？</li>
</ol>
<p>Hashtable 本身比较低效，因为它的实现基本就是将 put、get、size 等各种方法加上“synchronized”。简单来说，这就导致了所有并发操作都要竞争同一把锁，一个线程在进行同步操作时，其他线程只能等待，大大降低了并发操作的效率。</p>
<p>前面已经提过 HashMap 不是线程安全的，并发情况会导致类似 CPU 占用 100% 等一些问题，那么能不能利用 Collections 提供的同步包装器来解决问题呢？</p>
<p>看看下面的代码片段，我们发现同步包装器只是利用输入 Map 构造了另一个同步版本，所有操作虽然不再声明成为 synchronized 方法，但是还是利用了“this”作为互斥的 mutex，没有真正意义上的改进！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">    <span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.size();&#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// … </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，Hashtable 或者同步包装版本，都只是适合在非高度并发的场景下。</p>
<ol>
<li>ConcurrentHashMap 分析</li>
</ol>
<p>我们再来看看 ConcurrentHashMap 是如何设计实现的，为什么它能大大提高并发效率。</p>
<p>首先，我这里强调，<strong>ConcurrentHashMap 的设计实现其实一直在演化</strong>，比如在 Java 8 中就发生了非常大的变化（Java 7 其实也有不少更新），所以，我这里将比较分析结构、实现机制等方面，对比不同版本的主要区别。</p>
<p>早期 ConcurrentHashMap，其实现是基于：</p>
<ul>
<li>分离锁，也就是将内部进行分段（Segment），里面则是 HashEntry 的数组，和 HashMap 类似，哈希相同的条目也是以链表形式存放。</li>
<li>HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。</li>
</ul>
<p>你可以参考下面这个早期 ConcurrentHashMap 内部结构的示意图，其核心是利用分段设计，在进行并发操作的时候，只需要锁定相应段，这样就有效避免了类似 Hashtable 整体同步的问题，大大提高了性能。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/d45bcf9a34da2ef1ef335532b0198bd9-20221030215622-v85c2m9.png" alt="img"></p>
<p>在构造的时候，Segment 的数量由所谓的 concurrencyLevel 决定，默认是 16，也可以在相应构造函数直接指定。注意，Java 需要它是 2 的幂数值，如果输入是类似 15 这种非幂值，会被自动调整到 16 之类 2 的幂数值。</p>
<p>具体情况，我们一起看看一些 Map 基本操作的<a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/java/util/concurrent/ConcurrentHashMap.java">源码</a>，这是 JDK 7 比较新的 get 代码。针对具体的优化部分，为方便理解，我直接注释在代码段里，get 操作需要保证的是可见性，所以并没有什么同步逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key.hashCode());</span><br><span class="line">       <span class="comment">//利用位操作替换普通数学运算</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="comment">// 以Segment为单位，进行定位</span></span><br><span class="line">        <span class="comment">// 利用Unsafe直接进行volatile access</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//省略</span></span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而对于 put 操作，首先是通过二次哈希避免哈希冲突，然后以 Unsafe 调用方式，直接获取相应的 Segment，然后进行线程安全的 put 操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">       <span class="comment">// 二次哈希，以保证数据的分散性，避免哈希冲突</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key.hashCode());</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其核心逻辑实现在下面的内部方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">            <span class="comment">// scanAndLockForPut会去查找是否有key相同Node</span></span><br><span class="line">            <span class="comment">// 无论如何，确保获取锁</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="comment">// 更新已有value...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 放置HashEntry到特定位置，如果超过阈值，进行rehash</span></span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>所以，从上面的源码清晰的看出，在进行并发写操作时：</p>
<ul>
<li>ConcurrentHashMap 会获取再入锁，以保证数据一致性，Segment 本身就是基于 ReentrantLock 的扩展实现，所以，在并发修改期间，相应 Segment 是被锁定的。</li>
<li>在最初阶段，进行重复性的扫描，以确定相应 key 值是否已经在数组里面，进而决定是更新还是放置操作，你可以在代码里看到相应的注释。重复扫描、检测冲突是 ConcurrentHashMap 的常见技巧。</li>
<li>我在专栏上一讲介绍 HashMap 时，提到了可能发生的扩容问题，在 ConcurrentHashMap 中同样存在。不过有一个明显区别，就是它进行的不是整体的扩容，而是单独对 Segment 进行扩容，细节就不介绍了。</li>
</ul>
<p>另外一个 Map 的 size 方法同样需要关注，它的实现涉及分离锁的一个副作用。</p>
<p>试想，如果不进行同步，简单的计算所有 Segment 的总值，可能会因为并发 put，导致结果不准确，但是直接锁定所有 Segment 进行计算，就会变得非常昂贵。其实，分离锁也限制了 Map 的初始化等操作。</p>
<p>所以，ConcurrentHashMap 的实现是通过重试机制（RETRIES_BEFORE_LOCK，指定重试次数 2），来试图获得可靠值。如果没有监控到发生变化（通过对比 Segment.modCount），就直接返回，否则获取锁进行操作。</p>
<p>下面我来对比一下，<strong>在 Java 8 和之后的版本中，ConcurrentHashMap 发生了哪些变化呢？</strong></p>
<ul>
<li>总体结构上，它的内部存储变得和我在专栏上一讲介绍的 HashMap 结构非常相似，同样是大的桶（bucket）数组，然后内部也是一个个所谓的链表结构（bin），同步的粒度要更细致一些。</li>
<li>其内部仍然有 Segment 定义，但仅仅是为了保证序列化时的兼容性而已，不再有任何结构上的用处。</li>
<li>因为不再使用 Segment，初始化操作大大简化，修改为 lazy-load 形式，这样可以有效避免初始开销，解决了老版本很多人抱怨的这一点。</li>
<li>数据存储利用 volatile 来保证可见性。</li>
<li>使用 CAS 等操作，在特定场景进行无锁并发操作。</li>
<li>使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。</li>
</ul>
<p>先看看现在的数据存储内部实现，我们可以发现 Key 是 final 的，因为在生命周期中，一个条目的 Key 发生变化是不可能的；与此同时 val，则声明为 volatile，以保证可见性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V val;</span><br><span class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">       <span class="comment">// … </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我这里就不再介绍 get 方法和构造函数了，相对比较简单，直接看并发的 put 是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123; <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用CAS去进行无锁线程安全操作，如果bin是空的</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// 不加锁，进行检查</span></span><br><span class="line">                 &amp;&amp; fh == hash</span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="literal">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="comment">// 细粒度的同步修改操作... </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Bin超过阈值，进行树化</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化操作实现在 initTable 里面，这是一个典型的 CAS 使用场景，利用 volatile 的 sizeCtl 作为互斥手段：如果发现竞争性的初始化，就 spin 在那里，等待条件恢复；否则利用 CAS 设置排他标志。如果成功则进行初始化；否则重试。</p>
<p>请参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果发现冲突，进行spin等待</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); </span><br><span class="line">        <span class="comment">// CAS成功返回true，则进入真正的初始化逻辑</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 bin 为空时，同样是没有必要锁定，也是以 CAS 操作去放置。</p>
<p>你有没有注意到，在同步逻辑上，它使用的是 synchronized，而不是通常建议的 ReentrantLock 之类，这是为什么呢？现代 JDK 中，synchronized 已经被不断优化，可以不再过分担心性能差异，另外，相比于 ReentrantLock，它可以减少内存消耗，这是个非常大的优势。</p>
<p>与此同时，更多细节实现通过使用 Unsafe 进行了优化，例如 tabAt 就是直接利用 getObjectAcquire，避免间接调用的开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看，现在是如何实现 size 操作的。<a href="http://hg.openjdk.java.net/jdk/jdk/file/12fc7bf488ec/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java">阅读代码</a>你会发现，真正的逻辑是在 sumCount 方法中， 那么 sumCount 做了什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，虽然思路仍然和以前类似，都是分而治之的进行计数，然后求和处理，但实现却基于一个奇怪的 CounterCell。 难道它的数值，就更加准确吗？数据一致性是怎么保证的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CounterCell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    CounterCell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，对于 CounterCell 的操作，是基于 java.util.concurrent.atomic.LongAdder 进行的，是一种 JVM 利用空间换取更高效率的方法，利用了<a href="http://hg.openjdk.java.net/jdk/jdk/file/12fc7bf488ec/src/java.base/share/classes/java/util/concurrent/atomic/Striped64.java">Striped64</a>内部的复杂逻辑。这个东西非常小众，大多数情况下，建议还是使用 AtomicLong，足以满足绝大部分应用的性能需求。</p>
<p>今天我从线程安全问题开始，概念性的总结了基本容器工具，分析了早期同步容器的问题，进而分析了 Java 7 和 Java 8 中 ConcurrentHashMap 是如何设计实现的，希望 ConcurrentHashMap 的并发技巧对你在日常开发可以有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程安全</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>09 对比Hashtable、HashMap、TreeMap有什么不同？</title>
    <url>/2024/09/22/2024-09-22-09-%E5%AF%B9%E6%AF%94Hashtable%E3%80%81HashMap%E3%80%81TreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="09-对比Hashtable、HashMap、TreeMap有什么不同？"><a href="#09-对比Hashtable、HashMap、TreeMap有什么不同？" class="headerlink" title="09 对比Hashtable、HashMap、TreeMap有什么不同？"></a>09 对比Hashtable、HashMap、TreeMap有什么不同？</h1><p>Map 是广义 Java 集合框架中的另外一部分，HashMap 作为框架中使用频率最高的类型之一，它本身以及相关类型自然也是面试考察的热点。</p>
<p>今天我要问你的问题是，<strong>对比 Hashtable、HashMap、TreeMap 有什么不同？</strong>谈谈你对 HashMap 的掌握。</p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p>
<p>Hashtable 是早期 Java 类库提供的一个<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</p>
<p>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以<strong>它是绝大部分利用键值对存取场景的首选</strong>，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</p>
<p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>上面的回答，只是对一些基本特征的简单总结，针对 Map 相关可以扩展的问题很多，从各种数据结构、典型应用场景，到程序设计实现的技术考量，尤其是在 Java 8 里，HashMap 本身发生了非常大的变化，这些都是经常考察的方面。</p>
<p>很多朋友向我反馈，面试官似乎钟爱考察 HashMap 的设计和实现细节，所以今天我会增加相应的源码解读，主要专注于下面几个方面：</p>
<ul>
<li>理解 Map 相关类似整体结构，尤其是有序数据结构的一些要点。</li>
<li>从源码去分析 HashMap 的设计和实现要点，理解容量、负载因子等，为什么需要这些参数，如何影响 Map 的性能，实践中如何取舍等。</li>
<li>理解树化改造的相关原理和改进原因。</li>
</ul>
<p>除了典型的代码分析，还有一些有意思的并发相关问题也经常会被提到，如 HashMap 在并发环境可能出现<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6423457">无限循环占用 CPU</a>、size 不准确等诡异的问题。</p>
<p>我认为这是一种典型的使用错误，因为 HashMap 明确声明不是线程安全的数据结构，如果忽略这一点，简单用在多线程场景里，难免会出现问题。</p>
<p>理解导致这种错误的原因，也是深入理解并发程序运行的好办法。对于具体发生了什么，你可以参考这篇很久以前的<a href="https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html">分析</a>，里面甚至提供了示意图，我就不再重复别人写好的内容了。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ol>
<li>Map 整体结构</li>
</ol>
<p>首先，我们先对 Map 相关类型有个整体了解，Map 虽然通常被包括在 Java 集合框架里，但是其本身并不是狭义上的集合类型（Collection），具体你可以参考下面这个简单类图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/266cfaab2573c9777b1157816784727c-20221030214842-60g2hsi.png" alt="img"></p>
<p>Hashtable 比较特别，作为类似 Vector、Stack 的早期集合相关类型，它是扩展了 Dictionary 类的，类结构上与 HashMap 之类明显不同。</p>
<p>HashMap 等其他 Map 实现则是都扩展了 AbstractMap，里面包含了通用方法抽象。不同 Map 的用途，从类图结构就能体现出来，设计目的已经体现在不同接口上。</p>
<p>大部分使用 Map 的场景，通常就是放入、访问或者删除，而对顺序没有特别要求，HashMap 在这种情况下基本是最好的选择。<strong>HashMap 的性能表现非常依赖于哈希码的有效性，请务必掌握 hashCode 和 equals 的一些基本约定，</strong>比如：</p>
<ul>
<li>equals 相等，hashCode 一定要相等。</li>
<li>重写了 hashCode 也要重写 equals。</li>
<li>hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</li>
<li>equals 的对称、反射、传递等特性。</li>
</ul>
<p>这方面内容网上有很多资料，我就不在这里详细展开了。</p>
<p>针对有序 Map 的分析内容比较有限，我再补充一些，虽然 LinkedHashMap 和 TreeMap 都可以保证某种顺序，但二者还是非常不同的。</p>
<ul>
<li>LinkedHashMap 通常提供的是遍历顺序符合插入顺序，它的实现是通过为条目（键值对）维护一个双向链表。注意，通过特定构造函数，我们可以创建反映访问顺序的实例，所谓的 put、get、compute 等，都算作“访问”。</li>
</ul>
<p>这种行为适用于一些特定应用场景，例如，我们构建一个空间占用敏感的资源池，希望可以自动将最不常被访问的对象释放掉，这就可以利用 LinkedHashMap 提供的机制来实现，参考下面的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapSample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; accessOrderedMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;(<span class="number">16</span>, <span class="number">0.75F</span>, <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;String, String&gt; eldest)</span> &#123; <span class="comment">// 实现自定义删除策略，否则行为就和普遍Map没有区别</span></span><br><span class="line">                <span class="keyword">return</span> size() &gt; <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        accessOrderedMap.put(<span class="string">&quot;Project1&quot;</span>, <span class="string">&quot;Valhalla&quot;</span>);</span><br><span class="line">        accessOrderedMap.put(<span class="string">&quot;Project2&quot;</span>, <span class="string">&quot;Panama&quot;</span>);</span><br><span class="line">        accessOrderedMap.put(<span class="string">&quot;Project3&quot;</span>, <span class="string">&quot;Loom&quot;</span>);</span><br><span class="line">        accessOrderedMap.forEach( (k,v) -&gt; &#123;</span><br><span class="line">            System.out.println(k +<span class="string">&quot;:&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 模拟访问</span></span><br><span class="line">        accessOrderedMap.get(<span class="string">&quot;Project2&quot;</span>);</span><br><span class="line">        accessOrderedMap.get(<span class="string">&quot;Project2&quot;</span>);</span><br><span class="line">        accessOrderedMap.get(<span class="string">&quot;Project3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Iterate over should be not affected:&quot;</span>);</span><br><span class="line">        accessOrderedMap.forEach( (k,v) -&gt; &#123;</span><br><span class="line">            System.out.println(k +<span class="string">&quot;:&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 触发删除</span></span><br><span class="line">        accessOrderedMap.put(<span class="string">&quot;Project4&quot;</span>, <span class="string">&quot;Mission Control&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Oldest entry should be removed:&quot;</span>);</span><br><span class="line">        accessOrderedMap.forEach( (k,v) -&gt; &#123;<span class="comment">// 遍历顺序不变</span></span><br><span class="line">            System.out.println(k +<span class="string">&quot;:&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于 TreeMap，它的整体顺序是由键的顺序关系决定的，通过 Comparator 或 Comparable（自然顺序）来决定。</li>
</ul>
<p>我在上一讲留给你的思考题提到了，构建一个具有优先级的调度系统的问题，其本质就是个典型的优先队列场景，Java 标准库提供了基于二叉堆实现的 PriorityQueue，它们都是依赖于同一种排序机制，当然也包括 TreeMap 的马甲 TreeSet。</p>
<p>类似 hashCode 和 equals 的约定，为了避免模棱两可的情况，自然顺序同样需要符合一个约定，就是 compareTo 的返回值需要和 equals 一致，否则就会出现模棱两可情况。</p>
<p>我们可以分析 TreeMap 的 put 方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = …</span><br><span class="line">    cmp = k.compareTo(t.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        t = t.left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        t = t.right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从代码里，你可以看出什么呢？ 当我不遵守约定时，两个不符合唯一性（equals）要求的对象被当作是同一个（因为，compareTo 返回 0），这会导致歧义的行为表现。</p>
<ol>
<li>HashMap 源码分析</li>
</ol>
<p>前面提到，HashMap 设计与实现是个非常高频的面试题，所以我会在这进行相对详细的源码解读，主要围绕：</p>
<ul>
<li>HashMap 内部实现基本点分析。</li>
<li>容量（capacity）和负载系数（load factor）。</li>
<li>树化 。</li>
</ul>
<p>首先，我们来一起看看 HashMap 内部的结构，它可以看作是数组（Node[] table）和链表结合组成的复合结构，数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储，你可以参考下面的示意图。这里需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），图中的链表就会被改造为树形结构。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/1f72306a9d8719c66790b56ef7977c56-20221030214842-qbsir53.png" alt="img"></p>
<p>从非拷贝构造函数的实现来看，这个表格（数组）似乎并没有在最初就初始化好，仅仅设置了一些初始值而已。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span>&#123;  </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们深刻怀疑，HashMap 也许是按照 lazy-load 原则，在首次使用时被初始化（拷贝构造函数除外，我这里仅介绍最通用的场景）。既然如此，我们去看看 put 方法实现，似乎只有一个 putVal 的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看来主要的秘密似乎藏在 putVal 里面，到底有什么秘密呢？为了节省空间，我这里只截取了 putVal 比较关键的几部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evit)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> , i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) = <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == ull)</span><br><span class="line">        tab[i] = newNode(hash, key, value, nll);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for first </span></span><br><span class="line">           treeifyBin(tab, hash);</span><br><span class="line">        <span class="comment">//  ... </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 putVal 方法最初的几行，我们就可以发现几个有意思的地方：</p>
<ul>
<li>如果表格是 null，resize 方法会负责初始化它，这从 tab &#x3D; resize() 可以看出。</li>
<li>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容（resize）。</li>
<li>在放置新的键值对的过程中，如果发生下面条件，就会发生扩容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure>

<ul>
<li>具体键值对在哈希表中的位置（数组 index）取决于下面的位运算：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>

<p>仔细观察哈希值的源头，我们会发现，它并不是 key 本身的 hashCode，而是来自于 HashMap 内部的另外一个 hash 方法。注意，为什么这里需要将高位数据移位到低位进行异或运算呢？<strong>这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object kye)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt;<span class="number">16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>前面提到的链表结构（这里叫 bin），会在达到一定门限值时，发生树化，我稍后会分析为什么 HashMap 需要对 bin 进行处理。</li>
</ul>
<p>可以看到，putVal 方法本身逻辑非常集中，从初始化、扩容到树化，全部都和它有关，推荐你阅读源码的时候，可以参考上面的主要逻辑。</p>
<p>我进一步分析一下身兼多职的 resize 方法，很多朋友都反馈经常被面试官追问它的源码设计。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACIY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPAITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double there</span></span><br><span class="line">       <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// zero initial threshold signifies using defaultsfults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPAITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr ==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFator;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?(<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = neThr;</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newap];</span><br><span class="line">    table = n；</span><br><span class="line">    <span class="comment">// 移动到新的数组结构e数组结构 </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>依据 resize 源码，不考虑极端情况（容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 1&lt;&lt;30，也就是 2 的 30 次方），我们可以归纳为：</p>
<ul>
<li>门限值等于（负载因子）x（容量），如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。</li>
<li>门限通常是以倍数进行调整 （newThr &#x3D; oldThr &lt;&lt; 1），我前面提到，根据 putVal 中的逻辑，当元素个数超过门限大小时，则调整 Map 大小。</li>
<li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源</li>
</ul>
<ol>
<li>容量、负载因子和树化</li>
</ol>
<p>前面我们快速梳理了一下 HashMap 从创建到放入键值对的相关逻辑，现在思考一下，为什么我们需要在乎容量和负载因子呢？</p>
<p>这是因为容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。极端情况下，假设只有一个桶，那么它就退化成了链表，完全不能提供所谓常数时间存的性能。</p>
<p>既然容量和负载因子这么重要，我们在实践中应该如何选择呢？</p>
<p>如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。具体数值我们可以根据扩容发生的条件来做简单预估，根据前面的代码分析，我们知道它需要符合计算条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">负载因子 * 容量 &gt; 元素数量</span><br></pre></td></tr></table></figure>

<p>所以，预先设置的容量需要满足，大于“预估元素数量 &#x2F; 负载因子”，同时它是 2 的幂数，结论已经非常清晰了。</p>
<p>而对于负载因子，我建议：</p>
<ul>
<li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的。</li>
<li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。</li>
<li>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li>
</ul>
<p>我们前面提到了树化改造，对应逻辑主要在 putVal 和 treeifyBin 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//树化改造逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是精简过的 treeifyBin 示意，综合这两个方法，树化改造的逻辑就非常清晰了，可以理解为，当 bin 的数量大于 TREEIFY_THRESHOLD 时：</p>
<ul>
<li>如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容。</li>
<li>如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。</li>
</ul>
<p>那么，为什么 HashMap 要树化呢？</p>
<p><strong>本质上这是个安全问题。</strong>因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。</p>
<p>而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端 CPU 大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。</p>
<p>今天我从 Map 相关的几种实现对比，对各种 Map 进行了分析，讲解了有序集合类型容易混淆的地方，并从源码级别分析了 HashMap 的基本结构，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>Hashtable</tag>
        <tag>HashMap</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title>01 谈谈你对Java平台的理解？</title>
    <url>/2024/09/22/2024-09-22-01-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Java%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="01-谈谈你对Java平台的理解？"><a href="#01-谈谈你对Java平台的理解？" class="headerlink" title="01 谈谈你对Java平台的理解？"></a>01 谈谈你对Java平台的理解？</h1><p>从你接触 Java 开发到现在，你对 Java 最直观的印象是什么呢？是它宣传的 “Write once, run anywhere”，还是目前看已经有些过于形式主义的语法呢？你对于 Java 平台到底了解到什么程度？请你先停下来总结思考一下。</p>
<p>今天我要问你的问题是，谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？</p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java 本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“<strong>书写一次，到处运行</strong>”（Write once, run anywhere），能够非常容易地获得跨平台能力；另外就是<strong>垃圾收集</strong>（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。</p>
<p>我们日常会接触到 JRE（Java Runtime Environment）或者 JDK（Java Development Kit）。 JRE，也就是 Java 运行环境，包含了 JVM 和 Java 类库，以及一些模块等。而 JDK 可以看作是 JRE 的一个超集，提供了更多工具，比如编译器、各种诊断工具等。</p>
<p>对于“Java 是解释执行”这句话，这个说法不太准确。我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），然后，在运行时，通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于<strong>编译执行</strong>，而不是解释执行了。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>其实这个问题，问得有点笼统。题目本身是非常开放的，往往考察的是多个方面，比如，基础知识理解是否很清楚；是否掌握 Java 平台主要模块和运行原理等。很多面试者会在这种问题上吃亏，稍微紧张了一下，不知道从何说起，就给出个很简略的回答。</p>
<p>对于这类笼统的问题，你需要尽量<strong>表现出自己的思维深入并系统化，Java 知识理解得也比较全面，</strong>一定要避免让面试官觉得你是个“知其然不知其所以然”的人。毕竟明白基本组成和机制，是日常工作中进行问题诊断或者性能调优等很多事情的基础，相信没有招聘方会不喜欢“热爱学习和思考”的面试者。</p>
<p>即使感觉自己的回答不是非常完善，也不用担心。我个人觉得这种笼统的问题，有时候回答得稍微片面也很正常，大多数有经验的面试官，不会因为一道题就对面试者轻易地下结论。通常会尽量引导面试者，把他的真实水平展现出来，这种问题就是做个开场热身，面试官经常会根据你的回答扩展相关问题。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>回归正题，对于 Java 平台的理解，可以从很多方面简明扼要地谈一下，例如：Java 语言特性，包括泛型、Lambda 等语言特性；基础类库，包括集合、IO&#x2F;NIO、网络、并发、安全等基础类库。对于我们日常工作应用较多的类库，面试前可以系统化总结一下，有助于临场发挥。</p>
<p>或者谈谈 JVM 的一些基础概念和机制，比如 Java 的类加载机制，常用版本 JDK（如 JDK 8）内嵌的 Class-Loader，例如 Bootstrap、 Application 和 Extension Class-loader；类加载大致过程：加载、验证、链接、初始化（这里参考了周志明的《深入理解 Java 虚拟机》，非常棒的 JVM 上手书籍）；自定义 Class-Loader 等。还有垃圾收集的基本原理，最常见的垃圾收集器，如 SerialGC、Parallel GC、 CMS、 G1 等，对于适用于什么样的工作负载最好也心里有数。这些都是可以扩展开的领域，我会在后面的专栏对此进行更系统的介绍。</p>
<p>当然还有 JDK 包含哪些工具或者 Java 领域内其他工具等，如编译器、运行时环境、安全工具、诊断和监控工具等。这些基本工具是日常工作效率的保证，对于我们工作在其他语言平台上，同样有所帮助，很多都是触类旁通的。</p>
<p>下图是我总结的一个相对宽泛的蓝图供你参考。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/20bc6a900fc0b829c2f0e723df050732-20221026231319-hq3vjki.png" alt="img"></p>
<p>不再扩展了，回到前面问到的解释执行和编译执行的问题。有些面试官喜欢在特定问题上“刨根问底儿”，因为这是进一步了解面试者对知识掌握程度的有效方法，我稍微深入探讨一下。</p>
<p>众所周知，我们通常把 Java 分为编译期和运行时。这里说的 Java 的编译和 C&#x2F;C++ 是有着不同的意义的，Javac 的编译，编译 Java 源码生成“.class”文件里面实际是字节码，而不是可以直接执行的机器码。Java 通过字节码和 Java 虚拟机（JVM）这种跨平台的抽象，屏蔽了操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。</p>
<p>在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。就像我前面提到的，主流 Java 版本中，如 JDK 8 实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。通常运行在 server 模式的 JVM，会进行上万次调用以收集足够的信息进行高效的编译，client 模式这个门限是 1500 次。Oracle Hotspot JVM 内置了两个不同的 JIT compiler，C1 对应前面说的 client 模式，适用于对于启动速度敏感的应用，比如普通 Java 桌面应用；C2 对应 server 模式，它的优化是为长时间运行的服务器端应用设计的。默认是采用所谓的分层编译（TieredCompilation）。这里不再展开更多 JIT 的细节，没必要一下子就钻进去，我会在后面介绍分层编译的内容。</p>
<p>Java 虚拟机启动时，可以指定不同的参数对运行模式进行选择。 比如，指定“-Xint”，就是告诉 JVM 只进行解释执行，不对代码进行编译，这种模式抛弃了 JIT 可能带来的性能优势。毕竟解释器（interpreter）是逐条读入，逐条解释运行的。与其相对应的，还有一个“-Xcomp”参数，这是告诉 JVM 关闭解释器，不要进行解释执行，或者叫作最大优化级别。那你可能会问这种模式是不是最高效啊？简单说，还真未必。“-Xcomp”会导致 JVM 启动变慢非常多，同时有些 JIT 编译器优化方式，比如分支预测，如果不进行 profiling，往往并不能进行有效优化。</p>
<p>除了我们日常最常见的 Java 使用模式，其实还有一种新的编译方式，即所谓的 AOT（Ahead-of-Time Compilation），直接将字节码编译成机器代码，这样就避免了 JIT 预热等各方面的开销，比如 Oracle JDK 9 就引入了实验性的 AOT 特性，并且增加了新的 jaotc 工具。利用下面的命令把某个类或者某个模块编译成为 AOT 库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jaotc --output libHelloWorld.so HelloWorld.class</span><br><span class="line">jaotc --output libjava.base.so --module java.base</span><br></pre></td></tr></table></figure>

<p>‍</p>
<p>然后，在启动时直接指定就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -XX:AOTLibrary=./libHelloWorld.so,./libjava.base.so HelloWorld</span><br></pre></td></tr></table></figure>

<p>而且，Oracle JDK 支持分层编译和 AOT 协作使用，这两者并不是二选一的关系。如果你有兴趣，可以参考相关文档：<a href="http://openjdk.java.net/jeps/295%E3%80%82AOT">http://openjdk.java.net/jeps/295。AOT</a> 也不仅仅是只有这一种方式，业界早就有第三方工具（如 GCJ、Excelsior JET）提供相关功能。</p>
<p>另外，JVM 作为一个强大的平台，不仅仅只有 Java 语言可以运行在 JVM 上，本质上合规的字节码都可以运行，Java 语言自身也为此提供了便利，我们可以看到类似 Clojure、Scala、Groovy、JRuby、Jython 等大量 JVM 语言，活跃在不同的场景。</p>
<p>今天，我简单介绍了一下 Java 平台相关的一些内容，目的是提纲挈领地构建一个整体的印象，包括 Java 语言特性、 核心类库与常用第三方类库、Java 虚拟机基本原理和相关工具，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程</tag>
        <tag>理解</tag>
      </tags>
  </entry>
  <entry>
    <title>03 谈谈final、finally、finalize有什么不同？</title>
    <url>/2024/09/22/2024-09-22-03-%E8%B0%88%E8%B0%88final%E3%80%81finally%E3%80%81finalize%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="03-谈谈final、finally、-finalize有什么不同？"><a href="#03-谈谈final、finally、-finalize有什么不同？" class="headerlink" title="03 谈谈final、finally、 finalize有什么不同？"></a>03 谈谈final、finally、 finalize有什么不同？</h1><p>Java 语言有很多看起来很相似，但是用途却完全不同的语言要素，这些内容往往容易成为面试官考察你知识掌握程度的切入点。</p>
<p>今天，我要问你的是一个经典的 Java 基础题目，<strong>谈谈 final、finally、 finalize 有什么不同？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。</p>
<p>finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。</p>
<p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>这是一个非常经典的 Java 基础问题，我上面的回答主要是从语法和使用实践角度出发的，其实还有很多方面可以深入探讨，面试官还可以考察你对性能、并发、对象生命周期或垃圾收集基本过程等方面的理解。</p>
<p>推荐使用 final 关键字来明确表示我们代码的语义、逻辑意图，这已经被证明在很多场景下是非常好的实践，比如：</p>
<ul>
<li>我们可以将方法或者类声明为 final，这样就可以明确告知别人，这些行为是不许修改的。</li>
</ul>
<p>如果你关注过 Java 核心类库的定义或源码， 有没有发现 java.lang 包下面的很多类，相当一部分都被声明成为 final class？在第三方类库的一些基础类中同样如此，这可以有效避免 API 使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。</p>
<ul>
<li>使用 final 修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成 final。</li>
<li>final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</li>
</ul>
<p>final 也许会有性能的好处，很多文章或者书籍中都介绍了可在特定场景提高性能，比如，利用 final 可能有助于 JVM 将方法进行内联，可以改善编译器进行条件编译的能力等等。坦白说，很多类似的结论都是基于假设得出的，比如现代高性能 JVM（如 HotSpot）判断内联未必依赖 final 的提示，要相信 JVM 还是非常智能的。类似的，final 字段对性能的影响，大部分情况下，并没有考虑的必要。</p>
<p>从开发实践的角度，我不想过度强调这一点，这是和 JVM 的实现很相关的，未经验证比较难以把握。我的建议是，在日常开发中，除非有特别考虑，不然最好不要指望这种小技巧带来的所谓性能好处，程序最好是体现它的语义目的。如果你确实对这方面有兴趣，可以查阅相关资料，我就不再赘述了，不过千万别忘了验证一下。</p>
<p>对于 finally，明确知道怎么使用就足够了。需要关闭的连接等资源，更推荐使用 Java 7 中添加的 try-with-resources 语句，因为通常 Java 平台能够更好地处理异常情况，编码量也要少很多，何乐而不为呢。</p>
<p>另外，我注意到有一些常被考到的 finally 问题（也比较偏门），至少需要了解一下。比如，下面代码会输出什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">  System.out.println(“Print from <span class="keyword">finally</span>”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 finally 里面的代码可不会被执行的哦，这是一个特例。</p>
<p>对于 finalize，我们要明确它是不推荐使用的，业界实践一再证明它不是个好的办法，在 Java 9 中，甚至明确将 Object.finalize() 标记为 deprecated！如果没有特别的原因，不要实现 finalize 方法，也不要指望利用它来进行资源回收。</p>
<p>为什么呢？简单说，你无法保证 finalize 什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。</p>
<p>通常来说，利用上面的提到的 try-with-resources 或者 try-finally 机制，是非常好的回收资源的办法。如果确实需要额外处理，可以考虑 Java 提供的 Cleaner 机制或者其他替代方法。接下来，我来介绍更多设计考虑和实践细节。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ol>
<li>注意，final 不是 immutable！</li>
</ol>
<p>我在前面介绍了 final 在实践中的益处，需要注意的是，<strong>final 并不等同于 immutable</strong>，比如下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">strList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">strList.add(<span class="string">&quot;world&quot;</span>);  </span><br><span class="line">List&lt;String&gt; unmodifiableStrList = List.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">unmodifiableStrList.add(<span class="string">&quot;again&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>final 只能约束 strList 这个引用不可以被赋值，但是 strList 对象行为不被 final 影响，添加元素等操作是完全正常的。如果我们真的希望对象本身是不可变的，那么需要相应的类支持不可变的行为。在上面这个例子中，<a href="http://openjdk.java.net/jeps/269">List.of 方法</a>创建的本身就是不可变 List，最后那句 add 是会在运行时抛出异常的。</p>
<p>Immutable 在很多场景是非常棒的选择，某种意义上说，Java 语言目前并没有原生的不可变支持，如果要实现 immutable 的类，我们需要做到：</p>
<ul>
<li>将 class 自身声明为 final，这样别人就不能扩展来绕过限制了。</li>
<li>将所有成员变量定义为 private 和 final，并且不要实现 setter 方法。</li>
<li>通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。</li>
<li>如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，使用 copy-on-write 原则，创建私有的 copy。</li>
</ul>
<p>这些原则是不是在并发编程实践中经常被提到？的确如此。</p>
<p>关于 setter&#x2F;getter 方法，很多人喜欢直接用 IDE 一次全部生成，建议最好是你确定有需要时再实现。</p>
<ol>
<li>finalize 真的那么不堪？</li>
</ol>
<p>前面简单介绍了 finalize 是一种已经被业界证明了的非常不好的实践，那么为什么会导致那些问题呢？</p>
<p>finalize 的执行是和垃圾收集关联在一起的，一旦实现了非空的 finalize 方法，就会导致相应对象回收呈现数量级上的变慢，有人专门做过 benchmark，大概是 40~50 倍的下降。</p>
<p>因为，finalize 被设计成在对象被<strong>垃圾收集前</strong>调用，这就意味着实现了 finalize 方法的对象是个“特殊公民”，JVM 要对它进行额外处理。finalize 本质上成为了快速回收的阻碍者，可能导致你的对象经过多个垃圾收集周期才能被回收。</p>
<p>有人也许会问，我用 System.runFinalization() 告诉 JVM 积极一点，是不是就可以了？也许有点用，但是问题在于，这还是不可预测、不能保证的，所以本质上还是不能指望。实践中，因为 finalize 拖慢垃圾收集，导致大量对象堆积，也是一种典型的导致 OOM 的原因。</p>
<p>从另一个角度，我们要确保回收资源就是因为资源都是有限的，垃圾收集时间的不可预测，可能会极大加剧资源占用。这意味着对于消耗非常高频的资源，千万不要指望 finalize 去承担资源释放的主要职责，最多让 finalize 作为最后的“守门员”，况且它已经暴露了如此多的问题。这也是为什么我推荐，<strong>资源用完即显式释放，或者利用资源池来尽量重用</strong>。</p>
<p>finalize 还会掩盖资源回收时的出错信息，我们看下面一段 JDK 的源代码，截取自 java.lang.ref.Finalizer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runFinalizer</span><span class="params">(JavaLangAccess jla)</span> &#123;</span><br><span class="line"><span class="comment">//  ... 省略部分代码</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">finalizee</span> <span class="operator">=</span> <span class="built_in">this</span>.get(); </span><br><span class="line">   <span class="keyword">if</span> (finalizee != <span class="literal">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span><br><span class="line">      jla.invokeFinalize(finalizee);</span><br><span class="line">      <span class="comment">// Clear stack slot containing this variable, to decrease</span></span><br><span class="line">      <span class="comment">// the chances of false retention with a conservative GC</span></span><br><span class="line">      finalizee = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span><br><span class="line">   <span class="built_in">super</span>.clear(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合我上期专栏介绍的异常处理实践，你认为这段代码会导致什么问题？</p>
<p>是的，你没有看错，这里的** Throwable 是被生吞了的！**也就意味着一旦出现异常或者出错，你得不到任何有效信息。况且，Java 在 finalize 阶段也没有好的方式处理任何信息，不然更加不可预测。</p>
<ol>
<li>有什么机制可以替换 finalize 吗？</li>
</ol>
<p>Java 平台目前在逐步使用 java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。Cleaner 的实现利用了幻象引用（PhantomReference），这是一种常见的所谓 post-mortem 清理机制。我会在后面的专栏系统介绍 Java 的各种引用，利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符（操作系统有限的资源），它比 finalize 更加轻量、更加可靠。</p>
<p>吸取了 finalize 里的教训，每个 Cleaner 的操作都是独立的，它有自己的运行线程，所以可以避免意外死锁等问题。</p>
<p>实践中，我们可以为自己的模块构建一个 Cleaner，然后实现相应的清理逻辑。下面是 JDK 自身提供的样例程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CleaningExample</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">        <span class="comment">// A cleaner, preferably one shared within a library</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Cleaner</span> <span class="variable">cleaner</span> <span class="operator">=</span> &lt;cleaner&gt;;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">State</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">            State(...) &#123;</span><br><span class="line">                <span class="comment">// initialize State needed for cleaning action</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// cleanup action accessing State, executed at most once</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> State;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CleaningExample</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.state = <span class="keyword">new</span> <span class="title class_">State</span>(...);</span><br><span class="line">            <span class="built_in">this</span>.cleanable = cleaner.register(<span class="built_in">this</span>, state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">            cleanable.clean();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意，从可预测性的角度来判断，Cleaner 或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致幻象引用堆积，同样会出现问题。所以，Cleaner 适合作为一种最后的保证手段，而不是完全依赖 Cleaner 进行资源回收，不然我们就要再做一遍 finalize 的噩梦了。</p>
<p>我也注意到很多第三方库自己直接利用幻象引用定制资源收集，比如广泛使用的 MySQL JDBC driver 之一的 mysql-connector-j，就利用了幻象引用机制。幻象引用也可以进行类似链条式依赖关系的动作，比如，进行总量控制的场景，保证只有连接被关闭，相应资源被回收，连接池才能创建新的连接。</p>
<p>另外，这种代码如果稍有不慎添加了对资源的强引用关系，就会导致循环引用关系，前面提到的 MySQL JDBC 就在特定模式下有这种问题，导致内存泄漏。上面的示例代码中，将 State 定义为 static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。</p>
<p>今天，我从语法角度分析了 final、finally、finalize，并从安全、性能、垃圾收集等方面逐步深入，探讨了实践中的注意事项，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>final</tag>
        <tag>finally</tag>
        <tag>finalize</tag>
      </tags>
  </entry>
  <entry>
    <title>04 强引用、软引用、弱引用、幻象引用有什么区别？</title>
    <url>/2024/09/22/2024-09-22-04-%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="04-强引用、软引用、弱引用、幻象引用有什么区别？"><a href="#04-强引用、软引用、弱引用、幻象引用有什么区别？" class="headerlink" title="04 强引用、软引用、弱引用、幻象引用有什么区别？"></a>04 强引用、软引用、弱引用、幻象引用有什么区别？</h1><p>在 Java 语言中，除了原始数据类型的变量，其他所有都是所谓的引用类型，指向各种不同的对象，理解引用对于掌握 Java 对象生命周期和 JVM 内部相关机制非常有帮助。</p>
<p>今天我要问你的问题是，<strong>强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>不同的引用类型，主要体现的是<strong>对象不同的可达性（reachable）状态和对垃圾收集的影响。</strong></p>
<p>所谓强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p>
<p>对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，我在专栏上一讲中介绍的 Java 平台自身 Cleaner 机制等，也有人利用幻象引用监控对象的创建和销毁。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>这道面试题，属于既偏门又非常高频的一道题目。说它偏门，是因为在大多数应用开发中，很少直接操作各种不同引用，虽然我们使用的类库、框架可能利用了其机制。它被频繁问到，是因为这是一个综合性的题目，既考察了我们对基础概念的理解，也考察了对底层对象生命周期、垃圾收集机制等的掌握。</p>
<p>充分理解这些引用，对于我们设计可靠的缓存等框架，或者诊断应用 OOM 等问题，会很有帮助。比如，诊断 MySQL connector-j 驱动在特定模式下（useCompression&#x3D;true）的内存泄漏问题，就需要我们理解怎么排查幻象引用的堆积问题。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ol>
<li>对象可达性状态流转分析</li>
</ol>
<p>首先，请你看下面流程图，我这里简单总结了对象生命周期和不同可达性状态，以及不同状态可能的改变关系，可能未必 100% 严谨，来阐述下可达性的变化。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/36d3c7b158eda9421ef32463cb4d4fb0-20221026231642-qgqprs2.png" alt="img"></p>
<p>我来解释一下上图的具体状态，这是 Java 定义的不同可达性级别（reachability level），具体如下：</p>
<ul>
<li>强可达（Strongly Reachable），就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。</li>
<li>软可达（Softly Reachable），就是当我们只能通过软引用才能访问到对象的状态。</li>
<li>弱可达（Weakly Reachable），类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。这是十分临近 finalize 状态的时机，当弱引用被清除的时候，就符合 finalize 的条件了。</li>
<li>幻象可达（Phantom Reachable），上面流程图已经很直观了，就是没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候。</li>
<li>当然，还有一个最后的状态，就是不可达（unreachable），意味着对象可以被清除了。</li>
</ul>
<p>判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分考虑。</p>
<p>所有引用类型，都是抽象类 java.lang.ref.Reference 的子类，你可能注意到它提供了 get() 方法：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/bae702d46c665e12113f5abd876eb53e-20221026231642-gx8za9u.png" alt="img"></p>
<p>除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态！这也是为什么我在上面图里有些地方画了双向箭头。</p>
<p>所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。</p>
<p>但是，你觉得这里有没有可能出现什么问题呢？</p>
<p>不错，如果我们错误的保持了强引用（比如，赋值给了 static 变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。所以，检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路，如果我们的框架使用到弱引用又怀疑有内存泄漏，就可以从这个角度检查。</p>
<ol>
<li>引用队列（ReferenceQueue）使用</li>
</ol>
<p>谈到各种引用的编程，就必然要提到引用队列。我们在创建各种引用并关联到相应对象时，可以选择是否需要关联引用队列，JVM 会在特定时机将引用 enqueue 到队列里，我们可以从队列里获取引用（remove 方法在这里实际是有获取的意思）进行相关后续逻辑。尤其是幻象引用，get 方法只返回 null，如果再不指定引用队列，基本就没有意义了。看看下面的示例代码。利用引用队列，我们可以在对象处于相应状态时（对于幻象引用，就是前面说的被 finalize 了，处于幻象可达状态），执行后期处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">refQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; p = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(counter, refQueue);</span><br><span class="line">counter = <span class="literal">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Remove是一个阻塞方法，可以指定timeout，或者选择一直阻塞</span></span><br><span class="line">    Reference&lt;Object&gt; ref = refQueue.remove(<span class="number">1000L</span>);</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// Handle it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>显式地影响软引用垃圾收集</li>
</ol>
<p>前面泛泛提到了引用对垃圾收集的影响，尤其是软引用，到底 JVM 内部是怎么处理它的，其实并不是非常明确。那么我们能不能使用什么方法来影响软引用的垃圾收集呢？</p>
<p>答案是有的。软引用通常会在最后一次引用后，还能保持一段时间，默认值是根据堆剩余空间计算的（以 M bytes 为单位）。从 Java 1.3.1 开始，提供了 -XX:SoftRefLRUPolicyMSPerMB 参数，我们可以以毫秒（milliseconds）为单位设置。比如，下面这个示例就是设置为 3 秒（3000 毫秒）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:SoftRefLRUPolicyMSPerMB=<span class="number">3000</span></span><br></pre></td></tr></table></figure>

<p>这个剩余空间，其实会受不同 JVM 模式影响，对于 Client 模式，比如通常的 Windows 32 bit JDK，剩余空间是计算当前堆里空闲的大小，所以更加倾向于回收；而对于 server 模式 JVM，则是根据 -Xmx 指定的最大值来计算。</p>
<p>本质上，这个行为还是个黑盒，取决于 JVM 实现，即使是上面提到的参数，在新版的 JDK 上也未必有效，另外 Client 模式的 JDK 已经逐步退出历史舞台。所以在我们应用时，可以参考类似设置，但不要过于依赖它。</p>
<ol>
<li>诊断 JVM 引用情况</li>
</ol>
<p>如果你怀疑应用存在引用（或 finalize）导致的回收问题，可以有很多工具或者选项可供选择，比如 HotSpot JVM 自身便提供了明确的选项（PrintReferenceGC）去获取相关信息，我指定了下面选项去使用 JDK 8 运行一个样例应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintReferenceGC</span><br></pre></td></tr></table></figure>

<p>这是 JDK 8 使用 ParrallelGC 收集的垃圾收集日志，各种引用数量非常清晰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0.403</span>: [GC (Allocation Failure) <span class="number">0.871</span>: [SoftReference, <span class="number">0</span> refs, <span class="number">0.0000393</span> secs]<span class="number">0.871</span>: [WeakReference, <span class="number">8</span> refs, <span class="number">0.0000138</span> secs]<span class="number">0.871</span>: [FinalReference, <span class="number">4</span> refs, <span class="number">0.0000094</span> secs]<span class="number">0.871</span>: [PhantomReference, <span class="number">0</span> refs, <span class="number">0</span> refs, <span class="number">0.0000085</span> secs]<span class="number">0.871</span>: [JNI Weak Reference, <span class="number">0.0000071</span> secs][PSYoungGen: 76272K-&gt;10720K(141824K)] 128286K-&gt;128422K(316928K), <span class="number">0.4683919</span> secs] [Times: user=<span class="number">1.17</span> sys=<span class="number">0.03</span>, real=<span class="number">0.47</span> secs] </span><br></pre></td></tr></table></figure>

<p><strong>注意：JDK 9 对 JVM 和垃圾收集日志进行了广泛的重构</strong>，类似 PrintGCTimeStamps 和 PrintReferenceGC 已经不再存在，我在专栏后面的垃圾收集主题里会更加系统的阐述。</p>
<ol>
<li>Reachability Fence</li>
</ol>
<p>除了我前面介绍的几种基本引用类型，我们也可以通过底层 API 来达到强引用的效果，这就是所谓的设置 <strong>reachability fence</strong>。</p>
<p>为什么需要这种机制呢？考虑一下这样的场景，按照 Java 语言规范，如果一个对象没有指向强引用，就符合垃圾收集的标准，有些时候，对象本身并没有强引用，但是也许它的部分属性还在被使用，这样就导致诡异的问题，所以我们需要一个方法，在没有强引用情况下，通知 JVM 对象是在被使用的。说起来有点绕，我们来看看 Java 9 中提供的案例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ExternalResource[] externalResourceArray = ...</span><br><span class="line"> <span class="type">int</span> myIndex; Resource(...) &#123;</span><br><span class="line">     myIndex = ...</span><br><span class="line">     externalResourceArray[myIndex] = ...;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">     externalResourceArray[myIndex] = <span class="literal">null</span>;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 需要被保护的代码</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> myIndex;</span><br><span class="line">     Resource.update(externalResourceArray[i]);</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// 调用reachbilityFence，明确保障对象strongly reachable</span></span><br><span class="line">     Reference.reachabilityFence(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(ExternalResource ext)</span> &#123;</span><br><span class="line">    ext.status = ...;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>方法 action 的执行，依赖于对象的部分属性，所以被特定保护了起来。否则，如果我们在代码中像下面这样调用，那么就可能会出现困扰，因为没有强引用指向我们创建出来的 Resource 对象，JVM 对它进行 finalize 操作是完全合法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Resource</span>().action()</span><br></pre></td></tr></table></figure>

<p>类似的书写结构，在异步编程中似乎是很普遍的，因为异步编程中往往不会用传统的“执行 -&gt; 返回 -&gt; 使用”的结构。</p>
<p>在 Java 9 之前，实现类似功能相对比较繁琐，有的时候需要采取一些比较隐晦的小技巧。幸好，java.lang.ref.Reference 给我们提供了新方法，它是 JEP 193: Variable Handles 的一部分，将 Java 平台底层的一些能力暴露出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reachabilityFence</span><span class="params">(Object ref)</span></span><br></pre></td></tr></table></figure>

<p>在 JDK 源码中，reachabilityFence 大多使用在 Executors 或者类似新的 HTTP&#x2F;2 客户端代码中，大部分都是异步调用的情况。编程中，可以按照上面这个例子，将需要 reachability 保障的代码段利用 try-finally 包围起来，在 finally 里明确声明对象强可达。</p>
<p>今天，我总结了 Java 语言提供的几种引用类型、相应可达状态以及对于 JVM 工作的意义，并分析了引用队列使用的一些实际情况，最后介绍了在新的编程模式下，如何利用 API 去保障对象不被意外回收，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>引用</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>05 String、StringBuffer、StringBuilder有什么区别？</title>
    <url>/2024/09/22/2024-09-22-05-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="05-String、StringBuffer、StringBuilder有什么区别？"><a href="#05-String、StringBuffer、StringBuilder有什么区别？" class="headerlink" title="05 String、StringBuffer、StringBuilder有什么区别？"></a>05 String、StringBuffer、StringBuilder有什么区别？</h1><p>今天我会聊聊日常使用的字符串，别看它似乎很简单，但其实字符串几乎在所有编程语言里都是个特殊的存在，因为不管是数量还是体积，字符串都是大多数应用中的重要组成。</p>
<p>今天我要问你的问题是，<strong>理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p>
<p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p>
<p>StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>几乎所有的应用开发都离不开操作字符串，理解字符串的设计和实现以及相关工具如拼接类的使用，对写出高质量代码是非常有帮助的。关于这个问题，我前面的回答是一个通常的概要性回答，至少你要知道 String 是 Immutable 的，字符串操作不当可能会产生大量临时字符串，以及线程安全方面的区别。</p>
<p>如果继续深入，面试官可以从各种不同的角度考察，比如可以：</p>
<ul>
<li>通过 String 和相关类，考察基本的线程安全设计与实现，各种基础编程实践。</li>
<li>考察 JVM 对象缓存机制的理解以及如何良好地使用。</li>
<li>考察 JVM 优化 Java 代码的一些技巧。</li>
<li>String 相关类的演进，比如 Java 9 中实现的巨大变化。</li>
<li>…</li>
</ul>
<p>针对上面这几方面，我会在知识扩展部分与你详细聊聊。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ol>
<li>字符串设计和实现考量</li>
</ol>
<p>我在前面介绍过，String 是 Immutable 类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。</p>
<p>我们再来看看 StringBuffer 实现的一些细节，它的线程安全是通过把各种修改数据的方法都加上 synchronized 关键字实现的，非常直白。其实，这种简单粗暴的实现方式，非常适合我们常见的线程安全类实现，不必纠结于 synchronized 性能之类的，有人说“过早优化是万恶之源”，考虑可靠性、正确性和代码可读性才是大多数应用开发最重要的因素。</p>
<p>为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。</p>
<p>另外，这个内部数组应该创建成多大的呢？如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy。</p>
<p>前面我讲的这些内容，在具体的代码书写中，应该如何选择呢？</p>
<p>在没有线程安全问题的情况下，全部拼接操作是应该都用 StringBuilder 实现吗？毕竟这样书写的代码，还是要多敲很多字的，可读性也不理想，下面的对比非常明显。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strByBuilder</span>  <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">StringBuilder</span>().append(<span class="string">&quot;aa&quot;</span>).append(<span class="string">&quot;bb&quot;</span>).append(<span class="string">&quot;cc&quot;</span>).append</span><br><span class="line">            (<span class="string">&quot;dd&quot;</span>).toString();</span><br><span class="line">         </span><br><span class="line"><span class="type">String</span> <span class="variable">strByConcat</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span> + <span class="string">&quot;bb&quot;</span> + <span class="string">&quot;cc&quot;</span> + <span class="string">&quot;dd&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>其实，在通常情况下，没有必要过于担心，要相信 Java 还是非常智能的。</p>
<p>我们来做个实验，把下面一段代码，利用不同版本的 JDK 编译，然后再反编译，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConcat</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> str + “aa” + “bb”;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先编译再反编译，比如使用不同版本的 JDK：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;JAVA_HOME&#125;/bin/javac StringConcat.java</span><br><span class="line">$&#123;JAVA_HOME&#125;/bin/javap -v StringConcat.class</span><br></pre></td></tr></table></figure>

<p>JDK 8 的输出片段是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line"> <span class="number">3</span>: dup</span><br><span class="line"> <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"> <span class="number">7</span>: aload_0</span><br><span class="line"> <span class="number">8</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="number">11</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String aa</span></span><br><span class="line"><span class="number">13</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="number">16</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String bb</span></span><br><span class="line"><span class="number">18</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="number">21</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br></pre></td></tr></table></figure>

<p>而在 JDK 9 中，反编译的结果就会有点特别了，片段是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// concat method</span></span><br><span class="line"><span class="number">1</span>: invokedynamic #<span class="number">2</span>,  <span class="number">0</span>              <span class="comment">// InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 实际是利用了MethodHandle,统一了入口</span></span><br><span class="line"><span class="number">0</span>: #<span class="number">15</span> REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br></pre></td></tr></table></figure>

<p>你可以看到，非静态的拼接逻辑在 JDK 8 中会自动被 javac 转换为 StringBuilder 操作；而在 JDK 9 里面，则是体现了思路的变化。Java 9 利用 InvokeDynamic，将字符串拼接的优化与 javac 生成的字节码解耦，假设未来 JVM 增强相关运行时实现，将不需要依赖 javac 的任何修改。</p>
<p>在日常编程中，保证程序的可读性、可维护性，往往比所谓的最优性能更重要，你可以根据实际需求酌情选择具体的编码方式。</p>
<ol>
<li>字符串缓存</li>
</ol>
<p>我们粗略统计过，把常见应用进行堆转储（Dump Heap），然后分析对象组成，会发现平均 25% 的对象是字符串，并且其中约半数是重复的。如果能避免创建重复字符串，可以有效降低内存消耗和对象创建开销。</p>
<p>String 在 Java 6 以后提供了 intern() 方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。一般来说，JVM 会将所有的类似“abc”这样的文本字符串，或者字符串常量之类缓存起来。</p>
<p>看起来很不错是吧？但实际情况估计会让你大跌眼镜。一般使用 Java 6 这种历史版本，并不推荐大量使用 intern，为什么呢？魔鬼存在于细节中，被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到。所以，如果使用不当，OOM 就会光顾。</p>
<p>在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在 JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。你可以使用下面的参数直接打印具体数字，可以拿自己的 JDK 立刻试验一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintStringTableStatistics</span><br></pre></td></tr></table></figure>

<p>你也可以使用下面的 JVM 参数手动调整大小，但是绝大部分情况下并不需要调整，除非你确定它的大小已经影响了操作效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:StringTableSize=N</span><br></pre></td></tr></table></figure>

<p>Intern 是一种<strong>显式地排重机制</strong>，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。</p>
<p>幸好在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是 G1 GC 下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是 JVM 底层的改变，并不需要 Java 类库做什么修改。</p>
<p>注意这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用 G1 GC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UseStringDeduplication</span><br></pre></td></tr></table></figure>

<p>前面说到的几个方面，只是 Java 底层对字符串各种优化的一角，在运行时，字符串的一些基础操作会直接利用 JVM 内部的 Intrinsic 机制，往往运行的就是特殊优化的本地代码，而根本就不是 Java 代码生成的字节码。Intrinsic 可以简单理解为，是一种利用 native 方式 hard-coded 的逻辑，算是一种特别的内联，很多优化还是需要直接使用特定的 CPU 指令，具体可以看相关<a href="http://hg.openjdk.java.net/jdk/jdk/file/44b64fc0baa3/src/hotspot/share/classfile/vmSymbols.hpp">源码</a>，搜索“string”以查找相关 Intrinsic 定义。当然，你也可以在启动实验应用时，使用下面参数，了解 intrinsic 发生的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining</span><br><span class="line">    <span class="comment">//样例输出片段  </span></span><br><span class="line">        <span class="number">180</span>    <span class="number">3</span>       <span class="number">3</span>       java.lang.String::charAt (<span class="number">25</span> bytes)  </span><br><span class="line">                                  @ <span class="number">1</span>   java.lang.String::isLatin1 (<span class="number">19</span> bytes)   </span><br><span class="line">                                  ...  </span><br><span class="line">                                  @ <span class="number">7</span> java.lang.StringUTF16::getChar (<span class="number">60</span> bytes) intrinsic </span><br></pre></td></tr></table></figure>

<p>可以看出，仅仅是字符串一个实现，就需要 Java 平台工程师和科学家付出如此大且默默无闻的努力，我们得到的很多便利都是来源于此。</p>
<p>我会在专栏后面的 JVM 和性能等主题，详细介绍 JVM 内部优化的一些方法，如果你有兴趣可以再深入学习。即使你不做 JVM 开发或者暂时还没有使用到特别的性能优化，这些知识也能帮助你增加技术深度。</p>
<ol>
<li>String 自身的演化</li>
</ol>
<p>如果你仔细观察过 Java 的字符串，在历史版本中，它是使用 char 数组来存数据的，这样非常直接。但是 Java 中的 char 是两个 bytes 大小，拉丁语系语言的字符，根本就不需要太宽的 char，这样无区别的实现就造成了一定的浪费。密度是编程语言平台永恒的话题，因为归根结底绝大部分任务是要来操作数据的。</p>
<p>其实在 Java 6 的时候，Oracle JDK 就提供了压缩字符串的特性，但是这个特性的实现并不是开源的，而且在实践中也暴露出了一些问题，所以在最新的 JDK 版本中已经将它移除了。</p>
<p>在 Java 9 中，我们引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。将数据存储方式从 char 数组，改变为一个 byte 数组加上一个标识编码的所谓 coder，并且将相关字符串操作类都进行了修改。另外，所有相关的 Intrinsic 之类也都进行了重写，以保证没有任何性能损失。</p>
<p>虽然底层实现发生了这么大的改变，但是 Java 字符串的行为并没有任何大的变化，所以这个特性对于绝大部分应用来说是透明的，绝大部分情况不需要修改已有代码。</p>
<p>当然，在极端情况下，字符串也出现了一些能力退化，比如最大字符串的大小。你可以思考下，原来 char 数组的实现，字符串的最大长度就是数组本身的长度限制，但是替换成 byte 数组，同样数组长度下，存储能力是退化了一倍的！还好这是存在于理论中的极限，还没有发现现实应用受此影响。</p>
<p>在通用的性能测试和产品实验中，我们能非常明显地看到紧凑字符串带来的优势，<strong>即更小的内存占用、更快的操作速度</strong>。</p>
<p>今天我从 String、StringBuffer 和 StringBuilder 的主要设计和实现特点开始，分析了字符串缓存的 intern 机制、非代码侵入性的虚拟机层面排重、Java 9 中紧凑字符的改进，并且初步接触了 JVM 的底层优化机制 intrinsic。从实践的角度，不管是 Compact Strings 还是底层 intrinsic 优化，都说明了使用 Java 基础类库的优势，它们往往能够得到最大程度、最高质量的优化，而且只要升级 JDK 版本，就能零成本地享受这些益处。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title>02 Exception和Error有什么区别？</title>
    <url>/2024/09/22/2024-09-22-02-Exception%E5%92%8CError%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="02-Exception和Error有什么区别？"><a href="#02-Exception和Error有什么区别？" class="headerlink" title="02 Exception和Error有什么区别？"></a>02 Exception和Error有什么区别？</h1><p>世界上存在永远不会出错的程序吗？也许这只会出现在程序员的梦中。随着编程语言和软件的诞生，异常情况就如影随形地纠缠着我们，只有正确处理好意外情况，才能保证程序的可靠性。</p>
<p>Java 语言在设计之初就提供了相对完善的异常处理机制，这也是 Java 得以大行其道的原因之一，因为这种机制大大降低了编写和维护可靠程序的门槛。如今，异常处理机制已经成为现代编程语言的标配。</p>
<p>今天我要问你的问题是，<strong>请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p>
<p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p>
<p>Exception 又分为<strong>可检查</strong>（checked）异常和<strong>不检查</strong>（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。</p>
<p>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>分析 Exception 和 Error 的区别，是从概念角度考察了 Java 处理机制。总的来说，还处于理解的层面，面试者只要阐述清楚就好了。</p>
<p>我们在日常编程中，如何处理好异常是比较考验功底的，我觉得需要掌握两个方面。</p>
<p>第一，<strong>理解 Throwable、Exception、Error 的设计和分类</strong>。比如，掌握那些应用最为广泛的子类，以及如何自定义异常等。</p>
<p>很多面试官会进一步追问一些细节，比如，你了解哪些 Error、Exception 或者 RuntimeException？我画了一个简单的类图，并列出来典型例子，可以给你作为参考，至少做到基本心里有数。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/accba531a365e6ae39614ebfa3273900-20221026231601-msc2mtc.png" alt="img"></p>
<p>其中有些子类型，最好重点理解一下，比如 NoClassDefFoundError 和 ClassNotFoundException 有什么区别，这也是个经典的入门题目。</p>
<p>第二，<strong>理解 Java 语言中操作 Throwable 的元素和实践</strong>。掌握最基本的语法是必须的，如 try-catch-finally 块，throw、throws 关键字等。与此同时，也要懂得如何处理典型场景。</p>
<p>异常处理代码比较繁琐，比如我们需要写很多千篇一律的捕获代码，或者在 finally 里面做一些资源回收工作。随着 Java 语言的发展，引入了一些更加便利的特性，比如 try-with-resources 和 multiple catch，具体可以参考下面的代码段。在编译时期，会自动生成相应的处理逻辑，比如，自动按照约定俗成 close 那些扩展了 AutoCloseable 或者 Closeable 的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(…);</span><br><span class="line">     <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(…)) &#123;<span class="comment">// Try-with-resources</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">catch</span> ( IOException | XEception e) &#123;<span class="comment">// Multiple catch</span></span><br><span class="line">   <span class="comment">// Handle it</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>前面谈的大多是概念性的东西，下面我来谈些实践中的选择，我会结合一些代码用例进行分析。</p>
<p>先开看第一个吧，下面的代码反映了异常处理中哪些不当之处？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 业务代码</span></span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">  Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">// Ignore it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码虽然很短，但是已经违反了异常处理的两个基本原则。</p>
<p>第一，尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常，在这里是 Thread.sleep() 抛出的 InterruptedException。</p>
<p>这是因为在日常的开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作的艺术，所以我们有义务让自己的代码能够直观地体现出尽量多的信息，而泛泛的 Exception 之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望 RuntimeException 被扩散出来，而不是被捕获。</p>
<p>进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。</p>
<p>第二，不要生吞（swallow）异常。这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。</p>
<p>生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设！</p>
<p>如果我们不把异常抛出来，或者也没有输出到日志（Logger）之类，程序可能在后续代码以不可控的方式结束。没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p>
<p>再来看看第二段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 业务代码</span></span><br><span class="line">   <span class="comment">// …</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码作为一段实验代码，它是没有任何问题的，但是在产品代码中，通常都不允许这样处理。你先思考一下这是为什么呢？</p>
<p>我们先来看看<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Throwable.html#printStackTrace--">printStackTrace()</a>的文档，开头就是“Prints this throwable and its backtrace to the <strong>standard error stream</strong>”。问题就在这里，在稍微复杂一点的生产系统中，标准出错（STERR）不是个合适的输出选项，因为你很难判断出到底输出到哪里去了。</p>
<p>尤其是对于分布式系统，如果发生异常，但是无法找到堆栈轨迹（stacktrace），这纯属是为诊断设置障碍。所以，最好使用产品日志，详细地输出到日志系统里。</p>
<p>我们接下来看下面的代码段，体会一下** Throw early, catch late 原则。**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readPreferences</span><span class="params">(String fileName)</span>&#123;</span><br><span class="line">   <span class="comment">//...perform operations... </span></span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line">   <span class="comment">//...read the preferences file...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 fileName 是 null，那么程序就会抛出 NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位。这个 NPE 只是作为例子，实际产品代码中，可能是各种情况，比如获取配置失败之类的。在发现问题的时候，第一时间抛出，能够更加清晰地反映问题。</p>
<p>我们可以修改一下，让问题“throw early”，对应的异常信息就非常直观了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readPreferences</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">  Objects. requireNonNull(filename);</span><br><span class="line">  <span class="comment">//...perform other operations... </span></span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line">   <span class="comment">//...read the preferences file...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处理，可以选择保留原有异常的 cause 信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。</p>
<p>有的时候，我们会根据需要自定义异常，这个时候除了保证提供足够的信息，还有两点需要考虑：</p>
<ul>
<li>是否需要定义成 Checked Exception，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类。</li>
<li>在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。如果我们看 Java 的标准类库，你可能注意到类似 java.net.ConnectException，出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机器名、IP、端口等，一个重要考量就是信息安全。类似的情况在日志中也有，比如，用户数据一般是不可以输出到日志里面的。</li>
</ul>
<p>业界有一种争论（甚至可以算是某种程度的共识），Java 语言的 Checked Exception 也许是个设计错误，反对者列举了几点：</p>
<ul>
<li>Checked Exception 的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception 的使用，已经大大偏离了最初的设计目的。</li>
<li>Checked Exception 不兼容 functional 编程，如果你写过 Lambda&#x2F;Stream 代码，相信深有体会。</li>
</ul>
<p>很多开源项目，已经采纳了这种实践，比如 Spring、Hibernate 等，甚至反映在新的编程语言设计中，比如 Scala 等。 如果有兴趣，你可以参考：</p>
<p><a href="http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/">http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/。</a></p>
<p>当然，很多人也觉得没有必要矫枉过正，因为确实有一些异常，比如和环境相关的 IO、网络等，其实是存在可恢复性的，而且 Java 已经通过业界的海量实践，证明了其构建高质量软件的能力。我就不再进一步解读了，感兴趣的同学可以点击**<a href="https://v.qq.com/x/page/d0635rf5x0o.html">链接</a>**，观看 Bruce Eckel 在 2018 年全球软件开发大会 QCon 的分享 Failing at Failing: How and Why We’ve Been Nonchalantly Moving Away From Exception Handling。</p>
<p>我们从性能角度来审视一下 Java 的异常处理机制，这里有两个可能会相对昂贵的地方：</p>
<ul>
<li>try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if&#x2F;else、switch）要低效。</li>
<li>Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</li>
</ul>
<p>所以，对于部分追求极致性能的底层类库，有种方式是尝试创建不进行栈快照的 Exception。这本身也存在争议，因为这样做的假设在于，我创建异常时知道未来是否需要堆栈。问题是，实际上可能吗？小范围或许可能，但是在大规模项目中，这么做可能不是个理智的选择。如果需要堆栈，但又没有收集这些信息，在复杂情况下，尤其是类似微服务这种分布式系统，这会大大增加诊断的难度。</p>
<p>当我们的服务出现反应变慢、吞吐量下降的时候，检查发生最频繁的 Exception 也是一种思路。关于诊断后台变慢的问题，我会在后面的 Java 性能基础模块中系统探讨。</p>
<p>今天，我从一个常见的异常处理概念问题，简单总结了 Java 异常处理的机制。并结合代码，分析了一些普遍认可的最佳实践，以及业界最新的一些异常使用共识。最后，我分析了异常性能开销，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>06 动态代理是基于什么原理？</title>
    <url>/2024/09/22/2024-09-22-06-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="06-动态代理是基于什么原理？"><a href="#06-动态代理是基于什么原理？" class="headerlink" title="06 动态代理是基于什么原理？"></a>06 动态代理是基于什么原理？</h1><p>编程语言通常有各种不同的分类角度，动态类型和静态类型就是其中一种分类角度，简单区分就是语言类型信息是在运行时检查，还是编译期检查。</p>
<p>与其近似的还有一个对比，就是所谓强类型和弱类型，就是不同类型变量赋值时，是否需要显式地（强制）进行类型转换。</p>
<p>那么，如何分类 Java 语言呢？通常认为，Java 是静态的强类型语言，但是因为提供了类似反射等机制，也具备了部分动态类型语言的能力。</p>
<p>言归正传，今天我要问你的问题是，<strong>谈谈 Java 反射机制，动态代理是基于什么原理？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时<strong>自省</strong>（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p>
<p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>这个题目给我的第一印象是稍微有点诱导的嫌疑，可能会下意识地以为动态代理就是利用反射机制实现的，这么说也不算错但稍微有些不全面。功能才是目的，实现的方法有很多。总的来说，这道题目考察的是 Java 语言的另外一种基础机制： 反射，它就像是一种魔法，引入运行时自省能力，赋予了 Java 语言令人意外的活力，通过运行时操作元数据或对象，Java 可以灵活地操作运行时才能确定的信息。而动态代理，则是延伸出来的一种广泛应用于产品开发中的技术，很多繁琐的重复编程，都可以被动态代理机制优雅地解决。</p>
<p>从考察知识点的角度，这道题涉及的知识点比较庞杂，所以面试官能够扩展或者深挖的内容非常多，比如：</p>
<ul>
<li>考察你对反射机制的了解和掌握程度。</li>
<li>动态代理解决了什么问题，在你业务系统中的应用场景是什么？</li>
<li>JDK 动态代理在设计和实现上与 cglib 等方式有什么不同，进而如何取舍？</li>
</ul>
<p>这些考点似乎不是短短一篇文章能够囊括的，我会在知识扩展部分尽量梳理一下。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ol>
<li>反射机制及其演进</li>
</ol>
<p>对于 Java 语言的反射机制本身，如果你去看一下 java.lang 或 java.lang.reflect 包下的相关抽象，就会有一个很直观的印象了。Class、Field、Method、Constructor 等，这些完全就是我们去操作类和对象的元数据对应。反射各种典型用例的编程，相信有太多文章或书籍进行过详细的介绍，我就不再赘述了，至少你需要掌握基本场景编程，这里是官方提供的参考文档：</p>
<p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">https://docs.oracle.com/javase/tutorial/reflect/index.html</a> 。</p>
<p>关于反射，有一点我需要特意提一下，就是反射提供的 AccessibleObject.setAccessible(boolean flag)。它的子类也大都重写了这个方法，这里的所谓 accessible 可以理解成修饰成员的 public、protected、private，这意味着我们可以在运行时修改成员访问限制！</p>
<p>setAccessible 的应用场景非常普遍，遍布我们的日常开发、测试、依赖注入等各种框架中。比如，在 O&#x2F;R Mapping 框架中，我们为一个 Java 实体对象，运行时自动生成 setter、getter 的逻辑，这是加载或者持久化数据非常必要的，框架通常可以利用反射做这个事情，而不需要开发者手动写类似的重复代码。</p>
<p>另一个典型场景就是绕过 API 访问控制。我们日常开发时可能被迫要调用内部 API 去做些事情，比如，自定义的高性能 NIO 框架需要显式地释放 DirectBuffer，使用反射绕开限制是一种常见办法。</p>
<p>但是，在 Java 9 以后，这个方法的使用可能会存在一些争议，因为 Jigsaw 项目新增的模块化系统，出于强封装性的考虑，对反射访问进行了限制。Jigsaw 引入了所谓 Open 的概念，只有当被反射操作的模块和指定的包对反射调用者模块 Open，才能使用 setAccessible；否则，被认为是不合法（illegal）操作。如果我们的实体类是定义在模块里面，我们需要在模块描述符中明确声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MyEntities &#123;</span><br><span class="line">    <span class="comment">// Open for reflection</span></span><br><span class="line">    opens com.mycorp to java.persistence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为反射机制使用广泛，根据社区讨论，目前，Java 9 仍然保留了兼容 Java 8 的行为，但是很有可能在未来版本，完全启用前面提到的针对 setAccessible 的限制，即只有当被反射操作的模块和指定的包对反射调用者模块 Open，才能使用 setAccessible，我们可以使用下面参数显式设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--illegal-access=&#123; permit | warn | deny &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>动态代理</li>
</ol>
<p>前面的问题问到了动态代理，我们一起看看，它到底是解决什么问题？</p>
<p>首先，它是一个<strong>代理机制</strong>。如果熟悉设计模式中的代理模式，我们会知道，代理可以看作是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成。其实很多动态代理场景，我认为也可以看作是装饰器（Decorator）模式的应用，我会在后面的专栏设计模式主题予以补充。</p>
<p>通过代理可以让调用者与实现者之间<strong>解耦</strong>。比如进行 RPC 调用，框架内部的寻址、序列化、反序列化等，对于调用者往往是没有太大意义的，通过代理，可以提供更加友善的界面。</p>
<p>代理的发展经历了静态到动态的过程，源于静态代理引入的额外工作。类似早期的 RMI 之类古董技术，还需要 rmic 之类工具生成静态 stub 等各种文件，增加了很多繁琐的准备工作，而这又和我们的业务逻辑没有关系。利用动态代理机制，相应的 stub 等类，可以在运行时生成，对应的调用操作也是动态完成，极大地提高了我们的生产力。改进后的 RMI 已经不再需要手动去准备这些了，虽然它仍然是相对古老落后的技术，未来也许会逐步被移除。</p>
<p>这么说可能不够直观，我们可以看 JDK 动态代理的一个简单例子。下面只是加了一句 print，在生产系统中，我们可以轻松扩展类似逻辑进行诊断、限流等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDynamicProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloImpl</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(hello);</span><br><span class="line">        <span class="comment">// 构造代码实例</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxyHello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(HelloImpl.class.getClassLoader(), HelloImpl.class.getInterfaces(), handler);</span><br><span class="line">        <span class="comment">// 调用代理方法</span></span><br><span class="line">        proxyHello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span>  <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Invoking sayHello&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 JDK Proxy 例子，非常简单地实现了动态代理的构建和代理操作。首先，实现对应的 InvocationHandler；然后，以接口 Hello 为纽带，为被调用目标构建代理对象，进而应用程序就可以使用代理对象间接运行调用目标的逻辑，代理为应用插入额外逻辑（这里是 println）提供了便利的入口。</p>
<p>从 API 设计和实现的角度，这种实现仍然有局限性，因为它是以接口为中心的，相当于添加了一种对于被调用者没有太大意义的限制。我们实例化的是 Proxy 对象，而不是真正的被调用类型，这在实践中还是可能带来各种不便和能力退化。</p>
<p>如果被调用者没有实现接口，而我们还是希望利用动态代理机制，那么可以考虑其他方式。我们知道 Spring AOP 支持两种模式的动态代理，JDK Proxy 或者 cglib，如果我们选择 cglib 方式，你会发现对接口的依赖被克服了。</p>
<p>cglib 动态代理采取的是创建目标类的子类的方式，因为是子类化，我们可以达到近似使用被调用者本身的效果。在 Spring 编程中，框架通常会处理这种情况，当然我们也可以<a href="http://cliffmeyers.com/blog/2006/12/29/spring-aop-cglib-or-jdk-dynamic-proxies.html">显式指定</a>。关于类似方案的实现细节，我就不再详细讨论了。</p>
<p>那我们在开发中怎样选择呢？我来简单对比下两种方式各自优势。</p>
<p>JDK Proxy 的优势：</p>
<ul>
<li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li>
<li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li>
<li>代码实现简单。</li>
</ul>
<p>基于类似 cglib 框架的优势：</p>
<ul>
<li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。</li>
<li>只操作我们关心的类，而不必为其他相关类增加工作量。</li>
<li>高性能。</li>
</ul>
<p>另外，从性能角度，我想补充几句。记得有人曾经得出结论说 JDK Proxy 比 cglib 或者 Javassist 慢几十倍。坦白说，不去争论具体的 benchmark 细节，在主流 JDK 版本中，JDK Proxy 在典型场景可以提供对等的性能水平，数量级的差距基本上不是广泛存在的。而且，反射机制性能在现代 JDK 中，自身已经得到了极大的改进和优化，同时，JDK 很多功能也不完全是反射，同样使用了 ASM 进行字节码操作。</p>
<p>我们在选型中，性能未必是唯一考量，可靠性、可维护性、编程工作量等往往是更主要的考虑因素，毕竟标准类库和反射编程的门槛要低得多，代码量也是更加可控的，如果我们比较下不同开源项目在动态代理开发上的投入，也能看到这一点。</p>
<p>动态代理应用非常广泛，虽然最初多是因为 RPC 等使用进入我们视线，但是动态代理的使用场景远远不仅如此，它完美符合 Spring AOP 等切面编程。我在后面的专栏还会进一步详细分析 AOP 的目的和能力。简单来说它可以看作是对 OOP 的一个补充，因为 OOP 对于跨越不同对象或类的分散、纠缠逻辑表现力不够，比如在不同模块的特定阶段做一些事情，类似日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等，你可以参考下面这张图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/ba9a5b6228b188f5b9b15017e29a302b-20221026233834-arw5cxj.png" alt="img"></p>
<p>AOP 通过（动态）代理机制可以让开发者从这些繁琐事项中抽身出来，大幅度提高了代码的抽象程度和复用度。从逻辑上来说，我们在软件设计和实现中的类似代理，如 Facade、Observer 等很多设计目的，都可以通过动态代理优雅地实现。</p>
<p>今天我简要回顾了反射机制，谈了反射在 Java 语言演进中正在发生的变化，并且进一步探讨了动态代理机制和相关的切面编程，分析了其解决的问题，并探讨了生产实践中的选择考量。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代理</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>07 int和Integer有什么区别？</title>
    <url>/2024/09/22/2024-09-22-07-int%E5%92%8CInteger%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="07-int和Integer有什么区别？"><a href="#07-int和Integer有什么区别？" class="headerlink" title="07 int和Integer有什么区别？"></a>07 int和Integer有什么区别？</h1><p>Java 虽然号称是面向对象的语言，但是原始数据类型仍然是重要的组成元素，所以在面试中，经常考察原始数据类型和包装类等 Java 语言特性。</p>
<p>今天我要问你的问题是，<strong>int 和 Integer 有什么区别？谈谈 Integer 的值缓存范围。</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>int 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types，boolean、byte 、short、char、int、float、double、long）之一。<strong>Java 语言虽然号称一切都是对象，但原始数据类型是例外。</strong></p>
<p>Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了自动装箱和自动拆箱功能（boxing&#x2F;unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。</p>
<p>关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，<strong>这个值默认缓存是 -128 到 127 之间。</strong></p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天这个问题涵盖了 Java 里的两个基础要素：原始数据类型、包装类。谈到这里，就可以非常自然地扩展到自动装箱、自动拆箱机制，进而考察封装类的一些设计和实践。坦白说，理解基本原理和用法已经足够日常工作需求了，但是要落实到具体场景，还是有很多问题需要仔细思考才能确定。</p>
<p>面试官可以结合其他方面，来考察面试者的掌握程度和思考逻辑，比如：</p>
<ul>
<li>我在专栏第 1 讲中介绍的 Java 使用的不同阶段：编译阶段、运行时，自动装箱 &#x2F; 自动拆箱是发生在什么阶段？</li>
<li>我在前面提到使用静态工厂方法 valueOf 会使用到缓存机制，那么自动装箱的时候，缓存机制起作用吗？</li>
<li>为什么我们需要原始数据类型，Java 的对象似乎也很高效，应用中具体会产生哪些差异？</li>
<li>阅读过 Integer 源码吗？分析下类或某些方法的设计要点。</li>
</ul>
<p>似乎有太多内容可以探讨，我们一起来分析一下。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ol>
<li>理解自动装箱、拆箱</li>
</ol>
<p>自动装箱实际上算是一种<strong>语法糖</strong>。什么是语法糖？可以简单理解为 Java 平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的。</p>
<p>像前面提到的整数，javac 替我们自动把装箱转换为 Integer.valueOf()，把拆箱替换为 Integer.intValue()，这似乎这也顺道回答了另一个问题，既然调用的是 Integer.valueOf，自然能够得到缓存的好处啊。</p>
<p>如何程序化的验证上面的结论呢？</p>
<p>你可以写一段简单的程序包含下面两句代码，然后反编译一下。当然，这是一种从表现倒推的方法，大多数情况下，我们还是直接参考规范文档会更加可靠，毕竟软件承诺的是遵循规范，而不是保持当前行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">unboxing</span> <span class="operator">=</span> integer ++;</span><br></pre></td></tr></table></figure>

<p>反编译输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method</span></span><br><span class="line">java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line"><span class="number">8</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method</span></span><br><span class="line">java/lang/Integer.intValue:()I</span><br></pre></td></tr></table></figure>

<p>这种缓存机制并不是只有 Integer 才有，同样存在于其他的一些包装类，比如：</p>
<ul>
<li>Boolean，缓存了 true&#x2F;false 对应实例，确切说，只会返回两个常量实例 Boolean.TRUE&#x2F;FALSE。</li>
<li>Short，同样是缓存了 -128 到 127 之间的数值。</li>
<li>Byte，数值有限，所以全部都被缓存。</li>
<li>Character，缓存范围’\u0000’ 到 ‘\u007F’。</li>
</ul>
<p>自动装箱 &#x2F; 自动拆箱似乎很酷，在编程实践中，有什么需要注意的吗？</p>
<p>原则上，<strong>建议避免无意中的装箱、拆箱行为</strong>，尤其是在性能敏感的场合，创建 10 万个 Java 对象和 10 万个整数的开销可不是一个数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。</p>
<p>我们其实可以把这个观点扩展开，使用原始数据类型、数组甚至本地代码实现等，在性能极度敏感的场景往往具有比较大的优势，用其替换掉包装类、动态数组（如 ArrayList）等可以作为性能优化的备选项。一些追求极致性能的产品或者类库，会极力避免创建过多对象。当然，在大多数产品代码里，并没有必要这么做，还是以开发效率优先。以我们经常会使用到的计数器实现为例，下面是一个常见的线程安全计数器实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果利用原始数据类型，可以将其修改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">CompactCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLongFieldUpdater&lt;CompactCounter&gt; updater = AtomicLongFieldUpdater.newUpdater(CompactCounter.class, <span class="string">&quot;counter&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        updater.incrementAndGet(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>源码分析</li>
</ol>
<p>考察是否阅读过、是否理解 JDK 源代码可能是部分面试官的关注点，这并不完全是一种苛刻要求，阅读并实践高质量代码也是程序员成长的必经之路，下面我来分析下 Integer 的源码。</p>
<p>整体看一下 Integer 的职责，它主要包括各种基础的常量，比如最大值、最小值、位数等；前面提到的各种静态工厂方法 valueOf()；获取环境变量数值的方法；各种转换方法，比如转换为不同进制的字符串，如 8 进制，或者反过来的解析方法等。我们进一步来看一些有意思的地方。</p>
<p>首先，继续深挖缓存，Integer 的缓存范围虽然默认是 -128 到 127，但是在特别的应用场景，比如我们明确知道应用会频繁使用更大的数值，这时候应该怎么办呢？</p>
<p>缓存上限值实际是可以根据需要调整的，JVM 提供了参数设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:AutoBoxCacheMax=N</span><br></pre></td></tr></table></figure>

<p>这些实现，都体现在<a href="http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/lang/Integer.java">java.lang.Integer</a>源码之中，并实现在 IntegerCache 的静态初始化块里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span>                VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第二，我们在分析字符串的设计实现时，提到过字符串是不可变的，保证了基本的信息安全和并发编程中的线程安全。如果你去看包装类里存储数值的成员变量“value”，你会发现，不管是 Integer 还 Boolean 等，都被声明为“private final”，所以，它们同样是不可变类型！</p>
<p>这种设计是可以理解的，或者说是必须的选择。想象一下这个应用场景，比如 Integer 提供了 getInteger() 方法，用于方便地读取系统属性，我们可以用属性来设置服务器某个服务的端口，如果我可以轻易地把获取到的 Integer 对象改变为其他数值，这会带来产品可靠性方面的严重问题。</p>
<p>第三，Integer 等包装类，定义了类似 SIZE 或者 BYTES 这样的常量，这反映了什么样的设计考虑呢？如果你使用过其他语言，比如 C、C++，类似整数的位数，其实是不确定的，可能在不同的平台，比如 32 位或者 64 位平台，存在非常大的不同。那么，在 32 位 JDK 或者 64 位 JDK 里，数据位数会有不同吗？或者说，这个问题可以扩展为，我使用 32 位 JDK 开发编译的程序，运行在 64 位 JDK 上，需要做什么特别的移植工作吗？</p>
<p>其实，这种移植对于 Java 来说相对要简单些，因为原始数据类型是不存在差异的，这些明确定义在<a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-4.html#jls-4.2">Java 语言规范</a>里面，不管是 32 位还是 64 位环境，开发者无需担心数据的位数差异。</p>
<p>对于应用移植，虽然存在一些底层实现的差异，比如 64 位 HotSpot JVM 里的对象要比 32 位 HotSpot JVM 大（具体区别取决于不同 JVM 实现的选择），但是总体来说，并没有行为差异，应用移植还是可以做到宣称的“一次书写，到处执行”，应用开发者更多需要考虑的是容量、能力等方面的差异。</p>
<ol>
<li>原始类型线程安全</li>
</ol>
<p>前面提到了线程安全设计，你有没有想过，原始数据类型操作是不是线程安全的呢？</p>
<p>这里可能存在着不同层面的问题：</p>
<ul>
<li>原始数据类型的变量，显然要使用并发相关手段，才能保证线程安全，这些我会在专栏后面的并发主题详细介绍。如果有线程安全的计算需要，建议考虑使用类似 AtomicInteger、AtomicLong 这样的线程安全类。</li>
<li>特别的是，部分比较宽的数据类型，比如 float、double，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值！</li>
</ul>
<ol>
<li>Java 原始数据类型和引用类型局限性</li>
</ol>
<p>前面我谈了非常多的技术细节，最后再从 Java 平台发展的角度来看看，原始数据类型、对象的局限性和演进。</p>
<p>对于 Java 应用开发者，设计复杂而灵活的类型系统似乎已经习以为常了。但是坦白说，毕竟这种类型系统的设计是源于很多年前的技术决定，现在已经逐渐暴露出了一些副作用，例如：</p>
<ul>
<li>原始数据类型和 Java 泛型并不能配合使用</li>
</ul>
<p>这是因为 Java 的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为 Object。</p>
<ul>
<li>无法高效地表达数据，也不便于表达复杂的数据结构，比如 vector 和 tuple</li>
</ul>
<p>我们知道 Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。</p>
<p>Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。</p>
<p>针对这些方面的增强，目前正在 OpenJDK 领域紧锣密鼓地进行开发，有兴趣的话你可以关注相关工程：<a href="http://openjdk.java.net/projects/valhalla/">http://openjdk.java.net/projects/valhalla/ </a>。</p>
<p>今天，我梳理了原始数据类型及其包装类，从源码级别分析了缓存机制等设计和实现细节，并且针对构建极致性能的场景，分析了一些可以借鉴的实践。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>int</tag>
        <tag>Integer</tag>
      </tags>
  </entry>
  <entry>
    <title>08 对比Vector、ArrayList、LinkedList有何区别？</title>
    <url>/2024/09/22/2024-09-22-08-%E5%AF%B9%E6%AF%94Vector%E3%80%81ArrayList%E3%80%81LinkedList%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="08-对比Vector、ArrayList、LinkedList有何区别？"><a href="#08-对比Vector、ArrayList、LinkedList有何区别？" class="headerlink" title="08 对比Vector、ArrayList、LinkedList有何区别？"></a>08 对比Vector、ArrayList、LinkedList有何区别？</h1><p>我们在日常的工作中，能够高效地管理和操作数据是非常重要的。由于每个编程语言支持的数据结构不尽相同，比如我最早学习的 C 语言，需要自己实现很多基础数据结构，管理和操作会比较麻烦。相比之下，Java 则要方便的多，针对通用场景的需求，Java 提供了强大的集合框架，大大提高了开发者的生产力。</p>
<p>今天我要问你的是有关集合框架方面的问题，<strong>对比 Vector、ArrayList、LinkedList 有何区别？</strong></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p>
<p>Vector 是 Java 早期提供的线程<strong>安全的动态数组</strong>，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</p>
<p>ArrayList 是应用更加广泛的<strong>动态数组</strong>实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。</p>
<p>LinkedList 顾名思义是 Java 提供的<strong>双向链表</strong>，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</p>
<h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>似乎从我接触 Java 开始，这个问题就一直是经典的面试题，前面我的回答覆盖了三者的一些基本的设计和实现。</p>
<p>一般来说，也可以补充一下不同容器类型适合的场景：</p>
<ul>
<li>Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。</li>
<li>而 LinkedList 进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。</li>
</ul>
<p>所以，在应用开发中，如果事先可以估计到，应用操作是偏向于插入、删除，还是随机访问较多，就可以针对性的进行选择。这也是面试最常见的一个考察角度，给定一个场景，选择适合的数据结构，所以对于这种典型选择一定要掌握清楚。</p>
<p>考察 Java 集合框架，我觉得有很多方面需要掌握：</p>
<ul>
<li>Java 集合框架的设计结构，至少要有一个整体印象。</li>
<li>Java 提供的主要容器（集合和 Map）类型，了解或掌握对应的<strong>数据结构、算法</strong>，思考具体技术选择。</li>
<li>将问题扩展到性能、并发等领域。</li>
<li>集合框架的演进与发展。</li>
</ul>
<p>作为 Java 专栏，我会在尽量围绕 Java 相关进行扩展，否则光是罗列集合部分涉及的数据结构就要占用很大篇幅。这并不代表那些不重要，数据结构和算法是基本功，往往也是必考的点，有些公司甚至以考察这些方面而非常知名（甚至是“臭名昭著”）。我这里以需要掌握典型排序算法为例，你至少需要熟知：</p>
<ul>
<li>内部排序，至少掌握基础算法如归并排序、交换排序（冒泡、快排）、选择排序、插入排序等。</li>
<li>外部排序，掌握利用内存和外部存储处理超大数据集，至少要理解过程和思路。</li>
</ul>
<p>考察算法不仅仅是如何简单实现，面试官往往会刨根问底，比如哪些是排序是不稳定的呢（快排、堆排），或者思考稳定意味着什么；对不同数据集，各种排序的最好或最差情况；从某个角度如何进一步优化（比如空间占用，假设业务场景需要最小辅助空间，这个角度堆排序就比归并优异）等，从简单的了解，到进一步的思考，面试官通常还会观察面试者处理问题和沟通时的思路。</p>
<p>以上只是一个方面的例子，建议学习相关书籍，如《算法导论》《编程珠玑》等，或相关<a href="https://www.coursera.org/learn/algorithms-part1">教程</a>。对于特定领域，比如推荐系统，建议咨询领域专家。单纯从面试的角度，很多朋友推荐使用一些算法网站如 LeetCode 等，帮助复习和准备面试，但坦白说我并没有刷过这些算法题，这也是仁者见仁智者见智的事情，招聘时我更倾向于考察面试者自身最擅长的东西，免得招到纯面试高手。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>我们先一起来理解集合框架的整体设计，为了有个直观的印象，我画了一个简要的类图。注意，为了避免混淆，我这里没有把 java.util.concurrent 下面的线程安全容器添加进来；也没有列出 Map 容器，虽然通常概念上我们也会把 Map 作为集合框架的一部分，但是它本身并不是真正的集合（Collection）。</p>
<p>所以，我今天主要围绕狭义的集合框架，其他都会在专栏后面的内容进行讲解。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/assets/675536edf1563b11ab7ead0def1215c7-20221026235156-ruadx2l.png" alt="img"></p>
<p>我们可以看到 Java 的集合框架，Collection 接口是所有集合的根，然后扩展开提供了三大类集合，分别是：</p>
<ul>
<li>List，也就是我们前面介绍最多的有序集合，它提供了方便的访问、插入、删除等操作。</li>
<li>Set，Set 是不允许重复元素的，这是和 List 最明显的区别，也就是不存在两个对象 equals 返回 true。我们在日常开发中有很多需要保证元素唯一性的场合。</li>
<li>Queue&#x2F;Deque，则是 Java 提供的标准队列结构的实现，除了集合的基本功能，它还支持类似先入先出（FIFO， First-in-First-Out）或者后入先出（LIFO，Last-In-First-Out）等特定行为。这里不包括 BlockingQueue，因为通常是并发编程场合，所以被放置在并发包里。</li>
</ul>
<p>每种集合的通用逻辑，都被抽象到相应的抽象类之中，比如 AbstractList 就集中了各种 List 操作的通用部分。这些集合不是完全孤立的，比如，LinkedList 本身，既是 List，也是 Deque 哦。</p>
<p>如果阅读过更多<a href="http://hg.openjdk.java.net/jdk/jdk/file/bf9177eac58d/src/java.base/share/classes/java/util/TreeSet.java">源码</a>，你会发现，其实，TreeSet 代码里实际默认是利用 TreeMap 实现的，Java 类库创建了一个 Dummy 对象“PRESENT”作为 value，然后所有插入的元素其实是以键的形式放入了 TreeMap 里面；同理，HashSet 其实也是以 HashMap 为基础实现的，原来他们只是 Map 类的马甲！</p>
<p>就像前面提到过的，我们需要对各种具体集合实现，至少了解基本特征和典型使用场景，以 Set 的几个实现为例：</p>
<ul>
<li>TreeSet 支持自然顺序访问，但是添加、删除、包含等操作要相对低效（log(n) 时间）。</li>
<li>HashSet 则是利用哈希算法，理想情况下，如果哈希散列正常，可以提供常数时间的添加、删除、包含等操作，但是它不保证有序。</li>
<li>LinkedHashSet，内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序遍历的能力，与此同时，也保证了常数时间的添加、删除、包含等操作，这些操作性能略低于 HashSet，因为需要维护链表的开销。</li>
<li>在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，除非有必要，不然不要将其背后的 HashMap 容量设置过大。而对于 LinkedHashSet，由于其内部链表提供的方便，遍历性能只和元素多少有关系。</li>
</ul>
<p>我今天介绍的这些集合类，都不是线程安全的，对于 java.util.concurrent 里面的线程安全容器，我在专栏后面会去介绍。但是，并不代表这些集合完全不能支持并发编程的场景，在 Collections 工具类中，提供了一系列的 synchronized 方法，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span><br></pre></td></tr></table></figure>

<p>我们完全可以利用类似方法来实现基本的线程安全集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br></pre></td></tr></table></figure>

<p>它的实现，基本就是将每个基本方法，比如 get、set、add 之类，都通过 synchronized 添加基本的同步支持，非常简单粗暴，但也非常实用。注意这些方法创建的线程安全集合，都符合迭代时 fail-fast 行为，当发生意外的并发修改时，尽早抛出 ConcurrentModificationException 异常，以避免不可预计的行为。</p>
<p>另外一个经常会被考察到的问题，就是理解 Java 提供的默认排序算法，具体是什么排序方式以及设计思路等。</p>
<p>这个问题本身就是有点陷阱的意味，因为需要区分是 Arrays.sort() 还是 Collections.sort() （底层是调用 Arrays.sort()）；什么数据类型；多大的数据集（太小的数据集，复杂排序是没必要的，Java 会直接进行二分插入排序）等。</p>
<ul>
<li>对于原始数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序，你可以阅读<a href="http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/util/DualPivotQuicksort.java">源码</a>。</li>
<li>而对于对象数据类型，目前则是使用<a href="http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/util/TimSort.java">TimSort</a>，思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法。TimSort 并不是 Java 的独创，简单说它的思路是查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。</li>
</ul>
<p>另外，Java 8 引入了并行排序算法（直接使用 parallelSort 方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架（专栏后面会对 fork-join 进行相对详细的介绍），当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。</p>
<p>排序算法仍然在不断改进，最近双轴快速排序实现的作者提交了一个更进一步的改进，历时多年的研究，目前正在审核和验证阶段。根据作者的性能测试对比，相比于基于归并排序的实现，新改进可以提高随机数据排序速度提高 10%～20%，甚至在其他特征的数据集上也有几倍的提高，有兴趣的话你可以参考具体代码和介绍：</p>
<p><a href="http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-January/051000.html">http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-January/051000.html</a></p>
<p>在 Java 8 之中，Java 平台支持了 Lambda 和 Stream，相应的 Java 集合框架也进行了大范围的增强，以支持类似为集合创建相应 stream 或者 parallelStream 的方法实现，我们可以非常方便的实现函数式代码。</p>
<p>阅读 Java 源代码，你会发现，这些 API 的设计和实现比较独特，它们并不是实现在抽象类里面，而是以<strong>默认方法</strong>的形式实现在 Collection 这样的接口里！这是 Java 8 在语言层面的新特性，允许接口实现默认方法，理论上来说，我们原来实现在类似 Collections 这种工具类中的方法，大多可以转换到相应的接口上。针对这一点，我在面向对象主题，会专门梳理 Java 语言面向对象基本机制的演进。</p>
<p>在 Java 9 中，Java 标准类库提供了一系列的静态工厂方法，比如，List.of()、Set.of()，大大简化了构建小的容器实例的代码量。根据业界实践经验，我们发现相当一部分集合实例都是容量非常有限的，而且在生命周期中并不会进行修改。但是，在原有的 Java 类库中，我们可能不得不写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt;  list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>而利用新的容器静态工厂方法，一句代码就够了，并且保证了不可变性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; simpleList = List.of(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>更进一步，通过各种 of 静态工厂方法创建的实例，还应用了一些我们所谓的最佳实践，比如，它是不可变的，符合我们对线程安全的需求；它因为不需要考虑扩容，所以空间上更加紧凑等。</p>
<p>如果我们去看 of 方法的源码，你还会发现一个特别有意思的地方：我们知道 Java 已经支持所谓的可变参数（varargs），但是官方类库还是提供了一系列特定参数长度的方法，看起来似乎非常不优雅，为什么呢？这其实是为了最优的性能，JVM 在处理变长参数的时候会有明显的额外开销，如果你需要实现性能敏感的 API，也可以进行参考。</p>
<p>今天我从 Verctor、ArrayList、LinkedList 开始，逐步分析其设计实现区别、适合的应用场景等，并进一步对集合框架进行了简单的归纳，介绍了集合框架从基础算法到 API 设计实现的各种改进，希望能对你的日常开发和 API 设计能够有帮助。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>Vector</tag>
        <tag>ArrayList</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>HarmonyOS</title>
    <url>/2024/09/02/2024-09-02-HarmonyOS/</url>
    <content><![CDATA[<h1 id="HarmonyOS"><a href="#HarmonyOS" class="headerlink" title="HarmonyOS"></a>HarmonyOS</h1><h2 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">user</span>: <span class="built_in">string</span> = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>数字类型</strong>：number <strong>(包括了整型，浮点型等)</strong></p>
<p><strong>字符类型</strong>：string        </p>
<ul>
<li>“双引号”，’单引号’, `我今年${age}岁了`<strong>(表示形式)</strong></li>
</ul>
<p><strong>枚举类型</strong>：enum</p>
<p><strong>布尔类型</strong>：boolean</p>
<p><strong>联合类型</strong>：let flag: string | number | boolean <strong>(可以是这三种任意一个)</strong></p>
<h2 id="接口、对象、数组、ForEach循环"><a href="#接口、对象、数组、ForEach循环" class="headerlink" title="接口、对象、数组、ForEach循环"></a>接口、对象、数组、ForEach循环</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserInterface</span>&#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">flag</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用接口限定对象</span></span><br><span class="line"><span class="attr">userinfo</span>: <span class="title class_">UserInterface</span> = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="string">&#x27;20&#x27;</span>,</span><br><span class="line">    <span class="attr">flag</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="comment">//对象类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr3</span>: <span class="title class_">UserInterface</span>[] = [</span><br><span class="line">    &#123;</span><br><span class="line">        username = <span class="string">&#x27;王五&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">14</span>,</span><br><span class="line">        <span class="attr">flag</span>: flase</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="ForEach"><a href="#ForEach" class="headerlink" title="ForEach"></a>ForEach</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次从arr3中取出一个item，使用匿名方法进行操作。</span></span><br><span class="line"><span class="title class_">ForEach</span>(<span class="variable language_">this</span>.<span class="property">arr3</span>, <span class="function">(<span class="params">item: UserInterface</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>列表包裹元素可以进行屏幕滑动</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">List</span>()&#123;</span><br><span class="line">    <span class="comment">//必须由ListItem()为根组件</span></span><br><span class="line">    <span class="title class_">ListItem</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>允许表示一个已知元素数量和类型的数组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]	<span class="comment">// Yes</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]	<span class="comment">//No</span></span><br></pre></td></tr></table></figure>



<h2 id="ArkTsUI公共组件"><a href="#ArkTsUI公共组件" class="headerlink" title="ArkTsUI公共组件"></a>ArkTsUI公共组件</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Entry</span>	<span class="comment">//入口组件标记，表示可以直接由此进入一个页面</span></span><br><span class="line"><span class="meta">@Component</span>	<span class="comment">//组件标记，表示是一个组件</span></span><br><span class="line">struct <span class="title class_">Index</span> &#123;	<span class="comment">//组件都需要为struct关键字修饰</span></span><br><span class="line">  <span class="meta">@State</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello World&#x27;</span>;	</span><br><span class="line">  <span class="comment">//@State动态参数，声明之后，值改变后页面会自行渲染</span></span><br><span class="line">  <span class="title function_">build</span>(<span class="params"></span>) &#123;	<span class="comment">//Component组件都必须实现build方法</span></span><br><span class="line">    <span class="title class_">RelativeContainer</span>() &#123;	<span class="comment">//复杂组件容器</span></span><br><span class="line">      <span class="title class_">Column</span>(&#123;<span class="attr">space</span>: <span class="number">10</span>&#125;)&#123;	<span class="comment">//列容器，可以传入value，space：内部元素之间的间距</span></span><br><span class="line">        <span class="title class_">Column</span>()&#123;</span><br><span class="line">          <span class="title class_">Image</span>($r(<span class="string">&#x27;app.media.startIcon&#x27;</span>))	<span class="comment">//图片组件，可以传入本地图片或图片链接</span></span><br><span class="line">            <span class="comment">//$r()读取resources目录下的media资源，可以省略图片类型后缀</span></span><br><span class="line">            <span class="comment">//$rawfile(&#x27;test.jpg&#x27;)rawfile目录图片，只需要写图片名字，但是必须加上后缀</span></span><br><span class="line">            .<span class="title function_">width</span>(<span class="number">60</span>)	<span class="comment">//设置宽和高，直接写值为设置vp大小</span></span><br><span class="line">            .<span class="title function_">height</span>(<span class="number">60</span>)</span><br><span class="line">          <span class="title class_">Text</span>(<span class="string">&#x27;HUAWEI&#x27;</span>).<span class="title function_">fontSize</span>(<span class="number">15</span>).<span class="title function_">fontColor</span>(<span class="title class_">Color</span>.<span class="property">Black</span>).<span class="title function_">fontWeight</span>(<span class="title class_">FontWeight</span>.<span class="property">Bold</span>)</span><br><span class="line">            <span class="comment">//文本组件，fontSize设置文字大小，等</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Column</span>(&#123;<span class="attr">space</span>: <span class="number">10</span>&#125;)&#123;</span><br><span class="line">          <span class="title class_">TextInput</span>(&#123;<span class="attr">placeholder</span>: <span class="string">&#x27;请输入用户名&#x27;</span>&#125;)	</span><br><span class="line">            .<span class="title function_">width</span>(<span class="string">&#x27;80%&#x27;</span>)	<span class="comment">//设置百分比为占所在容器的多少，一般设置100%，组件默认就会居中</span></span><br><span class="line">          <span class="title class_">TextInput</span>(&#123;<span class="attr">placeholder</span>: <span class="string">&#x27;请输入密码&#x27;</span>&#125;)</span><br><span class="line">            .<span class="title function_">width</span>(<span class="string">&#x27;80%&#x27;</span>)</span><br><span class="line">            .<span class="title function_">type</span>(<span class="title class_">InputType</span>.<span class="property">Password</span>)	<span class="comment">//设置输入框类型</span></span><br><span class="line">          <span class="title class_">Button</span>(<span class="string">&#x27;登录&#x27;</span>)</span><br><span class="line">            .<span class="title function_">type</span>(<span class="title class_">ButtonType</span>.<span class="property">Capsule</span>)</span><br><span class="line">            .<span class="title function_">onClick</span>(<span class="function">() =&gt;</span> &#123;	<span class="comment">//点击事件</span></span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;.<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">          <span class="comment">//外边距</span></span><br><span class="line">      	.<span class="title function_">margin</span>(<span class="number">10</span>)	<span class="comment">//当前组件上下左右距离其他组件间隔10</span></span><br><span class="line">          <span class="comment">//margin(&#123;left: 10&#125;) 单独指定</span></span><br><span class="line">          <span class="comment">//内边距</span></span><br><span class="line">         .<span class="title function_">padding</span>(<span class="number">10</span>)	<span class="comment">//同理margin，但是是容器内部的组件间隔。</span></span><br><span class="line">      &#125;</span><br><span class="line">      .<span class="title function_">height</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">      .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">      .<span class="title function_">justifyContent</span>(<span class="title class_">FlexAlign</span>.<span class="property">Center</span>)	<span class="comment">//设置容器主轴的元素的排列对齐格式，Column为纵向。Row为横向。</span></span><br><span class="line">        <span class="comment">//alignItems设置主轴交叉轴的排列对齐格式，Row使用VerticalAlignn枚举，Col使用HorizontalAlign。</span></span><br><span class="line">      .<span class="title function_">backgroundColor</span>(<span class="string">&#x27;#EFEFEF&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>布局展示</strong></p>
<p><img src="https://pic.imge.cc/2024/09/02/66d5800885c58.png" alt="image-20240902162246246"></p>
<p><strong>练习</strong></p>
<p><img src="https://pic.imge.cc/2024/09/02/66d5800584b30.png" alt="image-20240902162913655"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct <span class="title class_">Index</span> &#123;</span><br><span class="line">  <span class="meta">@State</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">build</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">RelativeContainer</span>() &#123;</span><br><span class="line">      <span class="title class_">Column</span>(&#123;<span class="attr">space</span>: <span class="number">10</span>&#125;)&#123;</span><br><span class="line">        <span class="title class_">Column</span>()&#123;</span><br><span class="line">          <span class="title class_">Image</span>($r(<span class="string">&#x27;app.media.startIcon&#x27;</span>))</span><br><span class="line">            .<span class="title function_">width</span>(<span class="number">60</span>)</span><br><span class="line">            .<span class="title function_">height</span>(<span class="number">60</span>)</span><br><span class="line">          <span class="title class_">Text</span>(<span class="string">&#x27;HUAWEI&#x27;</span>).<span class="title function_">fontSize</span>(<span class="number">15</span>).<span class="title function_">fontColor</span>(<span class="title class_">Color</span>.<span class="property">Black</span>).<span class="title function_">fontWeight</span>(<span class="title class_">FontWeight</span>.<span class="property">Bold</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Column</span>(&#123;<span class="attr">space</span>: <span class="number">10</span>&#125;)&#123;</span><br><span class="line">          <span class="title class_">TextInput</span>(&#123;<span class="attr">placeholder</span>: <span class="string">&#x27;请输入用户名&#x27;</span>&#125;)</span><br><span class="line">            .<span class="title function_">width</span>(<span class="string">&#x27;80%&#x27;</span>)</span><br><span class="line">          <span class="title class_">TextInput</span>(&#123;<span class="attr">placeholder</span>: <span class="string">&#x27;请输入密码&#x27;</span>&#125;)</span><br><span class="line">            .<span class="title function_">width</span>(<span class="string">&#x27;80%&#x27;</span>)</span><br><span class="line">            .<span class="title function_">type</span>(<span class="title class_">InputType</span>.<span class="property">Password</span>)</span><br><span class="line">          <span class="title class_">Button</span>(<span class="string">&#x27;登录&#x27;</span>)</span><br><span class="line">            .<span class="title function_">type</span>(<span class="title class_">ButtonType</span>.<span class="property">Capsule</span>)</span><br><span class="line">            .<span class="title function_">onClick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;.<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      .<span class="title function_">height</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">      .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">      .<span class="title function_">justifyContent</span>(<span class="title class_">FlexAlign</span>.<span class="property">Center</span>)</span><br><span class="line">      .<span class="title function_">backgroundColor</span>(<span class="string">&#x27;#EFEFEF&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imge.cc/2024/09/02/66d58040ea8d2.png" alt="image-20240902164939725"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct <span class="title class_">Index</span> &#123;</span><br><span class="line">  <span class="meta">@State</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">build</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">RelativeContainer</span>() &#123;</span><br><span class="line">      <span class="title class_">Column</span>(&#123;<span class="attr">space</span>: <span class="number">10</span>&#125;)&#123;</span><br><span class="line">        <span class="title class_">Text</span>(<span class="string">&quot;图片大全&quot;</span>)</span><br><span class="line">          .<span class="title function_">backgroundColor</span>(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">          .<span class="title function_">fontColor</span>(<span class="title class_">Color</span>.<span class="property">White</span>)</span><br><span class="line">          .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">          .<span class="title function_">height</span>(<span class="number">30</span>)</span><br><span class="line">          .<span class="title function_">textAlign</span>(<span class="title class_">TextAlign</span>.<span class="property">Center</span>)<span class="comment">//调整text中文字的位置</span></span><br><span class="line">        <span class="title class_">Row</span>()&#123;</span><br><span class="line">          <span class="title class_">Image</span>(<span class="string">&quot;https://ts1.cn.mm.bing.net/th/id/R-C.66d7b796377883a92aad65b283ef1f84?rik=sQ%2fKoYAcr%2bOwsw&amp;riu=http%3a%2f%2fwww.quazero.com%2fuploads%2fallimg%2f140305%2f1-140305131415.jpg&amp;ehk=Hxl%2fQ9pbEiuuybrGWTEPJOhvrFK9C3vyCcWicooXfNE%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0&quot;</span>)</span><br><span class="line">            .<span class="title function_">objectFit</span>(<span class="title class_">ImageFit</span>.<span class="property">Cover</span>) <span class="comment">//设置图片对象填充样式，默认为cover，保持图片不失真</span></span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">        .<span class="title function_">height</span>(<span class="number">140</span>)</span><br><span class="line">        <span class="title class_">Row</span>(&#123;<span class="attr">space</span>: <span class="number">10</span>&#125;)&#123;</span><br><span class="line">         <span class="title class_">Column</span>()&#123;</span><br><span class="line">           <span class="title class_">Image</span>(<span class="string">&quot;https://ts1.cn.mm.bing.net/th/id/R-C.d88442788ee5a458d50e40f0a8cb1e05?rik=EoPp8GhejYeQfw&amp;riu=http%3a%2f%2fimg.pconline.com.cn%2fimages%2fupload%2fupc%2ftx%2fwallpaper%2f1307%2f10%2fc2%2f23151595_1373424485102.jpg&amp;ehk=J7xq%2f50bCmdD4jUXfnTlau2s5WiVsBxQArAjvJzqIo4%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0&quot;</span>)</span><br><span class="line">             .<span class="title function_">objectFit</span>(<span class="title class_">ImageFit</span>.<span class="property">Cover</span>)</span><br><span class="line">         &#125;</span><br><span class="line">          .<span class="title function_">layoutWeight</span>(<span class="number">2</span>)</span><br><span class="line">          .<span class="title function_">height</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">          <span class="title class_">Column</span>(&#123;<span class="attr">space</span>: <span class="number">5</span>&#125;)&#123;</span><br><span class="line">            <span class="title class_">Row</span>()&#123;</span><br><span class="line">              <span class="title class_">Image</span>(<span class="string">&quot;https://tse1-mm.cn.bing.net/th/id/OIP-C.SwMcwxwnFfYHMLbdB6X1AQHaEK?w=318&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.4&amp;pid=1.7&quot;</span>)</span><br><span class="line">                .<span class="title function_">objectFit</span>(<span class="title class_">ImageFit</span>.<span class="property">Cover</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">            .<span class="title function_">layoutWeight</span>(<span class="number">1</span>)</span><br><span class="line">            <span class="title class_">Row</span>()&#123;</span><br><span class="line">              <span class="title class_">Image</span>(<span class="string">&quot;https://tse3-mm.cn.bing.net/th/id/OIP-C.ofDJs_gFk7o_PdazIcWJygHaHa?w=180&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.4&amp;pid=1.7&quot;</span>)</span><br><span class="line">                .<span class="title function_">objectFit</span>(<span class="title class_">ImageFit</span>.<span class="property">Cover</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">            .<span class="title function_">layoutWeight</span>(<span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          .<span class="title function_">layoutWeight</span>(<span class="number">1</span>)	<span class="comment">//当前组件占据所在容器比重，如果容器中只有两个组件，layoutWeight值相等，则各占据50%</span></span><br><span class="line">          .<span class="title function_">height</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">        .<span class="title function_">height</span>(<span class="number">140</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">      .<span class="title function_">height</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stack组件"><a href="#Stack组件" class="headerlink" title="Stack组件"></a>Stack组件</h3><p>Stack组件可以实现容器堆叠，子组件按照顺序依次入栈，后一个组件覆盖前一个子组件</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Stack</span>(&#123;<span class="attr">alignContent</span>: <span class="title class_">Alignment</span>.<span class="property">xxx</span>&#125;)&#123;	<span class="comment">//通过这个设置，内部子组件的对齐方式</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="弹性布局（Flex）"><a href="#弹性布局（Flex）" class="headerlink" title="弹性布局（Flex）"></a>弹性布局（Flex）</h3><p>Flex布局，便于容器对子元素进行排列、对其、分配剩余空间</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240903111148081.png" alt="image-20240903111148081"></p>
<blockquote>
<p>默认显示方式和Row一样 -&gt; direction</p>
<p>默认是不换行的 -&gt; wrap, 设置为换行，则不会挤在一行自适应。</p>
</blockquote>
<h3 id="相对布局（RelativeContainer）"><a href="#相对布局（RelativeContainer）" class="headerlink" title="相对布局（RelativeContainer）"></a>相对布局（RelativeContainer）</h3><p>用于复杂场景中元素对其的布局，内部组件可以根据外部的RelativeContainer进行位置调整，也可以根据内部其他子组件进行位置调整。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240903112105924.png" alt="image-20240903112105924"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct <span class="title class_">RelativeContainerPage</span> &#123;</span><br><span class="line">  <span class="meta">@State</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">build</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Column</span>()&#123;</span><br><span class="line">      <span class="title class_">RelativeContainer</span>()&#123;</span><br><span class="line">        <span class="title class_">Text</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">          .<span class="title function_">width</span>(<span class="number">100</span>)</span><br><span class="line">          .<span class="title function_">height</span>(<span class="number">100</span>)</span><br><span class="line">          .<span class="title function_">lineHeight</span>(<span class="string">&#x27;200%&#x27;</span>) <span class="comment">//配置上下居中</span></span><br><span class="line">          .<span class="title function_">fontSize</span>(<span class="number">30</span>)</span><br><span class="line">          .<span class="title function_">textAlign</span>(<span class="title class_">TextAlign</span>.<span class="property">Center</span>)</span><br><span class="line">          .<span class="title function_">backgroundColor</span>(<span class="title class_">Color</span>.<span class="property">Red</span>)</span><br><span class="line">          .<span class="title function_">alignRules</span>(&#123;</span><br><span class="line">            <span class="attr">middle</span>:&#123;</span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;__container__&quot;</span>,  <span class="comment">//锚点，传入的为容器id</span></span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">HorizontalAlign</span>.<span class="property">Center</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">id</span>(<span class="string">&quot;text1&quot;</span>)</span><br><span class="line">        <span class="title class_">Text</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">          .<span class="title function_">width</span>(<span class="number">100</span>)</span><br><span class="line">          .<span class="title function_">height</span>(<span class="number">100</span>)</span><br><span class="line">          .<span class="title function_">lineHeight</span>(<span class="string">&#x27;200%&#x27;</span>) <span class="comment">//配置上下居中</span></span><br><span class="line">          .<span class="title function_">fontSize</span>(<span class="number">30</span>)</span><br><span class="line">          .<span class="title function_">textAlign</span>(<span class="title class_">TextAlign</span>.<span class="property">Center</span>)</span><br><span class="line">          .<span class="title function_">backgroundColor</span>(<span class="title class_">Color</span>.<span class="property">Yellow</span>)</span><br><span class="line">          .<span class="title function_">alignRules</span>(&#123;</span><br><span class="line">            <span class="attr">top</span>:&#123; <span class="comment">//这里的位置，指的是当前容器的top, middle, bottom等</span></span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;text1&quot;</span>,  <span class="comment">//锚点，传入的为容器id</span></span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">VerticalAlign</span>.<span class="property">Bottom</span></span><br><span class="line">            &#125;,  <span class="comment">//当前容器“text2”的顶部居于“text1”的底部之下</span></span><br><span class="line">            <span class="attr">left</span>:&#123;</span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;text1&quot;</span>,</span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">HorizontalAlign</span>.<span class="property">Start</span></span><br><span class="line">            &#125;  <span class="comment">//当前容器“text2”的左边居于“text1”的起始位置</span></span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">id</span>(<span class="string">&quot;text2&quot;</span>)</span><br><span class="line">        <span class="title class_">Text</span>(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">          .<span class="title function_">width</span>(<span class="number">100</span>)</span><br><span class="line">          .<span class="title function_">height</span>(<span class="number">100</span>)</span><br><span class="line">          .<span class="title function_">lineHeight</span>(<span class="string">&#x27;200%&#x27;</span>) <span class="comment">//配置上下居中</span></span><br><span class="line">          .<span class="title function_">fontSize</span>(<span class="number">30</span>)</span><br><span class="line">          .<span class="title function_">textAlign</span>(<span class="title class_">TextAlign</span>.<span class="property">Center</span>)</span><br><span class="line">          .<span class="title function_">backgroundColor</span>(<span class="title class_">Color</span>.<span class="property">Pink</span>)</span><br><span class="line">          .<span class="title function_">alignRules</span>(&#123;</span><br><span class="line">            <span class="attr">top</span>:&#123; <span class="comment">//这里的位置，指的是当前容器的top, middle, bottom等</span></span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;text1&quot;</span>,  <span class="comment">//锚点，传入的为容器id</span></span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">VerticalAlign</span>.<span class="property">Bottom</span></span><br><span class="line">            &#125;,  <span class="comment">//当前容器“text3”的顶部居于“text1”的底部之下</span></span><br><span class="line">            <span class="attr">right</span>:&#123;</span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;text1&quot;</span>,</span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">HorizontalAlign</span>.<span class="property">Start</span></span><br><span class="line">            &#125;  <span class="comment">//当前容器“text3”的右边居于“text1”的起始位置</span></span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">id</span>(<span class="string">&quot;text3&quot;</span>)</span><br><span class="line">        <span class="title class_">Text</span>(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">          .<span class="title function_">width</span>(<span class="number">100</span>)</span><br><span class="line">          .<span class="title function_">height</span>(<span class="number">100</span>)</span><br><span class="line">          .<span class="title function_">lineHeight</span>(<span class="string">&#x27;200%&#x27;</span>) <span class="comment">//配置上下居中</span></span><br><span class="line">          .<span class="title function_">fontSize</span>(<span class="number">30</span>)</span><br><span class="line">          .<span class="title function_">textAlign</span>(<span class="title class_">TextAlign</span>.<span class="property">Center</span>)</span><br><span class="line">          .<span class="title function_">backgroundColor</span>(<span class="title class_">Color</span>.<span class="property">Orange</span>)</span><br><span class="line">          .<span class="title function_">alignRules</span>(&#123;</span><br><span class="line">            <span class="attr">top</span>:&#123; <span class="comment">//这里的位置，指的是当前容器的top, middle, bottom等</span></span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;text1&quot;</span>,  <span class="comment">//锚点，传入的为容器id</span></span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">VerticalAlign</span>.<span class="property">Bottom</span></span><br><span class="line">            &#125;,  <span class="comment">//当前容器“text4”的顶部居于“text1”的底部之下</span></span><br><span class="line">            <span class="attr">left</span>:&#123;</span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;text1&quot;</span>,</span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">HorizontalAlign</span>.<span class="property">End</span></span><br><span class="line">            &#125;  <span class="comment">//当前容器“text4”的左边居于“text1”的起始位置</span></span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">id</span>(<span class="string">&quot;text4&quot;</span>)</span><br><span class="line">        <span class="title class_">Text</span>(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">          .<span class="title function_">width</span>(<span class="number">100</span>)</span><br><span class="line">          .<span class="title function_">height</span>(<span class="number">100</span>)</span><br><span class="line">          .<span class="title function_">lineHeight</span>(<span class="string">&#x27;200%&#x27;</span>) <span class="comment">//配置上下居中</span></span><br><span class="line">          .<span class="title function_">fontSize</span>(<span class="number">30</span>)</span><br><span class="line">          .<span class="title function_">textAlign</span>(<span class="title class_">TextAlign</span>.<span class="property">Center</span>)</span><br><span class="line">          .<span class="title function_">backgroundColor</span>(<span class="title class_">Color</span>.<span class="property">Green</span>)</span><br><span class="line">          .<span class="title function_">alignRules</span>(&#123;</span><br><span class="line">            <span class="attr">top</span>:&#123; <span class="comment">//这里的位置，指的是当前容器的top, middle, bottom等</span></span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;text2&quot;</span>,  <span class="comment">//锚点，传入的为容器id</span></span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">VerticalAlign</span>.<span class="property">Bottom</span></span><br><span class="line">            &#125;,  <span class="comment">//当前容器“text5”的顶部居于“text2”的底部之下</span></span><br><span class="line">            <span class="attr">left</span>:&#123;</span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;text2&quot;</span>,</span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">HorizontalAlign</span>.<span class="property">Start</span></span><br><span class="line">            &#125;  <span class="comment">//当前容器“text5”的左边居于“text2”的起始位置</span></span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">id</span>(<span class="string">&quot;text5&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      .<span class="title function_">width</span>(<span class="number">300</span>)</span><br><span class="line">      .<span class="title function_">height</span>(<span class="number">300</span>)</span><br><span class="line">      .<span class="title function_">border</span>(&#123;</span><br><span class="line">        <span class="attr">width</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">color</span>: <span class="title class_">Color</span>.<span class="property">Red</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    .<span class="title function_">height</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    .<span class="title function_">justifyContent</span>(<span class="title class_">FlexAlign</span>.<span class="property">Center</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240903112203598.png" alt="image-20240903112203598"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct <span class="title class_">ListPage</span>&#123;</span><br><span class="line">  <span class="meta">@State</span> <span class="attr">flag</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="title function_">build</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Column</span>()&#123;</span><br><span class="line">      <span class="title class_">Stack</span>(&#123;<span class="attr">alignContent</span>: <span class="title class_">Alignment</span>.<span class="property">BottomEnd</span>&#125;)&#123;	<span class="comment">//因为需要在列表之上加一个按钮，使用Stack包裹。</span></span><br><span class="line">        <span class="title class_">List</span>(&#123;<span class="attr">space</span>: <span class="number">10</span>&#125;)&#123;</span><br><span class="line">          <span class="title class_">ForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>], <span class="function">(<span class="params">item: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">ListItem</span>()&#123;</span><br><span class="line">              <span class="title class_">Text</span>(<span class="string">`<span class="subst">$&#123;item&#125;</span>`</span>)</span><br><span class="line">                .<span class="title function_">fontSize</span>(<span class="number">32</span>)</span><br><span class="line">                .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">                .<span class="title function_">height</span>(<span class="number">50</span>)</span><br><span class="line">                .<span class="title function_">backgroundColor</span>(<span class="string">&quot;#eee&quot;</span>)</span><br><span class="line">                .<span class="title function_">textAlign</span>(<span class="title class_">TextAlign</span>.<span class="property">Center</span>)</span><br><span class="line">                .<span class="title function_">borderRadius</span>(<span class="number">10</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="title function_">padding</span>(<span class="number">10</span>)</span><br><span class="line">        .<span class="title function_">height</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">	<span class="comment">//点击之后出现很多子组件按钮，使用RelativeContainer进行包裹</span></span><br><span class="line">        <span class="title class_">RelativeContainer</span>()&#123;</span><br><span class="line">          <span class="title class_">Button</span>()&#123;</span><br><span class="line">            <span class="title class_">Text</span>(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">              .<span class="title function_">fontColor</span>(<span class="title class_">Color</span>.<span class="property">White</span>)</span><br><span class="line">              .<span class="title function_">fontSize</span>(<span class="number">36</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          .<span class="title function_">width</span>(<span class="number">60</span>)</span><br><span class="line">          .<span class="title function_">height</span>(<span class="number">60</span>)</span><br><span class="line">          .<span class="title function_">id</span>(<span class="string">&quot;btn1&quot;</span>)	<span class="comment">//RelativeContainer中每个组件都需要有独一无二的id</span></span><br><span class="line">          .<span class="title function_">onClick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">flag</span> = !<span class="variable language_">this</span>.<span class="property">flag</span></span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">alignRules</span>(&#123;	<span class="comment">//设置组件位置规则</span></span><br><span class="line">            <span class="attr">bottom</span>:&#123;	<span class="comment">//组件的底部位于anchor的底部</span></span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;__container__&quot;</span>,	<span class="comment">//RelativeContainer默认id</span></span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">VerticalAlign</span>.<span class="property">Bottom</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">right</span>:&#123;	<span class="comment">//组件的右侧位于anchor的水平方向end位置</span></span><br><span class="line">              <span class="attr">anchor</span>: <span class="string">&quot;__container__&quot;</span>,</span><br><span class="line">              <span class="attr">align</span>: <span class="title class_">HorizontalAlign</span>.<span class="property">End</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="title class_">Button</span>()&#123;</span><br><span class="line">              <span class="title class_">Text</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">                .<span class="title function_">fontColor</span>(<span class="title class_">Color</span>.<span class="property">White</span>)</span><br><span class="line">                .<span class="title function_">fontSize</span>(<span class="number">36</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="title function_">backgroundColor</span>(<span class="title class_">Color</span>.<span class="property">Orange</span>)</span><br><span class="line">            .<span class="title function_">width</span>(<span class="number">60</span>)</span><br><span class="line">            .<span class="title function_">height</span>(<span class="number">60</span>)</span><br><span class="line">            .<span class="title function_">id</span>(<span class="string">&quot;btn2&quot;</span>)</span><br><span class="line">            .<span class="title function_">alignRules</span>(&#123;</span><br><span class="line">              <span class="attr">bottom</span>:&#123;</span><br><span class="line">                <span class="attr">anchor</span>: <span class="string">&quot;btn1&quot;</span>,</span><br><span class="line">                <span class="attr">align</span>: <span class="title class_">VerticalAlign</span>.<span class="property">Top</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">right</span>:&#123;</span><br><span class="line">                <span class="attr">anchor</span>: <span class="string">&quot;btn1&quot;</span>,</span><br><span class="line">                <span class="attr">align</span>: <span class="title class_">HorizontalAlign</span>.<span class="property">End</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_">offset</span>(&#123;<span class="attr">y</span>: -<span class="number">30</span>&#125;)</span><br><span class="line">            <span class="title class_">Button</span>()&#123;</span><br><span class="line">              <span class="title class_">Text</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">                .<span class="title function_">fontColor</span>(<span class="title class_">Color</span>.<span class="property">White</span>)</span><br><span class="line">                .<span class="title function_">fontSize</span>(<span class="number">36</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="title function_">backgroundColor</span>(<span class="title class_">Color</span>.<span class="property">Gray</span>)</span><br><span class="line">            .<span class="title function_">width</span>(<span class="number">60</span>)</span><br><span class="line">            .<span class="title function_">height</span>(<span class="number">60</span>)</span><br><span class="line">            .<span class="title function_">id</span>(<span class="string">&quot;btn3&quot;</span>)</span><br><span class="line">            .<span class="title function_">alignRules</span>(&#123;</span><br><span class="line">              <span class="attr">bottom</span>:&#123;</span><br><span class="line">                <span class="attr">anchor</span>: <span class="string">&quot;btn1&quot;</span>,</span><br><span class="line">                <span class="attr">align</span>: <span class="title class_">VerticalAlign</span>.<span class="property">Top</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">right</span>:&#123;</span><br><span class="line">                <span class="attr">anchor</span>: <span class="string">&quot;btn1&quot;</span>,</span><br><span class="line">                <span class="attr">align</span>: <span class="title class_">HorizontalAlign</span>.<span class="property">Start</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_">offset</span>(&#123;<span class="attr">x</span>: -<span class="number">10</span>, <span class="attr">y</span>: -<span class="number">10</span>&#125;)</span><br><span class="line">            <span class="title class_">Button</span>()&#123;</span><br><span class="line">              <span class="title class_">Text</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">                .<span class="title function_">fontColor</span>(<span class="title class_">Color</span>.<span class="property">White</span>)</span><br><span class="line">                .<span class="title function_">fontSize</span>(<span class="number">36</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="title function_">backgroundColor</span>(<span class="title class_">Color</span>.<span class="property">Green</span>)</span><br><span class="line">            .<span class="title function_">width</span>(<span class="number">60</span>)</span><br><span class="line">            .<span class="title function_">height</span>(<span class="number">60</span>)</span><br><span class="line">            .<span class="title function_">id</span>(<span class="string">&quot;btn4&quot;</span>)</span><br><span class="line">            .<span class="title function_">alignRules</span>(&#123;</span><br><span class="line">              <span class="attr">bottom</span>:&#123;</span><br><span class="line">                <span class="attr">anchor</span>: <span class="string">&quot;btn1&quot;</span>,</span><br><span class="line">                <span class="attr">align</span>: <span class="title class_">VerticalAlign</span>.<span class="property">Bottom</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">right</span>:&#123;</span><br><span class="line">                <span class="attr">anchor</span>: <span class="string">&quot;btn1&quot;</span>,</span><br><span class="line">                <span class="attr">align</span>: <span class="title class_">HorizontalAlign</span>.<span class="property">Start</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_">offset</span>(&#123;<span class="attr">x</span>: -<span class="number">30</span>&#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="title function_">height</span>(<span class="number">160</span>)</span><br><span class="line">        .<span class="title function_">width</span>(<span class="number">160</span>)</span><br><span class="line">        .<span class="title function_">offset</span>(&#123;<span class="attr">x</span>: -<span class="number">10</span>, <span class="attr">y</span>: -<span class="number">10</span>&#125;)	<span class="comment">//微调位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="title function_">width</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    .<span class="title function_">height</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华为</category>
      </categories>
      <tags>
        <tag>鸿蒙</tag>
        <tag>ArkTS</tag>
        <tag>华为</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2024/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表：顺序表"><a href="#线性表：顺序表" class="headerlink" title="线性表：顺序表"></a>线性表：顺序表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;插入位置异常&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(size &gt;= capacity)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> capacity + (capacity &gt;&gt; <span class="number">1</span>); <span class="comment">//扩容为原来1.5倍</span></span><br><span class="line">            Object[] newArray = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">            System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, size);<span class="comment">//旧数组数据拷贝</span></span><br><span class="line">            array = newArray;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; index; i--)&#123;</span><br><span class="line">            array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        array[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;删除位置异常&quot;</span>);</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) array[index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size; i++)&#123;</span><br><span class="line">            array[i] = array[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)   <span class="comment">//在插入之前同样要进行范围检查</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;非法的位置，合法的位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> (E) array[index];   <span class="comment">//直接返回就完事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;   <span class="comment">//获取当前存放的元素数量</span></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性表：链表"><a href="#线性表：链表" class="headerlink" title="线性表：链表"></a>线性表：链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedNode</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;非法的位置，合法的位置为：0 ~ &quot;</span>+(size)); </span><br><span class="line">        Node&lt;E&gt; pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">        node.next = pre.next;</span><br><span class="line">        pre.next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;非法的位置，合法的位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>)); </span><br><span class="line">        Node&lt;E&gt; pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> pre.next.element;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;非法的位置，合法的位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>)); </span><br><span class="line">        Node&lt;E&gt; pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next.element;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    Node&lt;E&gt; node = head.next;   <span class="comment">//从第一个结点开始，一个一个遍历，遍历一个就拼接到字符串上去</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        builder.append(node.element).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E element;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：什么情况下使用顺序表，什么情况下使用链表呢？</p>
<ul>
<li>通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。</li>
<li>而顺序表在插入元素时就显得有些鸡肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点 指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。</li>
</ul>
<h2 id="线性表：栈"><a href="#线性表：栈" class="headerlink" title="线性表：栈"></a>线性表：栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedStack</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> head.next.element;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt;&#123;</span><br><span class="line">        E element;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span>&#123;&#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性表：队列"><a href="#线性表：队列" class="headerlink" title="线性表：队列"></a>线性表：队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        Node&lt;E&gt; last = head;</span><br><span class="line">        <span class="keyword">while</span>(last.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> head.next.element;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt;&#123;</span><br><span class="line">        E element;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树：二叉树"><a href="#树：二叉树" class="headerlink" title="树：二叉树"></a>树：二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> E element;</span><br><span class="line">    <span class="keyword">public</span> TreeNode&lt;E&gt; left, right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.element);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.print(root.element);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.print(root.element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历，按照遍历顺序，遍历到谁输出谁</span></span><br><span class="line"><span class="comment">//直接使用队列实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    LinkedQueue&lt;TreeNode&lt;T&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedQueue</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode&lt;T&gt; node = queue.poll();</span><br><span class="line">        System.out.print(node.element);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>TODO</title>
    <url>/2024/07/22/TODO/</url>
    <content><![CDATA[<h2 id="1-变量的定义：变量类型有哪些？变量定义在内存的位置（作用域）？"><a href="#1-变量的定义：变量类型有哪些？变量定义在内存的位置（作用域）？" class="headerlink" title="1.变量的定义：变量类型有哪些？变量定义在内存的位置（作用域）？"></a>1.变量的定义：变量类型有哪些？变量定义在内存的位置（作用域）？</h2><p><strong>十个数据类型：</strong></p>
<p>四个整型：long, int, short, byte</p>
<p>两个浮点型：float, double</p>
<p>一个字符型：char</p>
<p>一个布尔类型：boolean</p>
<p>无返回值时：void</p>
<p>Java10新增：var，自动判断类型</p>
<h3 id="Java中变量类型："><a href="#Java中变量类型：" class="headerlink" title="Java中变量类型："></a>Java中变量类型：</h3><p>局部变量（方法、构造函数或块内部声明的变量），实例变量（在类中声明，每个实例对象都有副本），静态变量或类变量（static关键字修饰，所有该类的实例对象共享同一个变量），参数变量（方法或构造函数声明中的变量）</p>
<p>局部变量如果是基本类型，值会存在<strong>栈</strong>中，实例变量作为对象的一部分保存在<strong>堆</strong>中。常量存储在<strong>常量池</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">    <span class="keyword">static</span> String info;    <span class="comment">//这里我们定义一个info静态变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态属性是属于类的，不是依靠于实例对象存在。因此外部赋值时，应该直接Person.info进行使用。</span></span><br></pre></td></tr></table></figure>

<p>静态方法也是属于类的</p>
<p><img src="https://image.itbaima.cn/markdown/2022/09/20/cWCrJgnkXFL63y2.png" alt="image-20220920234401275"></p>
<p>其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：</p>
<ul>
<li>byte -&gt; Byte</li>
<li>boolean -&gt; Boolean</li>
<li>short -&gt; Short</li>
<li>char -&gt; Character</li>
<li>int -&gt; Integer</li>
<li>long -&gt; Long</li>
<li>float -&gt; Float</li>
<li>double -&gt; Double</li>
</ul>
<p>自动拆箱和装箱：</p>
<p>Integer i &#x3D; 10; int a &#x3D; i;</p>
<p>本质：Integer i &#x3D; Integer.valueOf(10);  和 int i &#x3D; i.intValue();</p>
<p>IntegerCache会默认缓存-128-127之间所有值，将这些值提前作为包装类存储。在这个缓存范围外，得到的就是不同对象。</p>
<p><strong>类什么时候加载？</strong></p>
<p>在Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：</p>
<ul>
<li>访问类的静态变量，或者为静态变量赋值</li>
<li>new 创建类的实例（隐式加载）</li>
<li>调用类的静态方法</li>
<li>子类初始化时</li>
<li>反射中</li>
</ul>
<p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p>
<p><strong>初始化顺序</strong></p>
<p>静态&gt;普通</p>
<p>变量&gt;代码块&gt;构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> test();  <span class="comment">//这里我们用test方法的返回值作为变量的初始值，便于观察</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是成员变量初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> init();   <span class="comment">//这里我们用init静态方法的返回值作为变量的初始值，便于观察</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态变量初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-字符串：字符串定义，字符串常用方法，"><a href="#2-字符串：字符串定义，字符串常用方法，" class="headerlink" title="2.字符串：字符串定义，字符串常用方法，"></a>2.字符串：字符串定义，字符串常用方法，</h2><p>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Runoob&quot;</span>;              <span class="comment">// String 直接创建 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Runoob&quot;</span>;              <span class="comment">// String 直接创建 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1;                    <span class="comment">// 相同引用 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Runoob&quot;</span>);   <span class="comment">// String 对象创建 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Runoob&quot;</span>);   <span class="comment">// String 对象创建</span></span><br></pre></td></tr></table></figure>

<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-string-1-2020-12-01.png" alt="img"></p>
<p>String类不可变，创建之后就为固定的，需要字符串修改的话，选择StringBuffer或StringBuilder。</p>
<p>字符串获取长度：string.length();</p>
<p>字符串连接：string1.concat(string2)或者string1 + string2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回指定索引处的char值</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="comment">//比较字符串字典顺序，如果调用方法的字符串排在前面结果大于0，后面结果小于0，相等结果等于0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span></span><br><span class="line"><span class="comment">//字符串是否以指定的前缀或后缀开始结束</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String prefix)</span></span><br><span class="line"><span class="comment">//根据给定的正则表达式切割</span></span><br><span class="line">String[] split(String regex, <span class="type">int</span> limit)</span><br><span class="line"><span class="comment">//给定的replacement替换所有的</span></span><br><span class="line">String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span></span><br><span class="line">String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar, <span class="type">char</span> new Char)</span></span><br><span class="line"><span class="comment">//返回指定字符串第一次出现的索引位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//将字符串放入字符串池中，并返回池中的引用</span></span><br><span class="line">String <span class="title function_">intern</span><span class="params">()</span></span><br></pre></td></tr></table></figure>



<h2 id="3-条件语句，循环语句，分支结构"><a href="#3-条件语句，循环语句，分支结构" class="headerlink" title="3.条件语句，循环语句，分支结构"></a>3.条件语句，循环语句，分支结构</h2><h2 id="4-运算符（算术运算符，逻辑运算符，Java内置方法）"><a href="#4-运算符（算术运算符，逻辑运算符，Java内置方法）" class="headerlink" title="4.运算符（算术运算符，逻辑运算符，Java内置方法）"></a>4.运算符（算术运算符，逻辑运算符，Java内置方法）</h2><h2 id="5-面向对象（封装，继承，多态：同一个接口实现不同方法，方法重写：变量方法作用域不同，重载）、如何实现多态？"><a href="#5-面向对象（封装，继承，多态：同一个接口实现不同方法，方法重写：变量方法作用域不同，重载）、如何实现多态？" class="headerlink" title="5.面向对象（封装，继承，多态：同一个接口实现不同方法，方法重写：变量方法作用域不同，重载）、如何实现多态？"></a>5.面向对象（封装，继承，多态：同一个接口实现不同方法，方法重写：变量方法作用域不同，重载）、如何实现多态？</h2><p>封装、继承和多态是面向对象编程的三大特性。</p>
<blockquote>
<p>封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。</p>
<p>继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。</p>
<p>多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。</p>
</blockquote>
<p>一个类继承另一个类时，属性也会被继承，子类可以直接访问父类的属性。除非父类属性为<code>private</code>，子类将无法访问，但是子类依旧继承了这个属性。</p>
<p>在使用子类时，可以直接当成父类使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);    <span class="comment">//这里使用父类类型的变量，去引用一个子类对象（向上转型）</span></span><br><span class="line">    person.hello();    <span class="comment">//父类对象的引用相当于当做父类来使用，只能访问父类对象的内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  <span class="comment">// 向上转型  </span></span><br><span class="line">a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;        <span class="comment">// 向下转型  </span></span><br></pre></td></tr></table></figure>

<p>如果变量所引用的对象是对应类型或是对应类型的子类，那么<code>instanceof</code>都会返回<code>true</code>，否则返回<code>false</code>。</p>
<p>方法重载指的是，可以有多个重名方法，但是方法的参数必须不同，<strong>参数相同但是仅仅只是返回值不同</strong>是不支持重载的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="comment">//不支持重载</span></span><br></pre></td></tr></table></figure>

<p>方法重载是为了给方法提供更多种类，而方法重写则是覆盖原有的方法实现。</p>
<p>Java重写方法需要满足以下一些要求：</p>
<ol>
<li><strong>方法签名必须相同</strong>：<ul>
<li>方法的名称、参数列表（包括参数类型和参数顺序）必须和父类&#x2F;接口中的方法完全一致。</li>
</ul>
</li>
<li><strong>返回类型可以是子类型</strong>：<ul>
<li>重写方法的返回类型可以是被重写方法返回类型的子类型（这叫做协变返回类型）。</li>
</ul>
</li>
<li><strong>访问修饰符不能更严格</strong>：<ul>
<li>重写方法不能有比被重写方法更严格的访问权限。例如，如果父类方法是 <code>public</code>，子类不能把它改成 <code>protected</code>或者<code>private</code>。</li>
</ul>
</li>
<li><strong>抛出的异常不能更广泛</strong>：<ul>
<li>重写方法抛出的检查异常范围不能超出被重写方法。例如，如果父类方法抛出一个 <code>IOException</code>，子类重写的方法只能抛出 <code>IOException</code> 或其子类异常，不能抛出更广泛的异常。</li>
</ul>
</li>
<li><strong>只能在子类中出现</strong>：<ul>
<li>重写是子类对父类方法的重新定义，因此只能在子类中重写父类的方法，不能在同一个类内部重写自己的方法。</li>
</ul>
</li>
<li><strong>需用 <code>@Override</code> 注解（推荐）</strong>：<ul>
<li>虽然不是必须的，但使用 <code>@Override</code> 注解可以帮助编译器和程序员理解这个方法是对父类方法的重写，如果有不一致的地方，编译器会报错。</li>
</ul>
</li>
</ol>
<p>下面是一个简单的例子来演示这些要求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java 复制代码<span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent display()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Number <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child display()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getValue</span><span class="params">()</span> &#123;  <span class="comment">// Integer 是 Number 的子类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;  <span class="comment">// FileNotFoundException 是 IOException 的子类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//构建抽象接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">(<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        println(PI * r * r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//接口实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">zhengfangxing</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        println(a*a);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">()</span>&#123;</span><br><span class="line">         println(<span class="string">&quot;正方形&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//接口实现</span></span><br><span class="line"></span><br><span class="line"><span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shape</span>();</span><br><span class="line"><span class="type">Circle</span> <span class="variable">cir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line"><span class="type">zhengfangxing</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zhengfangxing</span>();</span><br><span class="line"><span class="comment">//方法重写之后，实现多态。同一个接口实现不同的效果</span></span><br><span class="line">shape.area(cir);</span><br><span class="line">shape.area(zhengfangxing);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法。JDK8之后，接口中的方法可以存在默认实现，存在默认实现的方法，不强制要求实现类去实现。</p>
<h2 id="6-Java文件操作（标准IO，文件IO）区别。"><a href="#6-Java文件操作（标准IO，文件IO）区别。" class="headerlink" title="6.Java文件操作（标准IO，文件IO）区别。"></a>6.Java文件操作（标准IO，文件IO）区别。</h2><h2 id="7-Java进程线程（定义，功能，区别）"><a href="#7-Java进程线程（定义，功能，区别）" class="headerlink" title="7.Java进程线程（定义，功能，区别）"></a>7.Java进程线程（定义，功能，区别）</h2><h2 id="8-Java数据结构（Array-List-Set-Map，Queue，Stack，二叉树，B-树各自有哪几种，各自的特点区别。）如何定义，如何使用，使用场景。"><a href="#8-Java数据结构（Array-List-Set-Map，Queue，Stack，二叉树，B-树各自有哪几种，各自的特点区别。）如何定义，如何使用，使用场景。" class="headerlink" title="8.Java数据结构（Array,List,Set,Map，Queue，Stack，二叉树，B+树各自有哪几种，各自的特点区别。）如何定义，如何使用，使用场景。"></a>8.Java数据结构（Array,List,Set,Map，Queue，Stack，二叉树，B+树各自有哪几种，各自的特点区别。）如何定义，如何使用，使用场景。</h2><h2 id="线性结构，非线性结构"><a href="#线性结构，非线性结构" class="headerlink" title="线性结构，非线性结构"></a>线性结构，非线性结构</h2><p>Map键的排序方式，按照哪种进行排序的。</p>
<h2 id="9-网络编程（如何搭建一个简单CS模型，如何实现一个广播服务器，如何实现服务器连接多个客户端：并发实现，Netty。）并发实现：多进程，多线程（加解锁）。"><a href="#9-网络编程（如何搭建一个简单CS模型，如何实现一个广播服务器，如何实现服务器连接多个客户端：并发实现，Netty。）并发实现：多进程，多线程（加解锁）。" class="headerlink" title="9.网络编程（如何搭建一个简单CS模型，如何实现一个广播服务器，如何实现服务器连接多个客户端：并发实现，Netty。）并发实现：多进程，多线程（加解锁）。"></a>9.网络编程（如何搭建一个简单CS模型，如何实现一个广播服务器，如何实现服务器连接多个客户端：并发实现，Netty。）并发实现：多进程，多线程（加解锁）。</h2><h2 id="10-计算机网络（网络协议：Http和Https协议）（TCP和UDP）做什么的，有什么区别。三次握手，四次挥手。"><a href="#10-计算机网络（网络协议：Http和Https协议）（TCP和UDP）做什么的，有什么区别。三次握手，四次挥手。" class="headerlink" title="10.计算机网络（网络协议：Http和Https协议）（TCP和UDP）做什么的，有什么区别。三次握手，四次挥手。"></a>10.计算机网络（网络协议：Http和Https协议）（TCP和UDP）做什么的，有什么区别。三次握手，四次挥手。</h2><h2 id="11-Linux操作系统（了解基础命令，和Windos区别，Java在Linux上的部署）"><a href="#11-Linux操作系统（了解基础命令，和Windos区别，Java在Linux上的部署）" class="headerlink" title="11.Linux操作系统（了解基础命令，和Windos区别，Java在Linux上的部署）"></a>11.Linux操作系统（了解基础命令，和Windos区别，Java在Linux上的部署）</h2><h2 id="12-数据库MySQL，Redis（如何使用，SQL语句，存储过程：为什么要写？定义。多表查询，百万级数据如何提高查询效率。）"><a href="#12-数据库MySQL，Redis（如何使用，SQL语句，存储过程：为什么要写？定义。多表查询，百万级数据如何提高查询效率。）" class="headerlink" title="12.数据库MySQL，Redis（如何使用，SQL语句，存储过程：为什么要写？定义。多表查询，百万级数据如何提高查询效率。）"></a>12.数据库MySQL，Redis（如何使用，SQL语句，存储过程：为什么要写？定义。多表查询，百万级数据如何提高查询效率。）</h2><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;   <span class="comment">//标记为native的方法是本地方法，底层是由C++实现的</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();   <span class="comment">//这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒所有等待当前对象锁的线程，同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使得持有当前对象锁的线程进入等待状态，同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Clone克隆"><a href="#Clone克隆" class="headerlink" title="Clone克隆"></a>Clone克隆</h2><p>Java提供的克隆方法为浅拷贝。</p>
<p>克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。</p>
<ul>
<li><strong>浅拷贝：</strong> 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。</li>
<li><strong>深拷贝：</strong> 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</li>
</ul>
<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>并行流<code>.parallelStream()</code>与顺序流<code>.stream()</code>不同的是，并行流允许流操作在多个线程上并行执行，以提升处理大量数据时的性能。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>()-&gt;{}形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式和 Stream API 进行并行计算</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">										<span class="comment">//方法引用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.parallelStream().mapToInt(Integer::intValue).sum();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓开发</title>
    <url>/2024/06/22/2024-06-22-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="AndroidStudio新建项目"><a href="#AndroidStudio新建项目" class="headerlink" title="AndroidStudio新建项目"></a>AndroidStudio新建项目</h1><h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><h3 id="1-gradle和-idea"><a href="#1-gradle和-idea" class="headerlink" title="1. .gradle和.idea"></a>1. .gradle和.idea</h3><p>自动生成的文件</p>
<h3 id="2-app"><a href="#2-app" class="headerlink" title="2. app"></a>2. app</h3><p>项目中运行的代码资源都放在此文件夹下类似于src。</p>
<h3 id="3-build"><a href="#3-build" class="headerlink" title="3. build"></a>3. build</h3><p>包含编译时自动生成的文件</p>
<h3 id="4-gradle"><a href="#4-gradle" class="headerlink" title="4. gradle"></a>4. gradle</h3><p>包含了gradle wrapper配置文件</p>
<h3 id="5-gitignore"><a href="#5-gitignore" class="headerlink" title="5. .gitignore"></a>5. .gitignore</h3><p>版本控制</p>
<h3 id="6-build-gradle"><a href="#6-build-gradle" class="headerlink" title="6. build.gradle"></a>6. build.gradle</h3><p>项目全局的gradle构建脚本</p>
<h3 id="7-gradle-properties"><a href="#7-gradle-properties" class="headerlink" title="7.  gradle.properties"></a>7.  gradle.properties</h3><p>全局配置文件</p>
<h3 id="8-gradlew和gradle-bat"><a href="#8-gradlew和gradle-bat" class="headerlink" title="8. gradlew和gradle.bat"></a>8. gradlew和gradle.bat</h3><p>用于在命令行界面执行gradle命令，gradlew在Linux或mac，后者运行于Windows</p>
<h3 id="9-helloworld-iml"><a href="#9-helloworld-iml" class="headerlink" title="9. helloworld.iml"></a>9. helloworld.iml</h3><p>所有IDEA项目都会生成用于标识项目</p>
<h3 id="10-local-properties"><a href="#10-local-properties" class="headerlink" title="10. local.properties"></a>10. local.properties</h3><p>指定本机sdk路径</p>
<h3 id="11-settings-gradle"><a href="#11-settings-gradle" class="headerlink" title="11. settings.gradle"></a>11. settings.gradle</h3><p>用于指定项目中所有引用的模块</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240622144047475.png" alt="image-20240622144047475"></p>
<h2 id="app目录"><a href="#app目录" class="headerlink" title="app目录"></a>app目录</h2><h3 id="androidTest和test都是用来测试的"><a href="#androidTest和test都是用来测试的" class="headerlink" title="androidTest和test都是用来测试的"></a>androidTest和test都是用来测试的</h3><h3 id="主要代码都在main里面，Java包中编写，res下放资源相关。图片一般放在res的mipmap的xxhdpi。"><a href="#主要代码都在main里面，Java包中编写，res下放资源相关。图片一般放在res的mipmap的xxhdpi。" class="headerlink" title="主要代码都在main里面，Java包中编写，res下放资源相关。图片一般放在res的mipmap的xxhdpi。"></a>主要代码都在main里面，Java包中编写，res下放资源相关。图片一般放在res的mipmap的xxhdpi。</h3><h2 id="查看res目录下资源意义"><a href="#查看res目录下资源意义" class="headerlink" title="查看res目录下资源意义"></a>查看res目录下资源意义</h2><h3 id="res-values-strings-xml"><a href="#res-values-strings-xml" class="headerlink" title="res&#x2F;values&#x2F;strings.xml"></a>res&#x2F;values&#x2F;strings.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;app_name&quot;</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在代码中，通过R.string.app_name可以获取该字符串引用</li>
<li>在xml中，通过@string&#x2F;app_name获取该字符串引用</li>
</ul>
<p>其中string部分可以替换，如果引用图片资源替换成drawable，应用图标换为mipmap，布局文件替换为layout。</p>
<h2 id="build-gradle文件"><a href="#build-gradle文件" class="headerlink" title="build.gradle文件"></a>build.gradle文件</h2><p>外层用于全局配置。</p>
<p>app中的build.gradle中，</p>
<ul>
<li>plugin用于选择程序模块，Android.library和Android.application，一般选择后者，后者可以直接运行。</li>
<li>如果需要使用kotlin需要导入kotlin-android和kotlin-android-extensions插件</li>
<li>android闭包中千刀的defaultConfig闭包可以对项目细节进行配置：applicationId是每个应用唯一标识（包名），minSdkVersion：指定项目最低兼容安卓版本。targetSdkVersion：指定在这个目标版本上作了充分测试，可以使用这个版本的所有特性。versionCode：指定版本号。versionName：版本名</li>
<li>buildTypes闭包：release：指定生成的正式版安装文件的配置。minifyEnabled：true表示混淆</li>
<li>dependencies：指定依赖关系</li>
</ul>
<h2 id="日志工具掌握"><a href="#日志工具掌握" class="headerlink" title="日志工具掌握"></a>日志工具掌握</h2><h3 id="Log工具类"><a href="#Log工具类" class="headerlink" title="Log工具类"></a>Log工具类</h3><p>log.v():打印最为琐碎的意义最小的日志信息，对应<code>verbose</code>级别</p>
<p>log.d():打印一些调试信息，对应<code>debug</code></p>
<p>log.i():打印一些比较重要的信息，可以帮助分析用户行为，<code>info</code></p>
<p>log.w():打印警告信息，<code>warn</code></p>
<p>log.e():打印错误信息,<code>error</code></p>
<p><strong>级别依次递增</strong></p>
<p>使用Logcat进行日志调试查看，过滤日志。</p>
<h3 id="为什么不用System-out-println"><a href="#为什么不用System-out-println" class="headerlink" title="为什么不用System.out.println?"></a>为什么不用System.out.println?</h3><p>这个方法除了使用方便，一无是处。比如：日志开关不可控，不能添加日志标签，日志没有级别区分等。</p>
<h1 id="kotlin开发"><a href="#kotlin开发" class="headerlink" title="kotlin开发"></a>kotlin开发</h1><p>kotlin变量声明只有var和val，var表示非final，val为final，可以自动识别准确类型。</p>
<p>kotlin中没有基本类型，他将Java中的基本类型首字母大写，成为对象。</p>
<p><strong>永远优先使用val，当val无法满足时，使用var，来保证程序的健壮性和代码规范</strong></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>fun关键字来声明,后面跟函数名，括号中填写需要的参数以及类型（可以不填），如果不需要返回值类型就不写。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin语法糖1：当函数中只有一行代码时，允许不必编写函数体，直接将唯一一行代码写在尾部，中间用等号链接。比如上面的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = max(num1, num2)</span><br><span class="line"><span class="comment">//由于kotlin的类型推导机制，可以省略注明返回的Int</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = max(num1, num2)</span><br></pre></td></tr></table></figure>

<h3 id="程序逻辑控制"><a href="#程序逻辑控制" class="headerlink" title="程序逻辑控制"></a>程序逻辑控制</h3><h4 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h4><p>if和when</p>
<h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">        value = num1</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        value = num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和Java中的不同之处：</p>
<p>if可以有返回值,返回值为每个if语句块中最后一行的返回值</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> value = <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">        num1</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value冗余，精简</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">        num1</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据语法糖，继续精简</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">        num1</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largeNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span>(num1 &gt; num2) num1 <span class="keyword">else</span> num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="when条件语句"><a href="#when条件语句" class="headerlink" title="when条件语句"></a>when条件语句</h4><p>类似于Java的switch</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">if</span> (name == <span class="string">&quot;Tom&quot;</span>)&#123;</span><br><span class="line">    <span class="number">86</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">&quot;Jim&quot;</span>)&#123;</span><br><span class="line">    <span class="number">77</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">&quot;Jack&quot;</span>)&#123;</span><br><span class="line">    <span class="number">99</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过when可以再精简</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span>(name)&#123;</span><br><span class="line">    <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">99</span></span><br><span class="line">    <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">76</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了精确匹配，when还允许类型匹配</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(num: <span class="type">Number</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">when</span>(num)&#123;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;is Int&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; println(<span class="string">&quot;is Double&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;not support&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的代码，is关键字相当于Java的instanceof关键字。Number是kotlin的抽象类，Int，Long，Double，Float等与数字相关的都是他的子类，这里就使用类型判断是否为需要的参数。</p>
<p>when的不带参数用法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span>&#123;</span><br><span class="line">    name == <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    name == <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">99</span></span><br><span class="line">    name == <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">76</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">kotlin中判断对象是否相等可以直接使用“==”来判断。</span><br><span class="line">用法</span><br><span class="line">所有名字开头为Jhon的都为<span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span>&#123;</span><br><span class="line">    name.startsWith(<span class="string">&quot;Jhon&quot;</span>) -&gt; <span class="number">100</span></span><br><span class="line">    name == <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    name == <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">99</span></span><br><span class="line">    name == <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">76</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="while和for"><a href="#while和for" class="headerlink" title="while和for"></a>while和for</h5><p>while和Java无二</p>
<h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><p>for-i直接被省略了。for-each增强为for-in</p>
<p>val range &#x3D; 0..10,表示[0,10]:   <code>..</code>是创建两端闭区间的关键字</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但很多情况下，双端闭区间却不如单端闭区间好用。下标都是从0开始的，长度为10的数组，下标范围为0到9，因此左闭右开在设计中更加常用。kotlin使用<code>until</code>关键字创建一个左闭右开区间：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">0</span> until <span class="number">10</span></span><br><span class="line"><span class="comment">//[0, 10)</span></span><br></pre></td></tr></table></figure>

<p>默认情况下for-in循环中，每次执行循环都会在区间范围内递增1(i++效果)，如果想跳过其中一些元素，可以使用step关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span> step <span class="number">2</span>)&#123;<span class="comment">//i+2</span></span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>..</code>和<code>until</code>都是创建的升序区间，想要创建降序区间需要<code>downTo</code>关键字。用法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span>)&#123;<span class="comment">//[10, 1]</span></span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>Class创建一个类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(name + <span class="string">&quot;is eating. He is &quot;</span>+ age + <span class="string">&quot;years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实例对象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> per = Person()</span><br><span class="line">per.name = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">per.age = <span class="number">19</span></span><br><span class="line">per.eat()</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240622163430552.png" alt="image-20240622163430552"></p>
<h3 id="继承和构造函数"><a href="#继承和构造函数" class="headerlink" title="继承和构造函数"></a>继承和构造函数</h3><p>新建一个类Student：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sno = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;<span class="comment">//显然现在和Person类没有关系</span></span><br></pre></td></tr></table></figure>

<p>需要Person类被继承，需要</p>
<p>1.是Person类可以被继承：kotlin遵守了“如果一个类不是专门为继承而设计的，那么就应该主动加上final声明，禁止它可以被继承”，所有它默认都不能被继承。</p>
<p>开启方法：加上open关键字</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(name + <span class="string">&quot;is eating. He is &quot;</span>+ age + <span class="string">&quot;years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.让Student类继承Person类，在kotlin中继承关键字变成了冒号：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="type">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> sno = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要加括号？</p>
<p>涉及到了主构造函数和次构造函数。</p>
<p>kotlin将构造函数分为<code>主构造函数</code>和<code>次构造函数</code>：</p>
<p><strong>主构造函数</strong>将是最常用的构造函数，每个类默认都会有一个不带参数的主构造函数，当然也可以显式的指名参数。主构造函数的特点是没有函数体，直接定义在类后面即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;            <span class="comment">//主构造函数</span></span><br></pre></td></tr></table></figure>

<p>这里表明，在对Student类实例化的时候，必须传入所有参数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s = Student(<span class="string">&quot;a123&quot;</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>主函数中没有函数体，如何在主构造函数中编写逻辑？</p>
<p>kotlin提供了init结构体，所有主函数逻辑在这里编写</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>): Person() &#123;</span><br><span class="line">	<span class="keyword">init</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;sno is&quot;</span> + sno)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>Java继承特性：子类的构造函数必须调用父类的构造函数，kotlin也遵守了，那么回头看，Student类中声明了一个主构造函数，是否需要放入init结构体中执行Person的构造方法？可以放入，但是不是个好方法，大部分情况下我们不需要编写init结构体。	因此通过()来指定。</p>
<p>将父类的属性放入主构造函数，如何继承？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>): Person(name, age) &#123;</span><br><span class="line">									<span class="comment">//不再用val修饰父类构造函数的变量，因为在子类构造函数中声明val或var的参数将自动成为该类的字段，回到是和父类中同名的字段冲突。</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>当一个类中既有主构造函数又有次构造函数，所有的次构造函数都需要调用主构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>): Person(name, age) &#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>): <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age)&#123;</span><br><span class="line">        <span class="comment">//通过this关键字调用了主构造函数，并且对sno和grade赋初值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(): <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//通过this关键字调用了第一个次构造函数，并且将name，age赋初值，间接调用主构造函数也合法。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以通过这几种进行实例化了</span></span><br><span class="line"><span class="keyword">val</span> student = Student()</span><br><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;Jack&quot;</span>, <span class="number">19</span>)</span><br><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;a123&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Jack&quot;</span>, <span class="number">19</span>)</span><br></pre></td></tr></table></figure>

<p>特殊情况：只有次构造函数，没有子构造函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="type">Person</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age)&#123;</span><br><span class="line">        <span class="comment">//由于Student没有主构造函数，继承类的时候就不需要()了，但是由于没有主构造函数，次构造函数只能直接通过super调用父类的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>新建一个Study接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomeWork</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让Student类实现Study接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(name: String, age: <span class="built_in">Int</span>) : Person(name, age), Study&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(name + <span class="string">&quot;is reading.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doHomeWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(name + <span class="string">&quot;is doing homework.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Study接口中定义的两个待实现函数，Student类必须实现。</p>
<p>当接口的函数有了函数体，就不需要强制实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">//默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomeWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;do homework&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数可见性修饰符"><a href="#函数可见性修饰符" class="headerlink" title="函数可见性修饰符"></a>函数可见性修饰符</h3><p>kotlin中：</p>
<p>public：所有类可见，默认</p>
<p>private：当前类可见</p>
<p>protected：当前类、子类可见</p>
<p>default：无</p>
<p>internal：同一模块中的类可见</p>
<h3 id="数据类和单例类"><a href="#数据类和单例类" class="headerlink" title="数据类和单例类"></a>数据类和单例类</h3><p>数据类通常需要重写equals，hashcode，toString方法。在kotlin中，在类前面加data，表示这个类是一个数据类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cellphone</span>(<span class="keyword">val</span> brand: String, <span class="keyword">val</span> price: <span class="built_in">Double</span>)</span><br><span class="line">会根据参数生成这些方法。</span><br></pre></td></tr></table></figure>

<p>main函数中测试</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> cellphone = Cellphone(<span class="string">&quot;iphone&quot;</span>, <span class="number">9988.0</span>)</span><br><span class="line">    <span class="keyword">val</span> cellphone1 = Cellphone(<span class="string">&quot;iphone&quot;</span>, <span class="number">9988.0</span>)</span><br><span class="line">    println(cellphone)</span><br><span class="line">    println(cellphone == cellphone1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240622172731158.png" alt="image-20240622172731158"></p>
<p>实现单例类</p>
<p>创建类型选择Object</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">singletonTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;hello singleton&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接通过函数名调用，kotlin自动帮我们创建了一个实例，并且保证全局只有一个。</p>
<h3 id="Lambda编程"><a href="#Lambda编程" class="headerlink" title="Lambda编程"></a>Lambda编程</h3><p>创建集合</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = ArrayList&lt;String&gt;()</span><br><span class="line">list.add(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;pear&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line"><span class="comment">//通过listof函数代替简化</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>)</span><br><span class="line"><span class="comment">//通过listOf创建的集合式只读集合，不能进行增删，通过mutableListOf（）创建</span></span><br><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;water&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Set的创建方法和集合一样，setOf和mutableSetOf。</p>
<p>创建map</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持和Java一样通过put和get进行读取和添加数据操作</span></span><br><span class="line"><span class="keyword">val</span> map = HashMap&lt;String, <span class="built_in">Int</span>&gt;</span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//但是不建议这样，更加推荐类似于数组下标的语法结构</span></span><br><span class="line">map[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">读取：</span><br><span class="line"><span class="keyword">val</span> number = map[<span class="string">&quot;apple&quot;</span>]</span><br><span class="line"><span class="comment">//提供了mapOf和mutableMapOf函数来简化</span></span><br><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;apple&quot;</span> to <span class="number">1</span>, <span class="string">&quot;pear&quot;</span> to <span class="number">2</span>)</span><br><span class="line"><span class="comment">//这里的to是一个infix函数</span></span><br><span class="line">遍历</span><br><span class="line"><span class="keyword">for</span>((fruit, number) <span class="keyword">in</span> map)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数式API"><a href="#函数式API" class="headerlink" title="函数式API"></a>函数式API</h3><p><strong>Lambda表达式语法结构</strong></p>
<p>{参数名1：参数类型，参数名2：参数类型 -&gt; 函数体}</p>
<p>如果有参数传到Lambda表达式中的话，还需要声明参数列表，参数列表的结尾使用一个-&gt;符号，表示参数列表的结束和函数体的开始，函数体中并编写任意行代码，自动将最后一行代码作为返回值。</p>
<p>例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;mango&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> lambda = &#123;furit: String -&gt; furit.length&#125;</span><br><span class="line"><span class="keyword">val</span> maxFuritLength = list.maxBy(lambda)</span><br><span class="line"><span class="comment">//直接将Lambda写入maxBy函数</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;mango&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxFuritLength = list.maxBy(&#123;furit: String -&gt; furit.length&#125;)</span><br><span class="line"><span class="comment">//lambda函数是函数的最后一个参数，可以放到括号外面</span></span><br><span class="line"><span class="keyword">val</span> maxFuritLength = list.maxBy()&#123;furit: String -&gt; furit.length&#125;</span><br><span class="line"><span class="comment">//没有别的参数了，可以去掉括号</span></span><br><span class="line"><span class="keyword">val</span> maxFuritLength = list.maxBy&#123;furit: String -&gt; furit.length&#125;</span><br><span class="line"><span class="comment">//参数类型省略</span></span><br><span class="line"><span class="keyword">val</span> maxFuritLength = list.maxBy&#123;furit -&gt; furit.length&#125;</span><br><span class="line"><span class="comment">//只有一个参数时，省略参数名，使用it关键字表示</span></span><br><span class="line"><span class="keyword">val</span> maxFuritLength = list.maxBy&#123;it.length&#125;</span><br></pre></td></tr></table></figure>

<p>常用函数api</p>
<p>map()，将集合中每个元素映射成另外的值，例如将集合写成全部变为大写：list.map{ it.toUpperCase() }</p>
<p>filter()，过滤，过滤长度大于五的（保留长度五个字母以内的）：list.filter(it.length &lt;&#x3D; 5)</p>
<p>anyResult()和allResult()，any表示存在任意满足条件的，all表示全都符合条件。返回值为true或false</p>
<p>kotlin调用Java的接口：Java函数式API。单抽象方法接口，即可使用函数式API方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">onClickListener</span>()&#123;</span><br><span class="line">    void onClick(View v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin这样调用</span></span><br><span class="line">button.setOnClickListener&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空指针检查"><a href="#空指针检查" class="headerlink" title="空指针检查"></a>空指针检查</h3><p>程序中会出现空指针异常，需要编写判空逻辑来防止，kotlin中默认所有的参数和变量都不为空。</p>
<p>如果想要空的参数，需要在类型后面加个?</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study : <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study.dohomework()</span><br><span class="line">&#125;</span><br><span class="line">而加入空类型后，内部会报错，因为需要进行判空处理</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study : <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)</span><br><span class="line">    	study.dohomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>?.</code>和<code>?:</code></p>
<p>?.，当对象为空时什么都不做，不为空时正常执行方法。</p>
<p>?:，左边不为空就返回左边的值，否则返回右边的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextLength</span><span class="params">(text: <span class="type">String</span>?)</span></span> = text?.length ?: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>let函数，当前对象调用let函数，本身会传到函数中作为参数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study : <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study?.let&#123;</span><br><span class="line">        stu -&gt; </span><br><span class="line">        stu.read()</span><br><span class="line">        stu.write()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//?.判断study是否为空，不为空则执行let函数，将study传入let函数，调用本来的方法。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字符串内嵌表达式"><a href="#字符串内嵌表达式" class="headerlink" title="字符串内嵌表达式"></a>字符串内嵌表达式</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;hello <span class="subst">$&#123;obj.name&#125;</span>, nece to meet you!&quot;</span></span><br><span class="line">当表达式只有这一个变量时，可以省略大括号&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数的参数默认值"><a href="#函数的参数默认值" class="headerlink" title="函数的参数默认值"></a>函数的参数默认值</h3><p>在定义函数的时候，给任意参数赋初值，在调用函数时，对于有默认值的参数，可以选择不赋值使用默认值。</p>
<p>还支持和键值对一样的传值方式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">study(name = <span class="string">&quot;hello&quot;</span>, age = <span class="string">&quot;18&quot;</span>)<span class="comment">//顺序可以不一样。</span></span><br></pre></td></tr></table></figure>

<h2 id="创建加载布局"><a href="#创建加载布局" class="headerlink" title="创建加载布局"></a>创建加载布局</h2><h3 id="配置layout文件，新建一个first-layout-xml"><a href="#配置layout文件，新建一个first-layout-xml" class="headerlink" title="配置layout文件，新建一个first_layout.xml"></a>配置layout文件，新建一个first_layout.xml</h3><p>在<LinearLayout>标签中加入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;button1&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在FirstActivity中的onCreate方法加入setContentView(R.layout.first_layout)。</p>
<h3 id="在AndroidMainFest-xml注册"><a href="#在AndroidMainFest-xml注册" class="headerlink" title="在AndroidMainFest.xml注册"></a>在AndroidMainFest.xml注册</h3><p>所有的Activity都要在这里面注册才能生效。</p>
<p>注册声明都要放在<application>标签中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.ActivityTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">&quot;This is FirstAndroid&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用Toast"><a href="#使用Toast" class="headerlink" title="使用Toast"></a>使用Toast</h3><p>加入</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.first_layout)</span><br><span class="line">        <span class="keyword">val</span> button1: Button = findViewById(R.id.button1)</span><br><span class="line">        button1.setOnClickListener&#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;你点击了按钮&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            <span class="comment">//makeText参数，第一个参数为context，Activity本身就是一个context，直接调用this</span></span><br><span class="line">            <span class="comment">//第二个参数为显示的文本内容</span></span><br><span class="line">            <span class="comment">//第三个参数为显示时间。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版AndroidStudio，将kotlin-Android-extensions改用为ViewBinding</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = FirstLayoutBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.button1.setOnClickListener&#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;点击了按钮&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不再调用findViewById。</p>
<h3 id="在Activity中使用Menu"><a href="#在Activity中使用Menu" class="headerlink" title="在Activity中使用Menu"></a>在Activity中使用Menu</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = FirstLayoutBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.button1.setOnClickListener&#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;点击了按钮&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateOptionsMenu</span><span class="params">(menu: <span class="type">Menu</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        menuInflater.inflate(R.menu.main, menu)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (item.itemId)&#123;</span><br><span class="line">            R.id.add_item -&gt; Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;点击了增加&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            R.id.remove_item -&gt; Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;点击了减少&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>res目录下新建menu，并新建Menu Resource File，名为main</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/add_item&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;Add&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/remove_item&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;Remove&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="销毁Activity"><a href="#销毁Activity" class="headerlink" title="销毁Activity"></a>销毁Activity</h3><p>在需要执行的事件中，加入finish()</p>
<h2 id="使用Intent在Activity中穿梭"><a href="#使用Intent在Activity中穿梭" class="headerlink" title="使用Intent在Activity中穿梭"></a>使用Intent在Activity中穿梭</h2><h3 id="使用显式Intent"><a href="#使用显式Intent" class="headerlink" title="使用显式Intent"></a>使用显式Intent</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">加入onClickListener中</span><br></pre></td></tr></table></figure>

<h3 id="隐式使用Intent"><a href="#隐式使用Intent" class="headerlink" title="隐式使用Intent"></a>隐式使用Intent</h3><p>在AndroidManifest.xml的其他Activity中，加入<intent-filter>在其中加入action和category，表示可以响应的Intent类别是什么。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.activitytest.ACTION_START&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.activitytest.MY_CATEGORY&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其他使用方式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_VIEW)</span><br><span class="line">intent.<span class="keyword">data</span> = Uri.parse(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>

<p>启动浏览器，将parse中的字符串解析成uri对象，传入data</p>
<h3 id="向下一个Activity传递数据"><a href="#向下一个Activity传递数据" class="headerlink" title="向下一个Activity传递数据"></a>向下一个Activity传递数据</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//            val data = &quot;Hello 第二个按钮！&quot;</span></span><br><span class="line"><span class="comment">//            val intent = Intent(this, SecondActivity::class.java)</span></span><br><span class="line"><span class="comment">//            intent.putExtra(&quot;extra_data&quot;, data)</span></span><br><span class="line"><span class="comment">//            startActivity(intent)</span></span><br></pre></td></tr></table></figure>

<h3 id="返回数据给上一个Activity"><a href="#返回数据给上一个Activity" class="headerlink" title="返回数据给上一个Activity"></a>返回数据给上一个Activity</h3><p>第一个Activity的buttonclick事件中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">startActivity.launch(intent)</span><br></pre></td></tr></table></figure>

<p>还需要实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> startActivity =</span><br><span class="line">    registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123;</span><br><span class="line">        <span class="comment">//此处是跳转的result回调方法</span></span><br><span class="line">        <span class="keyword">if</span> (it.<span class="keyword">data</span> != <span class="literal">null</span> &amp;&amp; it.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = it.<span class="keyword">data</span>?.getStringExtra(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">            Log.d(<span class="string">&quot;第一按钮&quot;</span>, <span class="string">&quot;返回的数据为<span class="variable">$data</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二个activity中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent()</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;你好第一个按钮&quot;</span>)</span><br><span class="line">setResult(RESULT_OK, intent)</span><br><span class="line">finish()</span><br></pre></td></tr></table></figure>

<h2 id="Acitvity生命周期"><a href="#Acitvity生命周期" class="headerlink" title="Acitvity生命周期"></a>Acitvity生命周期</h2><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>Activity是按照栈的顺序来放的，当前用户所看到的Activity是正在运行，处于栈顶的Activity。点击返回按钮或者Activity调用finish方法，会将这个Activity弹出栈。</p>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>校园论坛项目</title>
    <url>/2024/06/20/2024-06-20-%E6%A0%A1%E5%9B%AD%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="校园论坛项目"><a href="#校园论坛项目" class="headerlink" title="校园论坛项目"></a>校园论坛项目</h1><h2 id="SpringBoot-版本-3-1-2，Mybatis-plus版本-3-5-1-3"><a href="#SpringBoot-版本-3-1-2，Mybatis-plus版本-3-5-1-3" class="headerlink" title="SpringBoot 版本 3.1.2，Mybatis-plus版本 3.5.1.3"></a>SpringBoot 版本 3.1.2，Mybatis-plus版本 3.5.1.3</h2><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>新建空项目，添加两个子模块后端forum-backend和前端forum-frontend，导入相关依赖。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240620105234477.png" alt="image-20240620105234477"></p>
<h2 id="配置Security配置类"><a href="#配置Security配置类" class="headerlink" title="配置Security配置类"></a>配置Security配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span>&#123;</span><br><span class="line">     <span class="comment">//lambada表达式</span></span><br><span class="line">     <span class="keyword">return</span> http</span><br><span class="line">         <span class="comment">//拦截</span></span><br><span class="line">         .authorizeHttpRequests(conf -&gt; conf </span><br><span class="line">                               .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>).permitAll() <span class="comment">//api验证操作允许放行</span></span><br><span class="line">                               .anyRequest().authenticated()<span class="comment">//其余操作全部拦截</span></span><br><span class="line">                               )</span><br><span class="line">         <span class="comment">//登录</span></span><br><span class="line">         .formLogin(conf -&gt; conf  </span><br><span class="line">                   .loginProcessingUrl(<span class="string">&quot;/api/auth/login&quot;</span>)</span><br><span class="line">                   .failureHandler(<span class="built_in">this</span>::onAuthenticationFailure)</span><br><span class="line">                   .successHandler(<span class="built_in">this</span>::onAuthenticationSuccess)</span><br><span class="line">                   )</span><br><span class="line">         <span class="comment">//退出登录</span></span><br><span class="line">         .logout(conf -&gt; conf </span><br><span class="line">                    .logoutUrl(<span class="string">&quot;/api/auth/logout&quot;</span>)</span><br><span class="line">                    .logoutSuccessHandler(<span class="built_in">this</span>::onLogoutSuccess)</span><br><span class="line">                    )</span><br><span class="line">         <span class="comment">//配置跨域</span></span><br><span class="line">         .csrf(conf -&gt; disable())</span><br><span class="line">         <span class="comment">//设置session为无状态</span></span><br><span class="line">         .sessionManagement(conf -&gt; conf </span><br><span class="line">                           .sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">         .build();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                    Authentication authentication)</span> <span class="keyword">throws</span> IOException,ServletException&#123;</span><br><span class="line">    response.getWriter().write(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                    AuthenticationException exception)</span> <span class="keyword">throws</span> IOException,ServletException&#123;</span><br><span class="line">    response.getWriter().write(<span class="string">&quot;failure&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                            HttpServletResponse response, </span></span><br><span class="line"><span class="params">                            Authentication authentication)</span> <span class="keyword">throws</span> IOException,ServletException&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回的数据不标准，封装一个实体类，返回JSON格式的数据</p>
<h3 id="封装一个记录类型实体类，用于统一返回格式"><a href="#封装一个记录类型实体类，用于统一返回格式" class="headerlink" title="封装一个记录类型实体类，用于统一返回格式"></a>封装一个记录类型实体类，用于统一返回格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson2.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson2.JSONWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">RestBean</span>&lt;T&gt;(<span class="type">int</span> code, T data, String message) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestBean</span>&lt;&gt;(<span class="number">200</span>, data, <span class="string">&quot;请求成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">failure</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestBean</span>&lt;&gt;(code, <span class="literal">null</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">asJsonString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSONObject.toJSONString(<span class="built_in">this</span>, JSONWriter.Feature.WriteNulls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过fastjson将数据转换为json格式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                       HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                       AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">       response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">       response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">       response.getWriter().write(RestBean.failure(<span class="number">401</span>, exception.getMessage()).asJsonString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                       HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                       Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">       response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">       response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">       response.getWriter().write(RestBean.success().asJsonString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>完成基本登录，引入JWT令牌，登录之后发放令牌，创建一个JWT工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.security.jwt.key&#125;&quot;)</span></span><br><span class="line">    String key;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.security.jwt.expire&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> expire;</span><br><span class="line">    <span class="comment">//创建JWT</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createJwt</span><span class="params">(UserDetails details, <span class="type">int</span> id, String username)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="built_in">this</span>.expireTime();</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;id&quot;</span>, id)    <span class="comment">//自定义存入id</span></span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, username)    <span class="comment">//自定义存入name</span></span><br><span class="line">                .withClaim(<span class="string">&quot;authorities&quot;</span>, details.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())   <span class="comment">//自定义存入验证信息</span></span><br><span class="line">                .withExpiresAt(expire)  <span class="comment">//设置过期时间</span></span><br><span class="line">                .withIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())   <span class="comment">//设置颁发时间</span></span><br><span class="line">                .sign(algorithm);   <span class="comment">//签名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过期时间计算</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">expireTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.add(Calendar.HOUR, expire * <span class="number">24</span>);</span><br><span class="line">        <span class="keyword">return</span> calendar.getTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在登陆成功时颁发，放到Security配置类中的onAuthenticationSuccess方法中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) authentication.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtUtils.createJwt(user, <span class="number">1</span>,  user.getUsername());</span><br><span class="line">        <span class="type">AuthorizeVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizeVO</span>();</span><br><span class="line">        vo.setExpire(JWT.decode(token).getExpiresAt());</span><br><span class="line">        vo.setRole(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        vo.setToken(token);</span><br><span class="line">        vo.setUsername(user.getUsername());</span><br><span class="line">        response.getWriter().write(RestBean.success(vo).asJsonString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>新建vo响应类，统一返回数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登陆成功后的响应类</span></span><br><span class="line"><span class="comment"> * 返回用户名、角色、token、过期时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeVO</span> &#123;</span><br><span class="line">    String username;</span><br><span class="line">    String role;</span><br><span class="line">    String token;</span><br><span class="line">    Date expire;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置JWT后，需要进行校验，SpringSecurity自带一个过滤器链机制，需要把我们自定义的一些规则加入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthorizeFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    JwtUtils jwtUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                    HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> jwtUtils.resolveJwt(authorization);</span><br><span class="line">        <span class="keyword">if</span> (jwt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//jwt不为空，将用户信息解析出来放入UserDetails</span></span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> jwtUtils.toUser(jwt);</span><br><span class="line">            <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user, <span class="literal">null</span>, user.getAuthorities());</span><br><span class="line">            authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            request.setAttribute(<span class="string">&quot;id&quot;</span>, jwtUtils.toId(jwt));</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JWTUtils也要加入对应方法，供解析</span></span><br><span class="line"><span class="comment">//将JWT解析为UserDetails</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">toUser</span><span class="params">(DecodedJWT jwt)</span>&#123;</span><br><span class="line">        Map&lt;String, Claim&gt; claims = jwt.getClaims();</span><br><span class="line">        <span class="keyword">return</span> User</span><br><span class="line">                .withUsername(claims.get(<span class="string">&quot;name&quot;</span>).asString())</span><br><span class="line">                .password(<span class="string">&quot;*****&quot;</span>)</span><br><span class="line">                .authorities(claims.get(<span class="string">&quot;authorities&quot;</span>).asArray(String.class))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将JWT解析为id</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">toId</span><span class="params">(DecodedJWT jwt)</span>&#123;</span><br><span class="line">        Map&lt;String, Claim&gt; claims = jwt.getClaims();</span><br><span class="line">        <span class="keyword">return</span> claims.get(<span class="string">&quot;id&quot;</span>).asInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断token是否合法，合法即切割开头自带Bearer返回</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">convertToken</span><span class="params">(String headerToken)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headerToken == <span class="literal">null</span> || !headerToken.startsWith(<span class="string">&quot;Bearer &quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> headerToken.substring(<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完成之后，将过滤器链加入Security配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跨域</span></span><br><span class="line">                .csrf(AbstractHttpConfigurer::disable)</span><br><span class="line">                <span class="comment">//设置session无状态</span></span><br><span class="line">                .sessionManagement(conf -&gt; conf</span><br><span class="line">                                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">                <span class="comment">//添加过滤器,放在默认之前</span></span><br><span class="line">                .addFilterBefore(jwtAuthorizeFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>

<p>加入异常处理，确保jwt异常时，输出格式的合理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改后的Security配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    JwtUtils jwtUtils;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    JwtAuthorizeFilter jwtAuthorizeFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                <span class="comment">//拦截</span></span><br><span class="line">                .authorizeHttpRequests(conf -&gt; conf</span><br><span class="line">                                        .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>).permitAll()</span><br><span class="line">                                        .anyRequest().authenticated())</span><br><span class="line">                <span class="comment">//登录</span></span><br><span class="line">                .formLogin(conf -&gt; conf</span><br><span class="line">                        .loginProcessingUrl(<span class="string">&quot;/api/auth/login&quot;</span>)</span><br><span class="line">                        .failureHandler(<span class="built_in">this</span>::onAuthenticationFailure)</span><br><span class="line">                        .successHandler(<span class="built_in">this</span>::onAuthenticationSuccess))</span><br><span class="line"></span><br><span class="line">                <span class="comment">//退出</span></span><br><span class="line">                .logout(conf -&gt; conf</span><br><span class="line">                        .logoutUrl(<span class="string">&quot;/api/auth/logout&quot;</span>)</span><br><span class="line">                        .logoutSuccessHandler(<span class="built_in">this</span>::onLogoutSuccess))</span><br><span class="line"></span><br><span class="line">                <span class="comment">//jwt异常处理</span></span><br><span class="line">                .exceptionHandling(conf -&gt; conf</span><br><span class="line">                        .authenticationEntryPoint(<span class="built_in">this</span>::onUnauthorized)</span><br><span class="line">                        .accessDeniedHandler(<span class="built_in">this</span>::onAccessDeny))</span><br><span class="line">                <span class="comment">//跨域</span></span><br><span class="line">                .csrf(AbstractHttpConfigurer::disable)</span><br><span class="line">                <span class="comment">//设置session无状态</span></span><br><span class="line">                .sessionManagement(conf -&gt; conf</span><br><span class="line">                                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">                <span class="comment">//添加过滤器,放在默认之前</span></span><br><span class="line">                .addFilterBefore(jwtAuthorizeFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAccessDeny</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             AccessDeniedException exception)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(RestBean.forbidden(exception.getMessage()).asJsonString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUnauthorized</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                AuthenticationException exception)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(RestBean.unauthorized(exception.getMessage()).asJsonString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        AuthenticationException exception)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(RestBean.unauthorized(exception.getMessage()).asJsonString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        Authentication authentication)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) authentication.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtUtils.createJwt(user, <span class="number">1</span>,  user.getUsername());</span><br><span class="line">        <span class="type">AuthorizeVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizeVO</span>();</span><br><span class="line">        vo.setExpire(JWT.decode(token).getExpiresAt());</span><br><span class="line">        vo.setRole(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        vo.setToken(token);</span><br><span class="line">        vo.setUsername(user.getUsername());</span><br><span class="line">        response.getWriter().write(RestBean.success(vo).asJsonString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写jwtUtils，logout删除jwt的方法</span></span><br><span class="line">    <span class="comment">//令牌失效方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">invalidateJwt</span><span class="params">(String headerToken)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">this</span>.convertToken(headerToken);</span><br><span class="line">        <span class="keyword">if</span>(token == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//获取相同的key，指定相同的jwt算法</span></span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="comment">//创建验证器，用于验证JWT合法性</span></span><br><span class="line">        <span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(algorithm).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置黑名单，通过jwt的id来判断，因此在下面create的时候加入uuid生成的id</span></span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line">            <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> jwt.getId();</span><br><span class="line">            <span class="keyword">return</span> deleteToken(id, jwt.getExpiresAt());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JWTVerificationException e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让令牌失效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">deleteToken</span><span class="params">(String uuid, Date time)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isInvalidToken(uuid))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//设置过期时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> Math.max(time.getTime() - now.getTime(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//存入redis</span></span><br><span class="line">        template.opsForValue().set(Const.JWT_BLACK_LIST + uuid, <span class="string">&quot;&quot;</span>, expire, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否失效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInvalidToken</span><span class="params">(String uuid)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(template.hasKey(Const.JWT_BLACK_LIST + uuid));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//完善Security配置类的onLogoutSuccess方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (jwtUtils.invalidateJwt(authorization))&#123;</span><br><span class="line">            writer.write(RestBean.success(<span class="string">&quot;退出成功&quot;</span>).asJsonString());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            writer.write(RestBean.failure(<span class="number">400</span>, <span class="string">&quot;退出失败&quot;</span>).asJsonString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置连接数据库"><a href="#配置连接数据库" class="headerlink" title="配置连接数据库"></a>配置连接数据库</h2><p>新建一个用户表，在dto中封装实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;db_account&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">    Integer id;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">    String email;</span><br><span class="line">    String role;</span><br><span class="line">    Date registerTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导入mybatis-plus依赖。</p>
<p>编写mapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Account&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写service和impl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Account&gt; &#123;</span><br><span class="line">        Account <span class="title function_">findAccountByNameOrEmail</span><span class="params">(String text)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;AccountMapper, Account&gt; <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="built_in">this</span>.findAccountByNameOrEmail(username);</span><br><span class="line">        <span class="keyword">if</span> (account == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> User</span><br><span class="line">                .withUsername(username)</span><br><span class="line">                .password(account.getPassword())</span><br><span class="line">                .roles(account.getRole())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findAccountByNameOrEmail</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.query()</span><br><span class="line">                .eq(<span class="string">&quot;username&quot;</span>, text).or()</span><br><span class="line">                .eq(<span class="string">&quot;email&quot;</span>, text)</span><br><span class="line">                .one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="封装对象转换接口"><a href="#封装对象转换接口" class="headerlink" title="封装对象转换接口"></a>封装对象转换接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseData</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; V <span class="title function_">asViewObject</span><span class="params">(Class&lt;V&gt; clazz, Consumer&lt;V&gt; consumer)</span>&#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="built_in">this</span>.asViewObject(clazz);</span><br><span class="line">        consumer.accept(v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; V <span class="title function_">asViewObject</span><span class="params">(Class&lt;V&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">            Constructor&lt;V&gt; constructor = clazz.getConstructor();</span><br><span class="line">            <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">            <span class="keyword">for</span> (Field declaredField : declaredFields) convert(declaredField, v);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ReflectiveOperationException exception)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(Field field, Object vo)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">source</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getDeclaredField(field.getName());</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            source.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            field.set(vo, source.get(<span class="built_in">this</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalAccessException | NoSuchFieldException ignored)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类去实现这个接口，在需要使用的时候调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) authentication.getPrincipal();</span><br><span class="line"><span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> accountService.findAccountByNameOrEmail(user.getUsername());</span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtUtils.createJwt(user, account.getId(),  account.getUsername());</span><br><span class="line"><span class="type">AuthorizeVO</span> <span class="variable">vo</span> <span class="operator">=</span> account.asViewObject(AuthorizeVO.class, v -&gt; &#123;</span><br><span class="line">    v.setExpire(JWT.decode(token).getExpiresAt());</span><br><span class="line">    v.setToken(token);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="后端配置跨域问题"><a href="#后端配置跨域问题" class="headerlink" title="后端配置跨域问题"></a>后端配置跨域问题</h3><p>新建一个CorsFilter跨域过滤器</p>
<p>指定优先级，优先级需要在Security之前，Security默认为-100</p>
<p>继承一个HttpFilter，重写doFilter方法。</p>
<p>编写方法，传入请求和响应，向响应头中添加“Origin，GET，POST，PUT等，添加”Authorization，Content-Type“</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(Const.ORDER_CORS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsFilter</span> <span class="keyword">extends</span> <span class="title class_">HttpFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                            HttpServletResponse response,</span></span><br><span class="line"><span class="params">                            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.addCorsHeader(request, response);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addCorsHeader</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response)</span>&#123;</span><br><span class="line">        response.addHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, request.getHeader(<span class="string">&quot;Origin&quot;</span>));</span><br><span class="line">        response.addHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET, POST, PUT, DELETE, OPTIONS&quot;</span>);</span><br><span class="line">        response.addHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Authorization, Content-Type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过rabbitmq发送验证码"><a href="#通过rabbitmq发送验证码" class="headerlink" title="通过rabbitmq发送验证码"></a>通过rabbitmq发送验证码</h2><h3 id="配置消息队列"><a href="#配置消息队列" class="headerlink" title="配置消息队列"></a>配置消息队列</h3><p>注册一个Bean，邮件队列，用于将数据放入rabbitmq</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;emailQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">emailQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(<span class="string">&quot;mail&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个消息队列监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;mail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailQueueListener</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    JavaMailSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMailMessage</span><span class="params">(Map&lt;String, Object&gt; data)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> data.get(<span class="string">&quot;email&quot;</span>).toString();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> (Integer) data.get(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> data.get(<span class="string">&quot;type&quot;</span>).toString();</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;register&quot;</span> -&gt; creatMessage(<span class="string">&quot;注册验证码&quot;</span>, <span class="string">&quot;您的验证码是：&quot;</span> + code + <span class="string">&quot;, 有效时间1分钟, 打死不要告诉其他人！&quot;</span>, email);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;reset&quot;</span> -&gt; creatMessage(<span class="string">&quot;重置验证码&quot;</span>, <span class="string">&quot;您的验证码是：&quot;</span> + code + <span class="string">&quot;, 有效时间1分钟, 打死不要告诉其他人！&quot;</span>, email);</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(message == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        sender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimpleMailMessage <span class="title function_">creatMessage</span><span class="params">(String title, String content, String email)</span>&#123;</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">        message.setSubject(title);</span><br><span class="line">        message.setText(content);</span><br><span class="line">        message.setTo(email);</span><br><span class="line">        message.setFrom(username);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>监听到验证码之后发送编辑的短信到指定用户。</p>
<p>编写注册邮件验证码发送方法：</p>
<p>生成一个随机验证码，通过random实现。生成之后存入Map丢进消息队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;AccountMapper, Account&gt; <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    FlowUtils flowUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="built_in">this</span>.findAccountByNameOrEmail(username);</span><br><span class="line">        <span class="keyword">if</span> (account == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> User</span><br><span class="line">                .withUsername(username)</span><br><span class="line">                .password(account.getPassword())</span><br><span class="line">                .roles(account.getRole())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findAccountByNameOrEmail</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.query()</span><br><span class="line">                .eq(<span class="string">&quot;username&quot;</span>, text).or()</span><br><span class="line">                .eq(<span class="string">&quot;email&quot;</span>, text)</span><br><span class="line">                .one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">registerEmailVerifyCode</span><span class="params">(String type, String email, String ip)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ip.intern())&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.verifyLimit(ip))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;请求频繁，请稍后再试！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> random.nextInt(<span class="number">899999</span>) + <span class="number">100000</span>;</span><br><span class="line">            Map&lt;String, Object&gt; data = Map.of(<span class="string">&quot;type&quot;</span>, type, <span class="string">&quot;email&quot;</span>, email, <span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">            amqpTemplate.convertAndSend(<span class="string">&quot;mail&quot;</span>, data);</span><br><span class="line">            template.opsForValue()</span><br><span class="line">                    .set(Const.VERIFY_EMAIL_DATA + email, String.valueOf(code), <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">verifyLimit</span><span class="params">(String ip)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> Const.VERIFY_EMAIL_LIMIT + ip;</span><br><span class="line">        <span class="keyword">return</span> flowUtils.limitOnceCheck(key, <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写限流工具，防止用户重复发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowUtils</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate template;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">limitOnceCheck</span><span class="params">(String key, <span class="type">int</span> blockTime)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Boolean.TRUE.equals(template.hasKey(key)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            template.opsForValue().set(key, <span class="string">&quot;&quot;</span>, blockTime, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加spring-boot-starter-validated依赖，进行参数校验"><a href="#添加spring-boot-starter-validated依赖，进行参数校验" class="headerlink" title="添加spring-boot-starter-validated依赖，进行参数校验"></a>添加spring-boot-starter-validated依赖，进行参数校验</h3><p>在请求参数的地方加入对应的校验</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/ask-code&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestBean&lt;Void&gt; <span class="title function_">askVerifyCode</span><span class="params">(<span class="meta">@RequestParam</span> <span class="meta">@Email</span> String email,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@RequestParam</span> <span class="meta">@Pattern(regexp = &quot;(register|reset)&quot;)</span> String type,</span></span><br><span class="line"><span class="params">                                        HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> service.registerEmailVerifyCode(type, email, request.getRemoteAddr());</span><br><span class="line">        <span class="keyword">return</span> message == <span class="literal">null</span> ? RestBean.success() : RestBean.failure(<span class="number">400</span>, message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>编写一个校验错误返回参数接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">validationController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> RestBean&lt;Void&gt; <span class="title function_">validateException</span><span class="params">(ValidationException exception)</span>&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Resolve [&#123;&#125;: &#123;&#125;]&quot;</span>, exception.getClass().getName(), exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> RestBean.failure(<span class="number">400</span>, <span class="string">&quot;请求参数有误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写注册对象内容实体类"><a href="#编写注册对象内容实体类" class="headerlink" title="编写注册对象内容实体类"></a>编写注册对象内容实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailRegisterVO</span> &#123;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    String mail;</span><br><span class="line">    <span class="meta">@Length(max = 6, min = 6)</span></span><br><span class="line">    String code;</span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^[a-zA-Z0-9\\u4e00-\\u9fa5]+$&quot;)</span></span><br><span class="line">    <span class="meta">@Length(min = 1,max = 16)</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Length(min = 6, max = 12)</span></span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写service中的注册业务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">registerEmailAccount</span><span class="params">(EmailRegisterVO vo)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> vo.getEmail();</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> vo.getUsername();</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> template.opsForValue().get(Const.VERIFY_EMAIL_DATA + email);</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;请先获取验证码！&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!code.equals(vo.getCode())) <span class="keyword">return</span> <span class="string">&quot;验证码输入错误，请重新输入&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.existsAccountByEmail(email)) <span class="keyword">return</span> <span class="string">&quot;此电子邮件已被其他用户注册&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.existsAccountByUsername(username)) <span class="keyword">return</span> <span class="string">&quot;此用户名已被其他用户使用&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> passwordEncoder.encode(vo.getPassword());</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="literal">null</span>, username, password, email, <span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.save(account))&#123;</span><br><span class="line">        template.delete(Const.VERIFY_EMAIL_DATA + email);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;内部错误，请联系管理员&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">existsAccountByEmail</span><span class="params">(String email)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baseMapper.exists(Wrappers.&lt;Account&gt;query().eq(<span class="string">&quot;email&quot;</span>, email));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">existsAccountByUsername</span><span class="params">(String username)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baseMapper.exists(Wrappers.&lt;Account&gt;query().eq(<span class="string">&quot;username&quot;</span>, username));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestBean&lt;Void&gt; <span class="title function_">register</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> EmailRegisterVO vo)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.messageHandle(() -&gt;</span><br><span class="line">            service.registerEmailAccount(vo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/06/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>start</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言面试</title>
    <url>/2024/06/13/Java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h3><ol>
<li>什么是Java</li>
<li>Java语言有哪些特点</li>
<li>JVM，JDK，JRE有什么区别</li>
<li>什么是跨平台性？原理是什么</li>
<li>什么是字节码？采用字节码的好处</li>
<li>为什么说Java语言“编译与解释并存”</li>
</ol>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ol>
<li>Java有哪些数据类型</li>
<li>自动类型转换、强制类型转换</li>
<li>什么是自动拆箱&#x2F;封箱</li>
<li>&amp;&amp;和&amp;的区别</li>
<li>switch能否作用在byte&#x2F;long&#x2F;String上</li>
<li>break、continue、return区别及作用</li>
<li>最有效率的方法计算2乘以8</li>
<li>自增自减运算</li>
</ol>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ol>
<li>面向对象和面向过程的区别</li>
<li>面向对象有哪些特性</li>
<li>重载和重写的区别</li>
<li>访问修饰符public、private、protected、以及默认区别</li>
<li>this关键字的作用</li>
<li>抽象类和接口的区别</li>
<li>成员变量与局部变量的区别有哪些</li>
<li>静态变量和实例变量的区别？静态方法和实例方法？</li>
<li>final关键字作用</li>
<li>final、finally、finalize区别</li>
<li>&#x3D;&#x3D;和equals区别</li>
<li>hashCode和equals？</li>
</ol>
<ul>
<li>什么是hashcode</li>
<li>为什么要有hashcode</li>
<li>为什么重写equals时必须重写hashcode方法</li>
<li>为什么两个对象有相同的hashcode值他们也不一定是相等的</li>
</ul>
<p>13.Java是值传递，还是引用传递</p>
<p>14.深拷贝和浅拷贝</p>
<p>15.Java创建对象方式</p>
<h3 id="集合基础"><a href="#集合基础" class="headerlink" title="集合基础"></a>集合基础</h3><ol>
<li>Java中实现Map接口的有哪些类</li>
<li>遍历HashMap的方法</li>
</ol>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><ol>
<li>String是Java的基本数据类型吗？可以被继承吗</li>
<li>String和String Builder、String Buffer</li>
<li>String str1 &#x3D; new String(“abc”)和String str2 &#x3D; “abc”的区别</li>
<li>String不是不可变类吗？拼接如何实现</li>
<li>intern方法作用</li>
<li>Java的包装类有什么用？为什么需要包装类？</li>
<li>Object类常见方法</li>
</ol>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol>
<li>Java中异常层级结构</li>
<li>异常的处理机制</li>
<li>finally一定会执行吗</li>
</ol>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><ol>
<li>Java中IO流分为几种</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程JUC并发编程</title>
    <url>/2024/05/12/%E5%A4%9A%E7%BA%BF%E7%A8%8BJUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程JUC并发编程"><a href="#多线程JUC并发编程" class="headerlink" title="多线程JUC并发编程"></a>多线程JUC并发编程</h1><p><strong>JUC -&gt; Java.util.concurrent</strong></p>
<p><strong>进程</strong>：在操作系统之上，可以同时运行很多个进程，且每个进程之间相互隔离互不干扰，CPU通过时间片轮转算法给每个进程分配时间片，时间片使用结束后切换到下一个进程继续执行，实现了宏观上的多个程序同时运行。</p>
<p>由于每个进程之间都有一个自己的内存空间，进程间的通信很麻烦，且执行不同进程会产生上下文切换非常耗时。</p>
<p><strong>线程</strong>：一个进程可以拥有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程是程序执行流的最小单元，各个线程之间共享程序的内存空间（所在进程的内存空间），上下文切换的速度也高于进程。</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><p>并发执行也是只能同一时间处理一个任务，但是每个任务轮流做（时间片轮转）：</p>
<p>只要单次处理分配时间够短，宏观来看，就是同时进行。</p>
<p>但是当需要同时处理上百上千个任务，CPU跟不上线程数，所以要程序有良好的并发性能，来应对同一时间大量任务的处理。学习JUC处理高并发。</p>
<h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>突破了同一时间只能处理一个任务，可以同一时间处理多个任务。</p>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>通过<code>synchronized</code>关键字实现锁，一定是和某个对象关联的，因为底层需要获取到监视对象的监视器<code>monitor</code>，获取<code>monitor</code>，执行之后判断是否发生异常，会有两个<code>monitorexit</code>，如果程序正常执行完会执行第一个释放，如果发生异常，为了防止锁住，会使用<code>athorw</code>，指令抛出异常再释放。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>每个等待锁的线程都会被封装为ObjectWaiter对象，进入到如下机制：</p>
<p><img src="https://image.itbaima.cn/markdown/2023/03/06/OvufwzKx7l6yNMB.png" alt="image-20230306171005840"></p>
<p>ObjectWaiter会先进入Entry Set等待，当线程获取到对象的<code>monitor</code>后进入The Owner区域并把<code>monitor</code>中的<code>owner</code>变量设置为当前线程，同时<code>moniter</code>中的计数器<code>count</code>加一，若线程调用了<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>owner</code>变量恢复为<code>null</code>，<code>count</code>自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>并复位变量的值，以便其他线程进入获取对象的<code>monitor</code>。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的目标是，在无竞争情况下，减少重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。他不像是重量级锁那样，需要向操作系统申请互斥量。</p>
<blockquote>
<p> CAS（Compare And Swap）是一种无锁算法（我们之前在Springboot阶段已经讲解过了），它并不会为对象加锁，而是在执行的时候，看看当前数据的值是不是我们预期的那样，如果是，那就正常进行替换，如果不是，那么就替换失败。比如有两个线程都需要修改变量<code>i</code>的值，默认为10，现在一个线程要将其修改为20，另一个要修改为30，如果他们都使用CAS算法，那么并不会加锁访问<code>i</code>，而是直接尝试修改<code>i</code>的值，但是在修改时，需要确认<code>i</code>是不是10，如果是，表示其他线程还没对其进行修改，如果不是，那么说明其他线程已经将其修改，此时不能完成修改任务，修改失败。</p>
<p>在CPU中，CAS操作使用的是<code>cmpxchg</code>指令，能够从最底层硬件层面得到效率的提升。</p>
</blockquote>
<p>如果CAS操作失败了的话，那么说明可能这时有线程已经进入这个同步代码块了，这时虚拟机会再次检查对象的Mark Word，是否指向当前线程的栈帧，如果是，说明不是其他线程，而是当前线程已经有了这个对象的锁，直接放心大胆进同步代码块即可。如果不是，那确实是被其他线程占用了。</p>
<p>这时，轻量级锁一开始的想法就是错的（这时有对象在竞争资源，已经赌输了），所以说只能将锁膨胀为重量级锁，按照重量级锁的操作执行（注意锁的膨胀是不可逆的）</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁对比轻量级锁，消除了同步，不需要进行CAS操作。当某个线程第一次获得锁时，接下来如果没有其他线程获取此锁，那么持有锁的线程将不需要进行同步操作。</p>
<h3 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h3><p>某段代码加了锁，但在运行时根本不可能出现各个线程之间资源争夺的情况，这种情况下完全不需要加任何锁机制，所以锁会被消除。锁粗化则是代码中频繁出现互斥同步操作，比如在一个循环内部加锁，这样明显是非常消耗性能的，虚拟机一旦检测到这种操作，会将整个同步范围进行扩展。</p>
<h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><img src="https://image.itbaima.cn/markdown/2023/03/06/UMkWgFatBoLsfr5.png" alt="image-20230306171115671"></p>
<p>JMM（Java Memory Model）内存模型规定如下：</p>
<ul>
<li>所有的变量全部存储在主内存（注意这里包括下面提到的变量，指的都是会出现竞争的变量，包括成员变量、静态变量等，而局部变量这种属于线程私有，不包括在内）</li>
<li>每条线程有着自己的工作内存（可以类比CPU的高速缓存）线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据。</li>
<li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存。</li>
</ul>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h2 id="队列同步器AQS"><a href="#队列同步器AQS" class="headerlink" title="队列同步器AQS"></a>队列同步器AQS</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收机制</title>
    <url>/2024/05/08/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h1><h2 id="对象存活判定方法"><a href="#对象存活判定方法" class="headerlink" title="对象存活判定方法"></a>对象存活判定方法</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>只要一个对象还有实用价值，我们可以通过他的引用变量来进行操作</p>
<ul>
<li>每个对象都包含一个<strong>引用计数器</strong>，用于存放引用计数（被引用的次数)</li>
<li>每当有一个地方引用此对象时，引用计数加一</li>
<li>当引用失效时，引用计数减一</li>
<li>当引用计数为零时，表示此对象不可能再被引用。</li>
</ul>
<p>存在问题-&gt;两个对象相互引用，引用计数器的值始终为一。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>采用类似树结构搜索机制</p>
<p>每个对象引用都有机会成为树的根节点（GC Roots），成为根节点的条件：</p>
<ul>
<li>位于虚拟机的栈帧中的本地变量表索引用到的对象</li>
<li>类的静态成员变量所引用的对象</li>
<li>方法区中，常量池里面引用的对象，比如之前的<code>String</code>对象</li>
<li>被添加了锁的对象（synchronized）</li>
<li>虚拟机内部需要用到的对象</li>
</ul>
<p>一旦以及存在的根节点不满足存在的条件时，根节点与对象之间的连接将断开，如果对象存在对其它对象的引用，但是由于没有任何根节点的引用，所以此对象可被判定为不再使用。</p>
<h3 id="最终判定"><a href="#最终判定" class="headerlink" title="最终判定"></a>最终判定</h3><p>经历了可达性分析算法后基本可能判断哪些对象能够被回收，但是并不代表此对象一定会被回收，会在最终判定阶段进行挽留。</p>
<p><code>Object</code>类中的<code>finalize()</code>方法就是最终判定方法，如果子类重写了此方法，那么子类对象在被判定为可回收时，会执行这个方法进行二次确认。如果在二次确认后对象不满足可回收条件，那么对象不会被回收。</p>
<p>只能执行一次，第二次执行的时候会跳过，直接回收。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h3><p>Java虚拟机将堆内存划分为<strong>新生代</strong>，<strong>老年代</strong>，<strong>永久代</strong>。</p>
<p><img src="https://image.itbaima.cn/markdown/2023/03/06/OZrKbUm39lfaAgv.png" alt="image-20230306165311823"></p>
<p>新创建的对象会放入Eden区，进行一次扫描，引用为空的对象会丢掉，剩下存活的对象转移到Survivor区，一开始From和To区都是空的，所有Eden存活的对象进入From区，最后From和To进行一次交换。</p>
<p>下一次垃圾回收，操作与上次一样，但是From区中有对象了，因此Eden区中的对象复制到From区后，会对To区的对象进行判定（每经历一次垃圾回收，年龄+1，对象年龄大于15，会直接进入老年代，否则会移入From区）</p>
<p>垃圾收集分为：</p>
<ul>
<li>Minor GC - 次要垃圾回收，主要进行新生代区域垃圾收集<ul>
<li>触发条件：新生代Eden区容量满</li>
</ul>
</li>
<li>Major GC：主要垃圾回收，主要对老年代垃圾收集</li>
<li>Full GC：完全垃圾回收，对整个Java堆内存和方法区进行垃圾回收。<ul>
<li>触发条件：<ul>
<li>每次晋升到老年代的对象平均大小大于老年代剩余空间</li>
<li>Minor GC后存活的对象超过了老年代剩余空间</li>
<li>永久代空间不足（JDK8之前）</li>
<li>手动调用System.gc()方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记所有需要回收的对象，然后再依次回收被标记的对象，或者是标记所有不需要回收的对象，回收没有被标记的对象。</p>
<p>缺点：如果存在大量对象，就会存在大量标记，大规模清除后连续的内存空间可能会出现许多空袭，碎片化导致连续内存空间利用率降低。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>将容量分为大小相同的两块区域，每次清除垃圾后将存活的对象全部复制到另一个区域，解决了碎片化问题。适用于新生代</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记对象后，将所有待回收的对象整齐排列，将后续对象全部清除。</p>
<h2 id="垃圾收集器实现"><a href="#垃圾收集器实现" class="headerlink" title="垃圾收集器实现"></a>垃圾收集器实现</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>单线程，会终止当前用户线程，收集完后继续线程</p>
<h3 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge&#x2F;Parallel Old收集器"></a>Parallel Scavenge&#x2F;Parallel Old收集器</h3><p>JDK8使用这种组合方式垃圾回收方案</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><h3 id="Garbage-First（G1）收集器"><a href="#Garbage-First（G1）收集器" class="headerlink" title="Garbage First（G1）收集器"></a>Garbage First（G1）收集器</h3><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>JDK8时直接将本地内存作为元空间（<strong>Metaspace</strong>）的区域，物理内存有多大，元空间内存就可以有多大</p>
<p><img src="https://image.itbaima.cn/markdown/2023/03/06/2RD3AnPvbh1lQ5N.png" alt="image-20230306165703340"></p>
<h2 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h2><p>强引用：<code>Object o = new Object()</code>，JVM不会随意回收强引用对象</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>内存空间不足时，软引用指向对象会被回收，get()方法得到null，并且软引用对象本身被丢进队列中</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>进行垃圾回收时，不管内存空间是否充足，都会回收</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>教程</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO</title>
    <url>/2024/05/08/NIO/</url>
    <content><![CDATA[<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h3>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>NIO</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>链表及算法例题</title>
    <url>/2024/04/26/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
<p>链表的入口节点称为链表的头结点也就是head。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt="链表1"></p>
<h2 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>刚刚说的就是单链表。</p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>单链表中的指针域只能指向节点的下一个节点。</p>
<p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p>
<p>双链表 既可以向前查询也可以向后查询。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png" alt="链表2"></p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表，顾名思义，就是链表首尾相连。</p>
<p>循环链表可以用来解决约瑟夫环问题。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png" alt="链表4"></p>
<h2 id="链表的存储方式"><a href="#链表的存储方式" class="headerlink" title="链表的存储方式"></a>链表的存储方式</h2><p>了解完链表的类型，再来说一说链表在内存中的存储方式。</p>
<p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p>
<p>链表是通过指针域的指针链接在内存中各个节点。</p>
<p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p>
<p>Java实现链表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p>
<p>直接使用原链表删除元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不用if，因为移除头节点是一个持续的过程，如果链表是1-&gt;1-&gt;1,目标为1用if就错了。</span></span><br><span class="line"><span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val == target)&#123;</span><br><span class="line">    head = head.next;</span><br><span class="line">    <span class="comment">//如果是c++需要进行头节点的释放，其他语言有垃圾回收机制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = head;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(cur-&gt;next-&gt;val == target)&#123;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>

<p>使用虚拟头节点(在非头节点和头节点操作时统一了操作)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dummyhead = <span class="keyword">new</span> <span class="title class_">ListNode</span>;</span><br><span class="line">dummyhead.next = head;</span><br><span class="line">cur = dummyhead;<span class="comment">//实际删除的是cur的next</span></span><br><span class="line"><span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.next.val == target)&#123;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummyhead.next;</span><br></pre></td></tr></table></figure>

<p>题目代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="comment">//ListNode pre = dummyNode;</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cur = cur.next;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p>
<p>获取第n个节点的值（n从0开始）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cur = dummyhead.next;</span><br><span class="line"><span class="keyword">while</span>(n )&#123;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur.val;</span><br></pre></td></tr></table></figure>

<p>头部插入节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newnode = <span class="keyword">new</span> <span class="title class_">node</span>();</span><br><span class="line">newnode.next = dummyhead.next;</span><br><span class="line">dummynode.next = newnode;</span><br><span class="line">size++;</span><br></pre></td></tr></table></figure>

<p>尾部插入节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cur = dummyhead;</span><br><span class="line"><span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">cur.next = newnode;</span><br><span class="line">size++;</span><br></pre></td></tr></table></figure>

<p>第n个节点前插入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cur = dummyhead;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    cur =  cur.next;</span><br><span class="line">&#125;</span><br><span class="line">newnode.next = cur.next;</span><br><span class="line">cur.next = newnode;</span><br><span class="line">size++;</span><br></pre></td></tr></table></figure>

<p>删除第n个节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cur = dummyhead;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br><span class="line">cur.next = cur.next.next;</span><br><span class="line">size--;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>教程</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础常见面试题总结</title>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Java基础常见面试题总结"><a href="#Java基础常见面试题总结" class="headerlink" title="Java基础常见面试题总结"></a>Java基础常见面试题总结</h1><h2 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h2><h3 id="Java语言有哪些特点？"><a href="#Java语言有哪些特点？" class="headerlink" title="Java语言有哪些特点？"></a>Java语言有哪些特点？</h3><p>1.简单易学；</p>
<p>2.面向对象（封装，继承，多态）；</p>
<p>3.平台无关性（JVM实现了平台无关性）；</p>
<p>4.支持多线程（C++11之前 没有内置多线程机制，因此必须调用操作系统的多线程来进行多线程设计，而Java提供了多线程支持）；</p>
<p>5.可靠性（具有异常处理和自动内存管理机制）； </p>
<p>6.安全性（Java本身的设计就提供了多重防护机制如控制访问符、限制程序直接访问操作系统资源）；</p>
<p>7.高效性（通过JIT编译器等技术的优化，Java运行的效率还不错）</p>
<p>8.支持网络编程并且很方便；</p>
<p>9.编译与解释并存；</p>
<p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！—-JavaGuide</p>
<h3 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM &amp; JDK &amp; JRE"></a>JVM &amp; JDK &amp; JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，都会给出相同的结果。<strong>字节码和不同系统上的JVM是实现Java语言“一次编译，随处运行”的关键</strong></p>
<p>JVM并不只有一种，只要满足JVM规范，每个人都可以开发自己的专属JVM；</p>
<h4 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h4><p>JDK（Java Development Kit），他是功能齐全的Java SDK，是提供给开发者使用，能够创建和编译Java程序的开发套件。包含了JRE、编译Java源码的Javac以及一些其他工具（Javadoc、jdb、jconsole、javap等等）</p>
<p>JRE（Java Runtime Environment）是Java运行时的环境。他是已经运行已编译Java程序所需的内容的集合，主要包括Java虚拟机（JVM）、Java基础类库（Class Library）</p>
<p>总的来说，JRE是Java运行时的环境，仅包含Java应用程序的运行时环境和必要类库。JDK包含了JRE，同时还包括了其他工具，用于Java应用程序的开发和调试。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-include-jre.png" alt="JDK 包含 JRE"></p>
<h3 id="什么是字节码，采用字节码的好处？"><a href="#什么是字节码，采用字节码的好处？" class="headerlink" title="什么是字节码，采用字节码的好处？"></a>什么是字节码，采用字节码的好处？</h3><p>在Java中JVM可以理解的代码叫做字节码（拓展名为<code>.class</code>的文件），他不面向任何特定的处理器，只面向虚拟机。</p>
<p>Java通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行起来还是相对高效的。而且由于字节码并不针对特定的机器，因此Java程序无需重新编译即可在多种不同的操作系统的计算机上运行。</p>
<p><strong>Java 程序从源代码到运行的过程如下图所示</strong>：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png" alt="Java程序转变为机器代码的过程"></p>
<p><code>.class-&gt;机器码</code>这一步，JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式执行速度相对比较慢，而且有些方法和代码块经常需要被调用（热点代码），所以后面引进了JIT（Just In Time Commpliation）编译器，JIT属于运行时编译。当JIT编译器完成第一次编译后，会将字节码对应的机器码保存起来，下次可以直接使用。这也解释了为什么说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code-with-jit.png" alt="Java程序转变为机器代码的过程"></p>
<p>JDK、JRE、JVM、JIT 这四者的关系如下图所示。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png" alt="JDK、JRE、JVM、JIT 这四者的关系"></p>
<h3 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h3><p>高级编程语言按照程序执行方式分为两种：</p>
<ul>
<li><strong>编译型</strong>：编译型语言会将源代码一次性翻译成可以被该平台执行的机器码。一般情况下，该类型开发效率较低，执行速度较快。（C、C++、GO、Rust）</li>
<li><strong>解释型</strong>：解释型语言会通过解释器一句一句将代码解释为机器代码后再执行。该类型开发较快，执行速度较慢。（Python、JavaScript、PHP）</li>
</ul>
<h4 id="为什么说Java语言“编译与解释并存”？-1"><a href="#为什么说Java语言“编译与解释并存”？-1" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h4><p>因为Java语言既有编译型语言特征也有解释型语言特征。因为Java程序要经过先编译，后解释两个步骤，由Java编写的程序先经过编译步骤，生成字节码，这种字节码再由Java解释器来解释运行。</p>
<h3 id="AOT有什么优点？为什么不全部使用AOT？"><a href="#AOT有什么优点？为什么不全部使用AOT？" class="headerlink" title="AOT有什么优点？为什么不全部使用AOT？"></a>AOT有什么优点？为什么不全部使用AOT？</h3><p>JDK9新引入了一种新的编译模式AOT（Ahead of Time Compilation）。这种模式会在程序被执行前就将其编译成机器码，属于静态编译（C++，Rust，GO就是静态编译）。AOT避免了JIT预热等各方面开销，可以提高Java程序的启动速度，避免预热时间长。并且，AOT还能减少内存占用和增强Java程序的安全性（AOT编译后的代码不容易被反编译和修改），特别适用于云原生场景。</p>
<p>AOT的优势在于启动时间，内存占用和打包体积。JIT的优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>
<h3 id="既然-AOT-这么多优点，那为什么不全部使用这种编译方式呢？"><a href="#既然-AOT-这么多优点，那为什么不全部使用这种编译方式呢？" class="headerlink" title="既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？"></a>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</h3><p>两者各有优点，AOT更适合云原生场景，对微服务架构支持也比较友好，AOT无法支持Java一些动态特性，如反射、动态代理、动态加载等。然而很多的框架和库（Spring）都用到了这些特性。如果只使用AOT编译就没办法使用这些框架和库了。</p>
<h3 id="Java和C-的区别？"><a href="#Java和C-的区别？" class="headerlink" title="Java和C++的区别？"></a>Java和C++的区别？</h3><p>Java和C++都是面向对象语言，都支持封装、继承和多态</p>
<ul>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，C++支持多重继承；但是Java接口可以多继承</li>
<li>Java有自动内存管理垃圾回收机制（GC），不需要手动释放无用内存。</li>
<li>C++同时支持方法重载和操作符重载，Java只支持方法重载（操作符重载增加了复杂性，与Java最初的设计思想不符）</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="标识符和关键字区别？"><a href="#标识符和关键字区别？" class="headerlink" title="标识符和关键字区别？"></a>标识符和关键字区别？</h4><p>在编写程序时，需要大量为程序，方法，类，变量等取名字，于是简单来说<strong>标识符就是一个名字</strong></p>
<p>有些标识符，Java已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是<strong>关键字</strong>。</p>
<p>Java关键字：</p>
<p>这里列举截止到Java17所有的关键字及其功能：</p>
<ul>
<li><strong>abstract</strong> 声明一个类为抽象类或一个方法为抽象方法。</li>
<li><strong>assert</strong> 断言表达式使用，用来对某些东西进行判断，如果判断失败会抛出错误，默认无效，需要添加启动参数才能开启，一般在测试环境中使用。</li>
<li><strong>boolean</strong> 基本数据类型，布尔类型，只有true和false两种结果。</li>
<li><strong>break</strong> 用于for&#x2F;while循环语句中对循环提前终止，以及在switch语句中结束当前case语句块，防止程序继续向下执行。</li>
<li><strong>byte</strong> 基本数据类型，字节类型，可以表示1字节的数据，取值范围为-128 到 127。</li>
<li><strong>case</strong> 用于在switch语句中判断条件，匹配后执行相应的代码块。</li>
<li><strong>catch</strong> 用于捕获异常，处理try块中抛出的异常。</li>
<li><strong>char</strong> 基本数据类型，字符类型，表示单个字符（16位Unicode字符）表示范围为’\u0000’ (0) 到 ‘\uffff’ (65535)</li>
<li><strong>class</strong>：声明一个类型，此外，使用<code>类名.class</code>用于获取指定类型的Class对象。</li>
<li><strong>const</strong> 保留关键字，无实际用途。</li>
<li><strong>continue</strong>：用于for&#x2F;while循环语句中跳过当前循环的剩余代码，直接开启下一轮循环。</li>
<li><strong>default</strong> 在switch语句中表示默认情况，同时，在接口中也可以为抽象方法指定默认实现（仅Java8之后可用）</li>
<li><strong>do</strong> 用于do-while循环中定义循环体，循环开始前会执行一次循环。</li>
<li><strong>double</strong> 基本数据类型，双精度浮点数，表示范围为4.9e-324 到 1.8e+308，精度为15位小数。</li>
<li><strong>else</strong> 与if语句一起使用，表示条件不成立时执行的代码块，也可以与if组合为else if判断。</li>
<li><strong>enum</strong> 声明枚举类型。</li>
<li><strong>extends</strong> 声明类继承另一个类，在接口中可以继承多个其他接口，在泛型类中List&lt;? extends Number&gt;表示为类型参数设定上界。</li>
<li><strong>final</strong> 声明一个变量的值不可修改、一个类不能被继承、一个方法不能被子类重写。</li>
<li><strong>finally</strong> 声明一个代码块，在异常处理时，无论是否发生异常都会执行。</li>
<li><strong>float</strong> 基本数据类型，单精度浮点数，表示范围为1.4e-45 到 3.4e+38，精度为6-7位小数。</li>
<li><strong>for</strong> 创建for循环语句。</li>
<li><strong>if</strong> 创建条件判断语句。</li>
<li><strong>implements</strong> 表示一个类实现的接口，可以跟一个或多个接口。</li>
<li><strong>import</strong> 用于导入包或类。</li>
<li><strong>instanceof</strong> 用于判断对象是否为指定类型。</li>
<li><strong>int</strong> 基本数据类型，整数类型，取值范围为-2^31 到 2^31-1。</li>
<li><strong>interface</strong>：定义接口。</li>
<li><strong>long</strong> 基本数据类型，长整数类型，取值范围为-2^63 到 2^63-1。</li>
<li><strong>native</strong> 用于声明一个本地方法，方法的实现使用非Java语言编写，一般为C或C++编写，详情请看JVM篇JNI相关介绍。</li>
<li><strong>new</strong> 用于实例化对象。</li>
<li><strong>null</strong> 表示空对象引用。</li>
<li><strong>package</strong> 用于声明包。</li>
<li><strong>private</strong> 权限修饰符，表示私有的，仅在类的内部可见。</li>
<li><strong>protected</strong> 权限修饰符，表示受保护的，仅当前类和子类可见。</li>
<li><strong>public</strong> 权限修饰符，表示公共的，对所有类可见。</li>
<li><strong>record</strong> 用于声明记录类型，Java14新增类型。</li>
<li><strong>return</strong> 用于方法返回值。</li>
<li><strong>sealed</strong> 用于声明密封类型，Java17新增类型。</li>
<li><strong>non-sealed</strong> 用于声明类型为非密封类型，Java17新增类型。</li>
<li><strong>short</strong> 用于声明短整型变量。</li>
<li><strong>static</strong> 将类、方法、属性声明为静态的。</li>
<li><strong>strictfp</strong> 用于确保浮点运算结果一致。</li>
<li><strong>super</strong> 表示父类对象，在泛型类中List&lt;? super Integer&gt;表示为类型参数设定下界，在编写子类构造方法时，默认需要优先执行super()调用父类构造方法（无参情况下可省略）在Java22之后super不再要求强制优先调用。</li>
<li><strong>switch</strong> 用于多重条件判断，在Java13之后可以使用switch表达式。</li>
<li><strong>synchronized</strong> 用于线程同步加锁。</li>
<li><strong>this</strong> 表示当前对象，使用this()可以调用当前类型的构造方法。</li>
<li><strong>throw</strong> 抛出异常对象。</li>
<li><strong>throws</strong> 在方法声明中指定可能被抛出的异常。</li>
<li><strong>transient</strong> 声明变量在对象序列化时不参与序列化。</li>
<li><strong>try</strong> 异常捕获的起始块。</li>
<li><strong>void</strong> 表示没有返回值。</li>
<li><strong>volatile</strong> 用于可能会被多个线程同时修改的变量，使其保证线程之间的可见性，禁止指令重排，但无法保证原子性，详情请见JUC篇视频教程。</li>
<li><strong>while</strong> 用于创建while循环，当条件满足时执行代码块。</li>
</ul>
<h4 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h4><p><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</p>
<p><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</p>
<p><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</p>
<h4 id="continue、break和return区别？"><a href="#continue、break和return区别？" class="headerlink" title="continue、break和return区别？"></a>continue、break和return区别？</h4><p>1.<code>continue</code>: 跳出当前这一次的循环，继续下一次循环</p>
<p>2.<code>break</code>: 跳出整个循环体，继续执行循环下面的语句。</p>
<p>3.<code>return</code>: 跳出所在的方法，结束该方法运行。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java中有8种基本数据类型：</p>
<ul>
<li>6种数字型：<ul>
<li>4中整数型：byte、short、int、long</li>
<li>2种浮点型：float、double</li>
</ul>
</li>
<li>1种字符类型：char</li>
<li>1种布尔类型：boolean</li>
</ul>
<p>对应的包装类型：Byte、Short、Integer、Long、Float、Double、Character、Boolean</p>
<h3 id="基本数据类型和包装类型的区别？"><a href="#基本数据类型和包装类型的区别？" class="headerlink" title="基本数据类型和包装类型的区别？"></a>基本数据类型和包装类型的区别？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/primitive-type-vs-packaging-type.png" alt="基本类型 vs 包装类型"></p>
<p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</p>
<p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p>
<p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p>
<p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p>
<p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p>
<p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p>
<h3 id="包装类型的缓存机制？"><a href="#包装类型的缓存机制？" class="headerlink" title="包装类型的缓存机制？"></a>包装类型的缓存机制？</h3><p>Java基本数据类型的包装类型大部分都用到了缓存机制来提升性能。</p>
<p>Byte、Short、Integer、Long这四种包装类默认创建了数值[-128, 127]的相应类型的缓存数据，Character创建了数值在[0, 127]范围的缓存数据，Boolean直接返回True或者False。</p>
<p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<h3 id="自动装箱与拆箱？原理？"><a href="#自动装箱与拆箱？原理？" class="headerlink" title="自动装箱与拆箱？原理？"></a>自动装箱与拆箱？原理？</h3><p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>装箱其实就是调用了包装类的valueOf()方法，拆箱调用了xxxValue()方法。</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p><strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="成员变量与局部变量的区别"><a href="#成员变量与局部变量的区别" class="headerlink" title="成员变量与局部变量的区别"></a>成员变量与局部变量的区别</h4><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/member-var-vs-local-var.png" alt="成员变量 vs 局部变量"></p>
<ul>
<li><p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
<p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
<p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p>
<p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
</li>
</ul>
<h4 id="为什么成员变量有默认值？"><a href="#为什么成员变量有默认值？" class="headerlink" title="为什么成员变量有默认值？"></a>为什么成员变量有默认值？</h4><p>1.变量存储的是内存地址对应的任意随机值，程序读取该值时会出现意外。</p>
<p>2.默认值有两种设置方式：手动和自动</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="静态方法为什么不能调用非静态成员？"><a href="#静态方法为什么不能调用非静态成员？" class="headerlink" title="静态方法为什么不能调用非静态成员？"></a>静态方法为什么不能调用非静态成员？</h4><p>1.静态方法是属于类的，类加载时就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化后才存在，需要通过类的实例对象去调用。</p>
<p>2.在类的非静态成员不存在时静态方法就已经存在了，此时内存调用内存中不存在的非静态成员属于非法操作。</p>
<h4 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h4><p><strong>重载</strong></p>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同，个数不同，顺序不同，返回值和访问修饰符可以不同。</p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<p>1.方法名】参数列表必须相同，子类方法返回值类型应比父类方法返回值类型相同或更小，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>
<p>2.如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p>
<p>3.构造方法无法被重写</p>
<h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p>两者区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆分成一个个方法，通过一个个方法解决问题。</li>
<li>面向对象会先抽象出对象，然后对象执行方法来解决问题。</li>
</ul>
<p>面向对象开发的程序一般更易维护、易服用、易扩展。</p>
<h3 id="创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>创建一个对象用什么运算符？对象实体与对象引用有何不同？</h3><p>new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象应用存放在栈内存中）。</p>
<ul>
<li>一个对象引用可以指向0或1个对象</li>
<li>一个对象可以有n个引用指向它</li>
</ul>
<h3 id="对象相等和引用相等区别"><a href="#对象相等和引用相等区别" class="headerlink" title="对象相等和引用相等区别"></a>对象相等和引用相等区别</h3><ul>
<li>对象的相等一般比较的是内存中存放的内容是否相等。</li>
<li>引用相等一般指的是指向的内存地址是否相等</li>
</ul>
<p><code>==</code>和<code>equals</code></p>
<h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h3><h5 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h5><ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现的方法（Java8可以用default关键字在接口中定义默认方法）</li>
</ul>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ul>
<li>接口主要用于对类的行为进行约束，实现某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是<code>public static final</code>类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可以在子类中被重新定义，也可被重新赋值。</li>
</ul>
<h3 id="深拷贝和浅拷贝区别？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别？什么是引用拷贝？"></a>深拷贝和浅拷贝区别？什么是引用拷贝？</h3><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
<p><strong>引用拷贝</strong>：引用拷贝就是两个不同的引用指向同一个对象。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object类常见方法？"><a href="#Object类常见方法？" class="headerlink" title="Object类常见方法？"></a>Object类常见方法？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals()的区别"></a>&#x3D;&#x3D; 和 equals()的区别</h3><p><code>==</code>对于基本类型和引用类型作用效果是不同的：</p>
<ul>
<li>对基本类型来说，<code>==</code>比较的是值。</li>
<li>对引用数据来说，<code>==</code>比较的是对象的内存地址。</li>
</ul>
<p>equals()两种使用方法：</p>
<ul>
<li>类没有重写equals()方法：通过equals()比较该类的两个对象是，等价于通过“&#x3D;&#x3D;”比较</li>
<li>类重写了equals()方法：比较两个对象中的属性是否相等。</li>
</ul>
<h3 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode()有什么用？"></a>hashCode()有什么用？</h3><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<h3 id="为什么要有hashCode"><a href="#为什么要有hashCode" class="headerlink" title="为什么要有hashCode?"></a>为什么要有hashCode?</h3><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
<h3 id="那为什么JDK还要同时提供这两个方法呢？"><a href="#那为什么JDK还要同时提供这两个方法呢？" class="headerlink" title="那为什么JDK还要同时提供这两个方法呢？"></a>那为什么JDK还要同时提供这两个方法呢？</h3><p>因为在一些容器里（如HashMap、HashSet）中，有了hashCode()之后，判断元素是否相等效率更高。</p>
<p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<h3 id="那为什么不只提供hashCode-方法呢？"><a href="#那为什么不只提供hashCode-方法呢？" class="headerlink" title="那为什么不只提供hashCode()方法呢？"></a>那为什么不只提供hashCode()方法呢？</h3><p>因为两个对象的hashcode值相等并不代表两个对象就相等。</p>
<h3 id="为什么两个对象hashCode相等他们也不一定是相等的？"><a href="#为什么两个对象hashCode相等他们也不一定是相等的？" class="headerlink" title="为什么两个对象hashCode相等他们也不一定是相等的？"></a>为什么两个对象hashCode相等他们也不一定是相等的？</h3><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h3 id="为什么重写equals-时必须重写hashCode-方法？"><a href="#为什么重写equals-时必须重写hashCode-方法？" class="headerlink" title="为什么重写equals()时必须重写hashCode()方法？"></a>为什么重写equals()时必须重写hashCode()方法？</h3><p>因为两个相等的对象hashCode值必须相等。如果equals方法判断两个对象是否相等的，那么这两个对象的hashCode值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p><strong>总结</strong>：</p>
<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String、StringBuffer、StringBuilder的区别？"><a href="#String、StringBuffer、StringBuilder的区别？" class="headerlink" title="String、StringBuffer、StringBuilder的区别？"></a>String、StringBuffer、StringBuilder的区别？</h3><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><p>String是不可变的</p>
<h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>String中的对象是不可变的，也就可以理解为常量，线程安全。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ul>
<h3 id="字符串常量池作用"><a href="#字符串常量池作用" class="headerlink" title="字符串常量池作用"></a>字符串常量池作用</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Exception和Error区别？"><a href="#Exception和Error区别？" class="headerlink" title="Exception和Error区别？"></a>Exception和Error区别？</h3><p>Java中，所有异常都有一个共同祖先，java.lang包的Throwable类。</p>
<p>其中两个重要的子类：</p>
<ul>
<li>Exception：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li>Error：Error属于程序无法处理的错误。</li>
</ul>
<h3 id="finally中的代码一定会执行吗？"><a href="#finally中的代码一定会执行吗？" class="headerlink" title="finally中的代码一定会执行吗？"></a>finally中的代码一定会执行吗？</h3><p>不一定！某些情况下不会。</p>
<p>比如finally之前虚拟机被终止运行，finally中的代码就不会被执行。</p>
<p>在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p>
<ol>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型？作用是什么？"><a href="#什么是泛型？作用是什么？" class="headerlink" title="什么是泛型？作用是什么？"></a>什么是泛型？作用是什么？</h3><p>Java泛型是JDK5引入的新特性，使用泛型参数可以增强代码的可读性以及稳定性。</p>
<h3 id="泛型的使用方式有哪几种？"><a href="#泛型的使用方式有哪几种？" class="headerlink" title="泛型的使用方式有哪几种？"></a>泛型的使用方式有哪几种？</h3><p>泛型一般有三种使用方式：<strong>泛型类、泛型接口、泛型方法</strong>。</p>
<p><strong>1.泛型类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2.泛型接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现，不指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现，指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3.泛型方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">   &#123;</span><br><span class="line">         <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是框架的灵魂，它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p>
<h3 id="反射的优缺点？"><a href="#反射的优缺点？" class="headerlink" title="反射的优缺点？"></a>反射的优缺点？</h3><p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供的便利。但是，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>教程</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2024/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（Simple Responsibility Pinciple，SRP）是最简单的面向对象设计原则，它用于控制类的粒度大小。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cooking</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我会做饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teaching</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我会教书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>People类中功能太多，略显臃肿，应该将各种能力再细分成对应的职业：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cooker</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cooking</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我会做饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teaching</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我会教书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将类的粒度进行更近一步的划分，这样就很清晰了，包括我们以后在设计Mapper、Service、Controller等等，根据不同的业务进行划分，都可以采用单一职责原则，以它作为我们实现高内聚低耦合的指导方针。实际上我们的微服务也是参考了单一职责原则，每个微服务只应担负一个职责。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则（Open Close Principle）也是重要的面向对象设计原则。</p>
<p><code>软件实体应当对扩展开放，对修改关闭。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义抽象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Code&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">JavaCoder</span> <span class="keyword">extends</span> <span class="title class_">Code</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Java太卷了T_T&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类，只用定义这个类要求的行为，具体实现由需要实现他的类自行实现，有较好的扩展性延续性。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则（Liskov Substitution Principle）是对子类型的特别定义。它由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为 “数据的抽象与层次” 的演说中首先提出。</p>
<blockquote>
<p>所有引用基类的地方必须能透明地使用其子类的对象。</p>
</blockquote>
<p>简单的说就是，子类可以扩展父类的功能，但不能改变父类原有的功能：</p>
<ol>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入&#x2F;入参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的输出&#x2F;返回值）要比父类更严格或与父类一样。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会打lol&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我爱学习&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Son继承了Father，但是并没有覆盖play方法。符合里氏替换原则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会打lol&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我爱学习&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我爱cs&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Son覆盖了父类play，他不再具备父类的行为了，违背了里氏替换原则。</p>
<p>这种情况可以让他们两都继承于一个更高的类<code>People</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;   <span class="comment">//这个行为还是定义出来，但是不实现</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会打lol&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我爱学习&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我爱cs&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>依赖倒转原则（Dependence Inversion Principle）也是我们一直在使用的，最明显的就是我们的Spring框架了。</p>
<blockquote>
<p>高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>在之前，编写项目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//CRUD...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserServiceNew</span> &#123;   <span class="comment">//由于UserServiceNew发生变化，会直接影响到其他高层模块</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserMapper</span>();</span><br><span class="line">        <span class="comment">//业务代码....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;   <span class="comment">//焯，干嘛改底层啊，我这又得重写了</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();   <span class="comment">//哦豁，原来的不能用了</span></span><br><span class="line">        <span class="type">UserServiceNew</span> <span class="variable">serviceNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceNew</span>();   <span class="comment">//只能修改成新的了</span></span><br><span class="line">        <span class="comment">//业务代码....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Spring框架后，使用ServiceImpl来具体实现Service中的方法，Controller直接注入Service接口，这样修改实现也不用修改对应业务的逻辑。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则（Interface Segregation Principle, ISP）实际上是对接口的细化。</p>
<blockquote>
<p>客户端不应依赖那些它不需要的接口。  </p>
</blockquote>
<p>电脑和风扇都是电子设备，但是电脑拥有CPU显卡等部件，因此不能单单编写一个Device类让他们两个继承，需要细分为电子设备和普通设备，避免过多不需要的属性堆叠。</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则（Composite Reuse Principle）的核心就是委派。</p>
<blockquote>
<p>优先使用对象组合，而不是通过继承来达到复用的目的。</p>
</blockquote>
<p>可以将B中需要的A类当作B的一个属性 A a，在要用到B的时候进行指定A。</p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则（Law of Demeter）又称最少知识原则，是对程序内部数据交互的限制。</p>
<blockquote>
<p>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p>
</blockquote>
<p>简单来说就是，一个类&#x2F;模块对其他的类&#x2F;模块有越少的交互越好。当一个类发生改动，那么，与其相关的类（比如用到此类啥方法的类）需要尽可能少的受影响（比如修改了方法名、字段名等，可能其他用到这些方法或是字段的类也需要跟着修改）这样我们在维护项目的时候会更加轻松一些。</p>
<p>Test方法需要一个A类的name属性，传入时不传入A类，而是传入String name，在外部Main方法，直接提取A中的name传入Test。</p>
<h1 id="设计模式（创建型）"><a href="#设计模式（创建型）" class="headerlink" title="设计模式（创建型）"></a>设计模式（创建型）</h1><p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>使用<code>简单工厂模式</code>来创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;   <span class="comment">//水果抽象类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fruit</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot;@&quot;</span>+hashCode();   <span class="comment">//打印一下当前水果名称，还有对象的hashCode</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;   <span class="comment">//苹果，继承自水果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;  <span class="comment">//橘子，也是继承自水果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;橘子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，我们直接new就可以得到对象了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        System.out.println(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们将对象的创建封装到工厂中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里就直接来一个静态方法根据指定类型进行创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 水果类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的水果对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getFruit</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;苹果&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">           	<span class="keyword">case</span> <span class="string">&quot;橘子&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Orange</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以使用此工厂来创建对象了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> FruitFactory.getFruit(<span class="string">&quot;橘子&quot;</span>);   <span class="comment">//直接问工厂要，而不是我们自己去创建</span></span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用对扩展开放，对修改关闭的性质，将<code>简单工厂模式</code>改进为<code>工厂方法模式</code>，那现在既然不让改，那么我们就看看如何去使用扩展的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; &#123;   <span class="comment">//将水果工厂抽象为抽象类，添加泛型T由子类指定水果类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title function_">getFruit</span><span class="params">()</span>;  <span class="comment">//不同的水果工厂，通过此方法生产不同的水果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">extends</span> <span class="title class_">FruitFactory</span>&lt;Apple&gt; &#123;  <span class="comment">//苹果工厂，直接返回Apple，一步到位</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Apple <span class="title function_">getFruit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以使用不同类型的工厂来生产不同类型的水果了，并且如果新增了水果类型，直接创建一个新的工厂类就行，不需要修改之前已经编写好的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">AppleFactory</span>()::getFruit);   <span class="comment">//比如我们现在要吃一个苹果，那么就直接通过苹果工厂来获取苹果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法模拟吃掉一个水果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Supplier&lt;Fruit&gt; supplier)</span>&#123;</span><br><span class="line">        System.out.println(supplier.get()+<span class="string">&quot; 被吃掉了，真好吃。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就简单实现了工厂方法模式，通过工厂来屏蔽对象的创建细节，使用者只需要关心如何去使用对象即可。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>经常看到有很多的框架都为我们提供了形如<code>XXXBuilder</code>的类型，我们一般也是使用这些类来创建我们需要的对象。</p>
<p>JavaSE中的StringBulider类。。。</p>
<p>现在有一个学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">    String name;</span><br><span class="line">    String college;</span><br><span class="line">    String profession;</span><br><span class="line">    List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, <span class="type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.college = college;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">        <span class="built_in">this</span>.awards = awards;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的属性很多，直接构造容易出错。所以，我们现在可以使用建造者模式来进行对象的创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一律使用建造者来创建，不对外直接开放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, <span class="type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentBuilder <span class="title function_">builder</span><span class="params">()</span>&#123;   <span class="comment">//通过builder方法直接获取建造者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentBuilder</span>&#123;   <span class="comment">//这里就直接创建一个内部类</span></span><br><span class="line">        <span class="comment">//Builder也需要将所有的参数都进行暂时保存，所以Student怎么定义的这里就怎么定义</span></span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> grade;</span><br><span class="line">        String name;</span><br><span class="line">        String college;</span><br><span class="line">        String profession;</span><br><span class="line">        List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">id</span><span class="params">(<span class="type">int</span> id)</span>&#123;    <span class="comment">//直接调用建造者对应的方法，为对应的属性赋值</span></span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;   <span class="comment">//为了支持链式调用，这里直接返回建造者本身，下同</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      	...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">awards</span><span class="params">(String... awards)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.awards = Arrays.asList(awards);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">build</span><span class="params">()</span>&#123;    <span class="comment">//最后我们只需要调用建造者提供的build方法即可根据我们的配置返回一个对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(id, age, grade, name, college, profession, awards);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们就可以使用建造者来为我们生成对象了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder()   <span class="comment">//获取建造者</span></span><br><span class="line">            .id(<span class="number">1</span>)    <span class="comment">//逐步配置各个参数</span></span><br><span class="line">            .age(<span class="number">18</span>)</span><br><span class="line">            .grade(<span class="number">3</span>)</span><br><span class="line">            .name(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">            .awards(<span class="string">&quot;ICPC-ACM 区域赛 金牌&quot;</span>, <span class="string">&quot;LPL 2022春季赛 冠军&quot;</span>)</span><br><span class="line">            .build();   <span class="comment">//最后直接建造我们想要的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>懒汉式和饿汉式</p>
<p><strong>饿汉式</strong>：在使用这个类时自动进行创建对应实例对象。</p>
<p><strong>懒汉式</strong>：在使用这个类的单例对象初始化方法时才会创建对象。</p>
<p>饿汉式<strong>多线程环境下会有问题！</strong>，如果几个线程同时调用，会被创建多次。为了避免这个问题，最简单的是加一个<code>synchronized</code>锁，但是在高并发情况下效率很低。</p>
<p>优化：在一开始进行if判断，判断需要的单例对象是否为空，但是这样也有可能多个线程同时判断为null进入等锁状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">//内层还要进行一次检查，双重检查锁定</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java中可以使用静态内部类，实现不加锁写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;   <span class="comment">//由静态内部类持有单例对象，但是根据类加载特性，我们仅使用Singleton类时，不会对静态内部类进行初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;   <span class="comment">//只有真正使用内部类时，才会进行类初始化</span></span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;   <span class="comment">//直接获取内部类中的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式与对象的拷贝紧密相关</p>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul>
<li><strong>浅拷贝：</strong> 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象</li>
</ul>
<ul>
<li><strong>深拷贝：</strong> 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>数组相关题目</title>
    <url>/2024/04/22/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="数组总结"><a href="#数组总结" class="headerlink" title="数组总结"></a>数组总结</h1><h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>
<p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p>
<p>举一个字符数组的例子，如图所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png" alt="img"></p>
<ul>
<li><strong>数组的下标都是从0开始的</strong></li>
<li><strong>数组内存空间都是连续的</strong></li>
</ul>
<p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<h2 id="数组的经典题目"><a href="#数组的经典题目" class="headerlink" title="数组的经典题目"></a>数组的经典题目</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p><strong>循环不变量原则</strong></p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p>
<h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><p>寻找合适的边界条件。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>教程</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2024/04/21/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p>
<h3 id="模拟转圈的过程"><a href="#模拟转圈的过程" class="headerlink" title="模拟转圈的过程"></a>模拟转圈的过程</h3><p><strong>边界点的处理</strong>（循环不变量）</p>
<p><code>不变量</code>:对每条边的处理规则 </p>
<p>使用左闭右开，处理第一个节点，不处理最后一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n矩阵大小</span></span><br><span class="line">startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line">offset = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">loop = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(loop &lt;= n / <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = starty; j &lt; n - offset; j++)&#123;</span><br><span class="line">        nums[startx][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = startx; i &lt; n - offset; i++)&#123;</span><br><span class="line">        nums[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; j &gt; starty; j--)&#123;</span><br><span class="line">        nums[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; i &gt; startx; i--)&#123;</span><br><span class="line">        nums[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    startx++;</span><br><span class="line">    starty++;</span><br><span class="line">    offset++;</span><br><span class="line">    loop++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">    nums[i][j] = count;</span><br></pre></td></tr></table></figure>

<p>模拟顺时针画矩阵的过程:</p>
<ul>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上</li>
</ul>
<p>由外向内一圈一圈这么画下去。</p>
<p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p>
<p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p>
<p>那么我按照左闭右开的原则，来画一圈，大家看一下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="number">0</span>, startY = <span class="number">0</span>;  <span class="comment">// 每一圈的起始点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 矩阵中需要填写的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 记录当前的圈数</span></span><br><span class="line">        <span class="type">int</span> i, j; <span class="comment">// j 代表列, i 代表行;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop &lt;= n / <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 顶部</span></span><br><span class="line">            <span class="comment">// 左闭右开，所以判断循环结束时， j 不能等于 n - offset</span></span><br><span class="line">            <span class="keyword">for</span> (j = startY; j &lt; n - offset; j++) &#123;</span><br><span class="line">                nums[startX][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右列</span></span><br><span class="line">            <span class="comment">// 左闭右开，所以判断循环结束时， i 不能等于 n - offset</span></span><br><span class="line">            <span class="keyword">for</span> (i = startX; i &lt; n - offset; i++) &#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 底部</span></span><br><span class="line">            <span class="comment">// 左闭右开，所以判断循环结束时， j != startY</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; startY; j--) &#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左列</span></span><br><span class="line">            <span class="comment">// 左闭右开，所以判断循环结束时， i != startX</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startX; i--) &#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startX++;</span><br><span class="line">            startY++;</span><br><span class="line">            offset++;</span><br><span class="line">            loop++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// n 为奇数时，单独处理矩阵中心的值</span></span><br><span class="line">            nums[startX][startY] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">代码随想录 (programmercarl.com)</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>教程</tag>
        <tag>螺旋矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针之滑动窗口</title>
    <url>/2024/04/20/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="双指针之滑动窗口"><a href="#双指针之滑动窗口" class="headerlink" title="双指针之滑动窗口"></a>双指针之滑动窗口</h1><p>使用一个for循环完成两个for循环，for循环中的变量表示窗口的终止位置。（如何移动起始位置？）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i起始位置，j终止位置，sum当前窗口值大小，subL窗口长度</span></span><br><span class="line">result = max;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">    sum += nums[j];</span><br><span class="line">    <span class="comment">//用while不用if，因为是持续寻找最小窗口的过程</span></span><br><span class="line">    <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">        subL = j - i + <span class="number">1</span>;</span><br><span class="line">        result = Math.min(subL, result);</span><br><span class="line">        sum = sum - nums[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p>
<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p>
<h2 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h2><ul>
<li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>教程</tag>
        <tag>双指针之滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法</title>
    <url>/2024/04/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>一个快指针，一个慢指针。使用一层for循环解决两层for循环做的事情。</p>
<p><code>快指针</code>：寻找新数组所需要的元素</p>
<p><code>慢指针</code>：获取新数组中需要更新的位置，新数组下标值就是慢指针，需要更新的下标值就是慢指针。</p>
<p>​	<img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="27.移除元素-双指针法"></p>
<h4 id="例题：27-移除元素-力扣（LeetCode）"><a href="#例题：27-移除元素-力扣（LeetCode）" class="headerlink" title="例题：27. 移除元素 - 力扣（LeetCode）"></a>例题：<a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素 - 力扣（LeetCode）</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(fast = <span class="number">0</span>; fast &lt; nums.size; fast++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        slow++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br></pre></td></tr></table></figure>

<h2 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h2><ul>
<li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26.删除排序数组中的重复项(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/move-zeroes/">283.移动零(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/backspace-string-compare/">844.比较含退格的字符串(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977.有序数组的平方</a></li>
</ul>
<h3 id="length-length-size-区别"><a href="#length-length-size-区别" class="headerlink" title="length,length(),size()区别"></a>length,length(),size()区别</h3><p>首先区分一下length和length()；</p>
<p><strong>length不是方法，是属性，数组的属性；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span>[] intArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	System.out.println(<span class="string">&quot;这个数组的长度为：&quot;</span> + intArray.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>length()是字符串String的一个方法；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;这个字符串的长度为：&quot;</span> + str.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>size()方法，是List集合的一个方法；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">	list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;这个list的长度为：&quot;</span> + list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p><strong>length——数组的属性；</strong></p>
<p><strong>length()——String的方法；</strong></p>
<p><strong>size()——集合的方法；</strong></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>教程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/2024/04/19/SpringSecurity/</url>
    <content><![CDATA[<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><p>SpringSecurity是一个基于Spring开发的非常强大的权限验证框架，其核心功能包括：</p>
<ul>
<li>认证 （用户登录）</li>
<li>授权 （此用户能够做哪些事情）</li>
<li>攻击防护 （防止伪造身份攻击）</li>
</ul>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="基于内存验证"><a href="#基于内存验证" class="headerlink" title="基于内存验证"></a>基于内存验证</h3><p>直接以代码的形式配置我们网站的用户和密码，配置方式非常简单，只需要在Security配置类中注册一个Bean即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//UserDetailsService就是获取用户信息的服务</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">//每一个UserDetails就代表一个用户信息，其中包含用户的用户名和密码以及角色</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">                .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)  <span class="comment">//角色目前我们不需要关心，随便写就行，后面会专门讲解</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">admin</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">                .username(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user, admin); </span><br><span class="line">      	<span class="comment">//创建一个基于内存的用户信息管理器作为UserDetailsService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>withDefaultPasswordEncoder()被弃用，现在推荐使用BCryptPasswordEncoder()。</p>
<h3 id="基于数据库校验"><a href="#基于数据库校验" class="headerlink" title="基于数据库校验"></a>基于数据库校验</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//手动创建一个AuthenticationManager用于处理密码校验</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(UserDetailsManager manager,</span></span><br><span class="line"><span class="params">                                                        PasswordEncoder encoder)</span>&#123;</span><br><span class="line">        <span class="type">DaoAuthenticationProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoAuthenticationProvider</span>();</span><br><span class="line">        provider.setUserDetailsService(manager);</span><br><span class="line">        provider.setPasswordEncoder(encoder);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProviderManager</span>(provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsManager <span class="title function_">userDetailsService</span><span class="params">(DataSource dataSource,</span></span><br><span class="line"><span class="params">                                                 PasswordEncoder encoder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JdbcUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcUserDetailsManager</span>(dataSource);</span><br><span class="line">      	<span class="comment">//为UserDetailsManager设置AuthenticationManager即可开启重置密码的时的校验</span></span><br><span class="line">        manager.setAuthenticationManager(authenticationManager(manager, encoder));</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h3><p>Service内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> mapper.findUserByName(username);</span><br><span class="line">        <span class="keyword">if</span>(account == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> User</span><br><span class="line">                .withUsername(username)</span><br><span class="line">                .password(account.getPassword())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h2><p>配置config</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  	...</span><br><span class="line">  </span><br><span class="line">		<span class="comment">//如果你学习过SpringSecurity 5.X版本，可能会发现新版本的配置方式完全不一样</span></span><br><span class="line">    <span class="comment">//新版本全部采用lambda形式进行配置，无法再使用之前的and()方法进行连接了</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                <span class="comment">//以下是验证请求拦截和放行配置</span></span><br><span class="line">                .authorizeHttpRequests(auth -&gt; &#123;</span><br><span class="line">                    auth.anyRequest().authenticated();    <span class="comment">//将所有请求全部拦截，一律需要验证</span></span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//以下是表单登录相关配置</span></span><br><span class="line">                .formLogin(conf -&gt; &#123;</span><br><span class="line">                    conf.loginPage(<span class="string">&quot;/login&quot;</span>);   <span class="comment">//将登录页设置为我们自己的登录页面</span></span><br><span class="line">                    conf.loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>); <span class="comment">//登录表单提交的地址，可以自定义</span></span><br><span class="line">                    conf.defaultSuccessUrl(<span class="string">&quot;/&quot;</span>);   <span class="comment">//登录成功后跳转的页面</span></span><br><span class="line">                    conf.permitAll();    <span class="comment">//将登录相关的地址放行，否则未登录的用户连登录界面都进不去</span></span><br><span class="line">                  	<span class="comment">//用户名和密码的表单字段名称，不过默认就是这个，可以不配置，除非有特殊需求</span></span><br><span class="line">                    conf.usernameParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">                    conf.passwordParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遇到<code>302</code>看有没有放行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是csrf相关配置</span></span><br><span class="line">               .csrf(conf -&gt; &#123;</span><br><span class="line">                   conf.disable();   <span class="comment">//此方法可以直接关闭全部的csrf校验，一步到位</span></span><br><span class="line">                   conf.ignoringRequestMatchers(<span class="string">&quot;/xxx/**&quot;</span>);   <span class="comment">//此方法可以根据情况忽略某些地址的csrf校验</span></span><br><span class="line">               &#125;)</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>教程</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式 singleton</title>
    <url>/2024/04/18/%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h2 id="单例模式-singleton"><a href="#单例模式-singleton" class="headerlink" title="单例模式 singleton"></a>单例模式 singleton</h2><p>IOC容器每次创建bean对象，都是同一个。</p>
<p>当Bean的作用域为单例模式时，他会在一开始（容器加载配置时）就被创建，之后拿到的都是这个对象。（可以配置<strong>lazy</strong>懒加载，不在一开始就创建对象）</p>
<h2 id="原型模式-prototype"><a href="#原型模式-prototype" class="headerlink" title="原型模式 prototype"></a>原型模式 prototype</h2><p>每次调用都新建一个对象。</p>
<p>处于原型模式时，只有在被获取时才会被创建，也就是说，在单例模式下Bean会被IOC容器存储，只要容器没有被销毁，那么此对象将会一直存在，而原型模式才相当于在要用的时候直接new一个对象，并不会被保存。</p>
<h1 id="controller控制器"><a href="#controller控制器" class="headerlink" title="controller控制器"></a>controller控制器</h1><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>@RequestMapping(“&#x2F;index”)可以多个路径-&gt;@RequestMapping({“&#x2F;index”, “&#x2F;hello”})</p>
<p>放在当前Controller类名上时，当前controller中的所有Mapping映射前面都需要加一个这个路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/yyds&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/index&quot;, &quot;/test&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路径还支持使用通配符进行匹配：</p>
<ul>
<li><p>?：表示任意一个字符，比如<code>@RequestMapping(&quot;/index/x?&quot;)</code>可以匹配&#x2F;index&#x2F;xa、&#x2F;index&#x2F;xb等等。</p>
</li>
<li><p>*：表示任意0-n个字符，比如<code>@RequestMapping(&quot;/index/*&quot;)</code>可以匹配&#x2F;index&#x2F;lbwnb、&#x2F;index&#x2F;yyds等。</p>
</li>
<li><p>**：表示当前目录或基于当前目录的多级目录，比如<code>@RequestMapping(&quot;/index/**&quot;)</code>可以匹配&#x2F;index、&#x2F;index&#x2F;xxx等。</p>
<p>RequestMapping可以在内部设置method来定义允许访问的类型。也可以直接明确书写 @PostMapping或@GetMapping、@DeletedMapping等</p>
<h2 id="RequestParam和-RequestHeader"><a href="#RequestParam和-RequestHeader" class="headerlink" title="@RequestParam和@RequestHeader"></a>@RequestParam和@RequestHeader</h2><p>获取请求中的参数，只需要在方法上添加一个形参，形参前面加上@RequestParam：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">index</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们需要在<code>@RequestParam</code>中填写参数名称，参数的值会自动传递给形式参数，我们可以直接在方法中使用，注意，如果参数名称与形式参数名称相同，即使不添加<code>@RequestParam</code>也能获取到参数值。</p>
</blockquote>
</li>
</ul>
<p>一旦添加<code>@RequestParam</code>，那么此请求必须携带指定参数，我们也可以将require属性设定为false来将属性设定为非必须。</p>
<h2 id="RestFul风格"><a href="#RestFul风格" class="headerlink" title="RestFul风格"></a>RestFul风格</h2><p>中文释义为<strong>“表现层状态转换”</strong>（名字挺高大上的），它不是一种标准，而是一种设计风格。它的主要作用是充分并正确利用HTTP协议的特性，规范资源获取的URI路径。通俗的讲，RESTful风格的设计允许将参数通过URL拼接传到服务端，目的是让URL看起来更简洁实用，并且我们可以充分使用多种HTTP请求方式（POST&#x2F;GET&#x2F;PUT&#x2F;DELETE），来执行相同请求地址的不同类型操作。</p>
<p>这种风格的连接，我们就可以直接从请求路径中读取参数，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/mvc/index/123456</span><br></pre></td></tr></table></figure>

<p>我们可以直接将index的下一级路径作为请求参数进行处理，也就是说现在的请求参数包含在了请求路径中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/index/&#123;str&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(<span class="meta">@PathVariable</span> String str)</span> &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以按照不同功能进行划分：</p>
<ul>
<li>POST <a href="http://localhost:8080/mvc/index">http://localhost:8080/mvc/index</a> -  添加用户信息，携带表单数据</li>
<li>GET <a href="http://localhost:8080/mvc/index/%7Bid%7D">http://localhost:8080/mvc/index/{id}</a> -  获取用户信息，id直接放在请求路径中</li>
<li>PUT <a href="http://localhost:8080/mvc/index">http://localhost:8080/mvc/index</a> -  修改用户信息，携带表单数据</li>
<li>DELETE <a href="http://localhost:8080/mvc/index/%7Bid%7D">http://localhost:8080/mvc/index/{id}</a> -  删除用户信息，id直接放在请求路径中</li>
</ul>
<p>我们分别编写四个请求映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String text)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取用户：&quot;</span>+text);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">post</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户：&quot;</span>+username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String text)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户：&quot;</span>+text);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index&quot;, method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改用户：&quot;</span>+username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC（对象的创建权）</title>
    <url>/2023/11/20/IOC%EF%BC%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9D%83%EF%BC%89/</url>
    <content><![CDATA[<h2 id="IOC（对象的创建权）"><a href="#IOC（对象的创建权）" class="headerlink" title="IOC（对象的创建权）"></a>IOC（对象的创建权）</h2><p>创建多个Bean来管理类，新建一个容器用来存放Beans，每次要使用哪个类，通过类id去容器里面使用对应的bean创建类。</p>
<p>实现了控制反转，将原来手动创建类变成了交给容器创建。</p>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>singleton和prototype</p>
<p>singleton(单例模式):使用这个模式的Bean创建出来的对象每次就一个，创建多次都是同一个。</p>
<p>prototype(多例模式):使用这个模式的Bean每次创建对象都是创建一个新的对象。</p>
<h2 id="DI（对象的维护权）"><a href="#DI（对象的维护权）" class="headerlink" title="DI（对象的维护权）"></a>DI（对象的维护权）</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>IoC</tag>
        <tag>Spring</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列</title>
    <url>/2023/10/18/%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p><code>class Solution &#123;</code><br>  <code>public long maxKelements(int[] nums, int k) &#123;</code><br><code>​    PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;((a,b) -&gt; b - a);</code><br><code>​    for(int num : nums)&#123;</code><br><code>​      q.offer(num);</code><br><code>​    &#125;</code><br><code>​    long ans = 0;</code><br><code>​    for(int i = 0; i &lt; k ; i++)&#123;</code><br><code>​      int x = q.poll();</code><br><code>​      ans += x;</code><br><code>​      q.offer((x+2) / 3);</code><br><code>​    &#125;</code><br><code>​    return ans;</code><br>  <code>&#125;</code><br><code>&#125;</code></p>
<h3 id="ProiorityQueue-q-优先队列"><a href="#ProiorityQueue-q-优先队列" class="headerlink" title="ProiorityQueue q 优先队列"></a>ProiorityQueue<T> q 优先队列</h3><p>保留了队列先进先出的性质，另外可以通过添加条件来使特定的元素存储在最前面。</p>
<p>（a，b） -&gt; b - a  如果a&lt;b则b-a为正数为真，则符合条件。用来设置这个队列中按照从大到小排列。</p>
<p>String.valueOf(); 可以将对象转换为String类型</p>
<h1 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h1><h2 id="MyISAM不支持行级锁，Innodb支持行级锁。"><a href="#MyISAM不支持行级锁，Innodb支持行级锁。" class="headerlink" title="MyISAM不支持行级锁，Innodb支持行级锁。"></a>MyISAM不支持行级锁，Innodb支持行级锁。</h2><h2 id="在RR-可重复读-情况下，mysql通过两种方式解决幻读问题："><a href="#在RR-可重复读-情况下，mysql通过两种方式解决幻读问题：" class="headerlink" title="在RR(可重复读)情况下，mysql通过两种方式解决幻读问题："></a>在RR(可重复读)情况下，mysql通过两种方式解决幻读问题：</h2><h3 id="在快照读（不加锁）情况下，通过mvcc避免幻读"><a href="#在快照读（不加锁）情况下，通过mvcc避免幻读" class="headerlink" title="在快照读（不加锁）情况下，通过mvcc避免幻读"></a>在快照读（不加锁）情况下，通过mvcc避免幻读</h3><h3 id="在当前读（加锁）情况下，通过next-key避免幻读"><a href="#在当前读（加锁）情况下，通过next-key避免幻读" class="headerlink" title="在当前读（加锁）情况下，通过next-key避免幻读"></a>在当前读（加锁）情况下，通过next-key避免幻读</h3><h3 id="全局锁、表锁和行锁"><a href="#全局锁、表锁和行锁" class="headerlink" title="全局锁、表锁和行锁"></a>全局锁、表锁和行锁</h3><p>从锁的作用范围上划分，分为全局锁、表锁和行锁：</p>
<ul>
<li><strong>全局锁：</strong> 锁作用于全局，整个数据库的所有操作全部受到锁限制。</li>
<li><strong>表锁：</strong> 锁作用于整个表，所有对表的操作都会收到锁限制。</li>
<li><strong>行锁：</strong> 锁作用于表中的某一行，只会通过锁限制对某一行的操作（仅InnoDB支持）</li>
</ul>
<p>全局锁开启后，整个数据库会被上锁，只允许读操作，其他操作被阻塞。</p>
<p>表锁，整个表会被上锁</p>
<p>行锁是仅仅某一行。</p>
<h2 id="行锁被分为记录锁、间隙锁和临键锁"><a href="#行锁被分为记录锁、间隙锁和临键锁" class="headerlink" title="行锁被分为记录锁、间隙锁和临键锁"></a>行锁被分为记录锁、间隙锁和临键锁</h2><h3 id="记录锁：仅仅锁住索引记录的一行，在单条索引记录上加锁。而如果没有索引，会在每个聚集索引后面加写锁，类似于表锁但是原理不同。"><a href="#记录锁：仅仅锁住索引记录的一行，在单条索引记录上加锁。而如果没有索引，会在每个聚集索引后面加写锁，类似于表锁但是原理不同。" class="headerlink" title="记录锁：仅仅锁住索引记录的一行，在单条索引记录上加锁。而如果没有索引，会在每个聚集索引后面加写锁，类似于表锁但是原理不同。"></a>记录锁：仅仅锁住索引记录的一行，在单条索引记录上加锁。而如果没有索引，会在每个聚集索引后面加写锁，类似于表锁但是原理不同。</h3><h3 id="间隙锁：锁住一个区间，在索引记录之间加锁，比如索引1，2-间隙锁加锁区间为（-无穷，1），（1，2），（2，-无穷）"><a href="#间隙锁：锁住一个区间，在索引记录之间加锁，比如索引1，2-间隙锁加锁区间为（-无穷，1），（1，2），（2，-无穷）" class="headerlink" title="间隙锁：锁住一个区间，在索引记录之间加锁，比如索引1，2.间隙锁加锁区间为（-无穷，1），（1，2），（2，+无穷）"></a>间隙锁：锁住一个区间，在索引记录之间加锁，比如索引1，2.间隙锁加锁区间为（-无穷，1），（1，2），（2，+无穷）</h3><h3 id="临键锁：左开右闭区间。例如1，3，5，7-当查询条件只有3时，会锁住3所在的区间。查询条件为3，7时，会锁住3，7之间的区间和他们中包含的索引行，（3，5-和（5，7"><a href="#临键锁：左开右闭区间。例如1，3，5，7-当查询条件只有3时，会锁住3所在的区间。查询条件为3，7时，会锁住3，7之间的区间和他们中包含的索引行，（3，5-和（5，7" class="headerlink" title="临键锁：左开右闭区间。例如1，3，5，7.当查询条件只有3时，会锁住3所在的区间。查询条件为3，7时，会锁住3，7之间的区间和他们中包含的索引行，（3，5]和（5，7]"></a>临键锁：左开右闭区间。例如1，3，5，7.当查询条件只有3时，会锁住3所在的区间。查询条件为3，7时，会锁住3，7之间的区间和他们中包含的索引行，（3，5]和（5，7]</h3>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>教程</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
</search>
